---
id: trading-data-service-estimate-fee
title: "Get an estimate for the fee to be paid for a given order"
description: "Get an estimate for the fee to be paid for a given order"
sidebar_label: "Get an estimate for the fee to be paid for a given order"
hide_title: true
hide_table_of_contents: true
api: {"responses":{"200":{"content":{"application/json":{"schema":{"properties":{"fee":{"title":"Summary of the estimated fees for this order if it were to trade now","properties":{"infrastructureFee":{"title":"Fee amount paid for maintaining the Vega infrastructure","type":"string"},"liquidityFee":{"title":"Fee amount paid to market makers","type":"string"},"makerFee":{"title":"Fee amount paid to the non-aggressive party of the trade","type":"string"}},"type":"object"}},"title":"Response to a EstimateFeeRequest, containing the estimated fees for a given order","type":"object"}}},"description":"A successful response."},"default":{"content":{"application/json":{"schema":{"properties":{"code":{"format":"int32","type":"integer"},"details":{"items":{"additionalProperties":{},"properties":{"@type":{"type":"string"}},"type":"object","title":"protobufAny"},"type":"array"},"message":{"type":"string"}},"type":"object","title":"googlerpcStatus"}}},"description":"An unexpected error response."}},"tags":["TradingDataService"],"operationId":"TradingDataService_EstimateFee","requestBody":{"content":{"application/json":{"schema":{"properties":{"order":{"properties":{"batchId":{"format":"uint64","title":"Batch identifier for the order, used internally for orders submitted during auctions\nto keep track of the auction batch this order falls under (required for fees calculation)","type":"string"},"createdAt":{"format":"int64","title":"Timestamp for when the order was created at, in nanoseconds since the epoch\n- See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`","type":"string"},"expiresAt":{"format":"int64","title":"Timestamp for when the order will expire, in nanoseconds since the epoch\n- See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`, valid only for [`Order.TimeInForce`](#vega.Order.TimeInForce)`.TIME_IN_FORCE_GTT`","type":"string"},"id":{"title":"Unique identifier for the order (set by the system after consensus)","type":"string"},"liquidityProvisionId":{"description":"Is this order created as part of a liquidity provision, will be empty if not.","type":"string"},"marketId":{"title":"Market identifier for the order","type":"string"},"partyId":{"title":"Party identifier for the order","type":"string"},"peggedOrder":{"description":"Pegged order details, used only if the order represents a pegged order.","properties":{"offset":{"title":"Offset from the price reference","type":"string"},"reference":{"title":"Which price point are we linked to","default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"type":"string"}},"title":"Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET\nThey can be used for any limit order that is valid during continuous trading","type":"object"},"price":{"title":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places","type":"string"},"reason":{"title":"If the Order `status` is `STATUS_REJECTED` then an [`OrderError`](#vega.OrderError) reason will be specified\n- The default for this field is `ORDER_ERROR_NONE` which signifies that there were no errors","default":"ORDER_ERROR_UNSPECIFIED","description":"- ORDER_ERROR_UNSPECIFIED: Default value, no error reported\n - ORDER_ERROR_INVALID_MARKET_ID: Order was submitted for a market that does not exist\n - ORDER_ERROR_INVALID_ORDER_ID: Order was submitted with an invalid identifier\n - ORDER_ERROR_OUT_OF_SEQUENCE: Order was amended with a sequence number that was not previous version + 1\n - ORDER_ERROR_INVALID_REMAINING_SIZE: Order was amended with an invalid remaining size (e.g. remaining greater than total size)\n - ORDER_ERROR_TIME_FAILURE: Node was unable to get Vega (blockchain) time\n - ORDER_ERROR_REMOVAL_FAILURE: Failed to remove an order from the book\n - ORDER_ERROR_INVALID_EXPIRATION_DATETIME: An order with `TimeInForce.TIME_IN_FORCE_GTT` was submitted or amended\nwith an expiration that was badly formatted or otherwise invalid\n - ORDER_ERROR_INVALID_ORDER_REFERENCE: Order was submitted or amended with an invalid reference field\n - ORDER_ERROR_EDIT_NOT_ALLOWED: Order amend was submitted for an order field that cannot not be amended (e.g. order identifier)\n - ORDER_ERROR_AMEND_FAILURE: Amend failure because amend details do not match original order\n - ORDER_ERROR_NOT_FOUND: Order not found in an order book or store\n - ORDER_ERROR_INVALID_PARTY_ID: Order was submitted with an invalid or missing party identifier\n - ORDER_ERROR_MARKET_CLOSED: Order was submitted for a market that has closed\n - ORDER_ERROR_MARGIN_CHECK_FAILED: Order was submitted, but the party did not have enough collateral to cover the order\n - ORDER_ERROR_MISSING_GENERAL_ACCOUNT: Order was submitted, but the party did not have an account for this asset\n - ORDER_ERROR_INTERNAL_ERROR: Unspecified internal error\n - ORDER_ERROR_INVALID_SIZE: Order was submitted with an invalid or missing size (e.g. 0)\n - ORDER_ERROR_INVALID_PERSISTENCE: Order was submitted with an invalid persistence for its type\n - ORDER_ERROR_INVALID_TYPE: Order was submitted with an invalid type field\n - ORDER_ERROR_SELF_TRADING: Order was stopped as it would have traded with another order submitted from the same party\n - ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES: Order was submitted, but the party did not have enough collateral to cover the fees for the order\n - ORDER_ERROR_INCORRECT_MARKET_TYPE: Order was submitted with an incorrect or invalid market type\n - ORDER_ERROR_INVALID_TIME_IN_FORCE: Order was submitted with invalid time in force\n - ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION: A GFN order has got to the market when it is in auction mode\n - ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING: A GFA order has got to the market when it is in continuous trading mode\n - ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT: Attempt to amend order to GTT without ExpiryAt\n - ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT: Attempt to amend ExpiryAt to a value before CreatedAt\n - ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT: Attempt to amend to GTC without an ExpiryAt value\n - ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC: Amending to FOK or IOC is invalid\n - ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN: Amending to GFA or GFN is invalid\n - ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN: Amending from GFA or GFN is invalid\n - ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION: IOC orders are not allowed during auction\n - ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION: FOK orders are not allowed during auction\n - ORDER_ERROR_MUST_BE_LIMIT_ORDER: Pegged orders must be LIMIT orders\n - ORDER_ERROR_MUST_BE_GTT_OR_GTC: Pegged orders can only have TIF GTC or GTT\n - ORDER_ERROR_WITHOUT_REFERENCE_PRICE: Pegged order must have a reference price\n - ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE: Buy pegged order cannot reference best ask price\n - ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO: Pegged order offset must be >= 0\n - ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE: Sell pegged order cannot reference best bid price\n - ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO: Pegged order offset must be > zero\n - ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE: The party has an insufficient balance, or does not have\na general account to submit the order (no deposits made\nfor the required asset)\n - ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER: Cannot amend a non pegged orders details\n - ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER: We are unable to re-price a pegged order because a market price is unavailable\n - ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER: It is not possible to amend the price of an existing pegged order\n - ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS: An FOK, IOC, or GFN order was rejected because it resulted in trades outside the price bounds","enum":["ORDER_ERROR_UNSPECIFIED","ORDER_ERROR_INVALID_MARKET_ID","ORDER_ERROR_INVALID_ORDER_ID","ORDER_ERROR_OUT_OF_SEQUENCE","ORDER_ERROR_INVALID_REMAINING_SIZE","ORDER_ERROR_TIME_FAILURE","ORDER_ERROR_REMOVAL_FAILURE","ORDER_ERROR_INVALID_EXPIRATION_DATETIME","ORDER_ERROR_INVALID_ORDER_REFERENCE","ORDER_ERROR_EDIT_NOT_ALLOWED","ORDER_ERROR_AMEND_FAILURE","ORDER_ERROR_NOT_FOUND","ORDER_ERROR_INVALID_PARTY_ID","ORDER_ERROR_MARKET_CLOSED","ORDER_ERROR_MARGIN_CHECK_FAILED","ORDER_ERROR_MISSING_GENERAL_ACCOUNT","ORDER_ERROR_INTERNAL_ERROR","ORDER_ERROR_INVALID_SIZE","ORDER_ERROR_INVALID_PERSISTENCE","ORDER_ERROR_INVALID_TYPE","ORDER_ERROR_SELF_TRADING","ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES","ORDER_ERROR_INCORRECT_MARKET_TYPE","ORDER_ERROR_INVALID_TIME_IN_FORCE","ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION","ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING","ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT","ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT","ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT","ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC","ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN","ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN","ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION","ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION","ORDER_ERROR_MUST_BE_LIMIT_ORDER","ORDER_ERROR_MUST_BE_GTT_OR_GTC","ORDER_ERROR_WITHOUT_REFERENCE_PRICE","ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE","ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO","ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE","ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO","ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE","ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER","ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER","ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER","ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS"],"type":"string"},"reference":{"title":"Reference given for the order, this is typically used to retrieve an order submitted through consensus\n- Currently set internally by the node to return a unique reference identifier for the order submission","type":"string"},"remaining":{"format":"uint64","title":"Size remaining, when this reaches 0 then the order is fully filled and status becomes STATUS_FILLED","type":"string"},"side":{"title":"Side for the order, e.g. SIDE_BUY or SIDE_SELL - See [`Side`](#vega.Side)","default":"SIDE_UNSPECIFIED","description":"- SIDE_UNSPECIFIED: Default value, always invalid\n - SIDE_BUY: Buy order\n - SIDE_SELL: Sell order","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"type":"string"},"size":{"format":"uint64","title":"Size for the order, for example, in a futures market the size equals the number of contracts","type":"string"},"status":{"title":"The current status for the order. See [`Order.Status`](#vega.Order.Status)\n- For detail on `STATUS_REJECTED` please check the [`OrderError`](#vega.OrderError) value given in the `reason` field","default":"STATUS_UNSPECIFIED","description":"Status values for an order\nSee resulting status in [What order types are available to trade on Vega?](https://docs.testnet.vega.xyz/docs/trading-questions/#what-order-types-are-available-to-trade-on-vega) for more detail.\n\n - STATUS_UNSPECIFIED: Default value, always invalid\n - STATUS_ACTIVE: Used for active unfilled or partially filled orders\n - STATUS_EXPIRED: Used for expired GTT orders\n - STATUS_CANCELLED: Used for orders cancelled by the party that created the order\n - STATUS_STOPPED: Used for unfilled FOK or IOC orders, and for orders that were stopped by the network\n - STATUS_FILLED: Used for closed fully filled orders\n - STATUS_REJECTED: Used for orders when not enough collateral was available to fill the margin requirements\n - STATUS_PARTIALLY_FILLED: Used for closed partially filled IOC orders\n - STATUS_PARKED: Order has been removed from the order book and has been parked, this applies to pegged orders only","enum":["STATUS_UNSPECIFIED","STATUS_ACTIVE","STATUS_EXPIRED","STATUS_CANCELLED","STATUS_STOPPED","STATUS_FILLED","STATUS_REJECTED","STATUS_PARTIALLY_FILLED","STATUS_PARKED"],"type":"string"},"timeInForce":{"title":"Time in force indicates how long an order will remain active before it is executed or expires.\n- See [`Order.TimeInForce`](#vega.Order.TimeInForce)","default":"TIME_IN_FORCE_UNSPECIFIED","description":"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled\n - TIME_IN_FORCE_GTT: Good until specified time\n - TIME_IN_FORCE_IOC: Immediate or cancel\n - TIME_IN_FORCE_FOK: Fill or kill\n - TIME_IN_FORCE_GFA: Good for auction\n - TIME_IN_FORCE_GFN: Good for normal","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"type":"string"},"type":{"title":"Type for the order - See [`Order.Type`](#vega.Order.Type)","default":"TYPE_UNSPECIFIED","description":"- TYPE_UNSPECIFIED: Default value, always invalid\n - TYPE_LIMIT: Used for Limit orders\n - TYPE_MARKET: Used for Market orders\n - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"type":"string"},"updatedAt":{"format":"int64","title":"Timestamp for when the Order was last updated, in nanoseconds since the epoch\n- See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`","type":"string"},"version":{"format":"uint64","title":"The version for the order, initial value is version 1 and is incremented after each successful amend","type":"string"}},"title":"An order can be submitted, amended and cancelled on Vega in an attempt to make trades with other parties","type":"object"}},"title":"Request to fetch the estimated fee if an order were to trade immediately","type":"object"}}},"required":true},"description":"Get an estimate for the fee to be paid for a given order","method":"post","path":"/orders/fee/estimate","servers":[{"url":"https://vega.xprv.io/datanode","description":"vega.xprv.io"}],"jsonRequestBodyExample":{"order":{"batchId":"string","createdAt":"string","expiresAt":"string","id":"string","liquidityProvisionId":"string","marketId":"string","partyId":"string","peggedOrder":{"offset":"string","reference":"PEGGED_REFERENCE_UNSPECIFIED"},"price":"string","reason":"ORDER_ERROR_UNSPECIFIED","reference":"string","remaining":"string","side":"SIDE_UNSPECIFIED","size":"string","status":"STATUS_UNSPECIFIED","timeInForce":"TIME_IN_FORCE_UNSPECIFIED","type":"TYPE_UNSPECIFIED","updatedAt":"string","version":"string"}},"info":{"title":"data-node/api/v1/trading_data.proto","version":"0.53.0"},"postman":{"name":"Get an estimate for the fee to be paid for a given order","description":{"type":"text/plain"},"url":{"path":["orders","fee","estimate"],"host":["{{baseUrl}}"],"query":[],"variable":[]},"header":[{"key":"Content-Type","value":"application/json"},{"key":"Accept","value":"application/json"}],"method":"POST","body":{"mode":"raw","raw":"\"\"","options":{"raw":{"language":"json"}}}}}
sidebar_class_name: "post api-method"
info_path: version-v0.53/api/rest/data-v1/data-node-api-v-1-trading-data-proto
custom_edit_url: "https://github.com/vegaprotocol/documentation/issues/new?labels=documentation&title=[Documentation] Requesting changes to 'Get an estimate for the fee to be paid for a given order' (trading-data-service-estimate-fee)"
---

import ApiTabs from "@theme/ApiTabs";
import MimeTabs from "@theme/MimeTabs";
import ParamsItem from "@theme/ParamsItem";
import ResponseSamples from "@theme/ResponseSamples";
import SchemaItem from "@theme/SchemaItem";
import SchemaTabs from "@theme/SchemaTabs";
import DiscriminatorTabs from "@theme/DiscriminatorTabs";
import TabItem from "@theme/TabItem";

## Get an estimate for the fee to be paid for a given order



Get an estimate for the fee to be paid for a given order

<MimeTabs><TabItem label={"application/json"} value={"application/json-schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Request Body</strong><strong style={{"fontSize":"var(--ifm-code-font-size)","color":"var(--openapi-required)"}}> required</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>order</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"batchId"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Batch identifier for the order, used internally for orders submitted during auctions\nto keep track of the auction batch this order falls under (required for fees calculation)","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"createdAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","title":"Timestamp for when the order was created at, in nanoseconds since the epoch\n- See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","title":"Timestamp for when the order will expire, in nanoseconds since the epoch\n- See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`, valid only for [`Order.TimeInForce`](#vega.Order.TimeInForce)`.TIME_IN_FORCE_GTT`","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"id"} required={false} schemaName={"Unique identifier for the order (set by the system after consensus)"} qualifierMessage={undefined} schema={{"title":"Unique identifier for the order (set by the system after consensus)","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"liquidityProvisionId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Is this order created as part of a liquidity provision, will be empty if not.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"Market identifier for the order"} qualifierMessage={undefined} schema={{"title":"Market identifier for the order","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"partyId"} required={false} schemaName={"Party identifier for the order"} qualifierMessage={undefined} schema={{"title":"Party identifier for the order","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>peggedOrder</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Pegged order details, used only if the order represents a pegged order.

</div><SchemaItem collapsible={false} name={"offset"} required={false} schemaName={"Offset from the price reference"} qualifierMessage={undefined} schema={{"title":"Offset from the price reference","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"Which price point are we linked to"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} schema={{"title":"Which price point are we linked to","default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places"} qualifierMessage={undefined} schema={{"title":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reason"} required={false} schemaName={"If the Order `status` is `STATUS_REJECTED` then an [`OrderError`](#vega.OrderError) reason will be specified\n- The default for this field is `ORDER_ERROR_NONE` which signifies that there were no errors"} qualifierMessage={"**Possible values:** [`ORDER_ERROR_UNSPECIFIED`, `ORDER_ERROR_INVALID_MARKET_ID`, `ORDER_ERROR_INVALID_ORDER_ID`, `ORDER_ERROR_OUT_OF_SEQUENCE`, `ORDER_ERROR_INVALID_REMAINING_SIZE`, `ORDER_ERROR_TIME_FAILURE`, `ORDER_ERROR_REMOVAL_FAILURE`, `ORDER_ERROR_INVALID_EXPIRATION_DATETIME`, `ORDER_ERROR_INVALID_ORDER_REFERENCE`, `ORDER_ERROR_EDIT_NOT_ALLOWED`, `ORDER_ERROR_AMEND_FAILURE`, `ORDER_ERROR_NOT_FOUND`, `ORDER_ERROR_INVALID_PARTY_ID`, `ORDER_ERROR_MARKET_CLOSED`, `ORDER_ERROR_MARGIN_CHECK_FAILED`, `ORDER_ERROR_MISSING_GENERAL_ACCOUNT`, `ORDER_ERROR_INTERNAL_ERROR`, `ORDER_ERROR_INVALID_SIZE`, `ORDER_ERROR_INVALID_PERSISTENCE`, `ORDER_ERROR_INVALID_TYPE`, `ORDER_ERROR_SELF_TRADING`, `ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES`, `ORDER_ERROR_INCORRECT_MARKET_TYPE`, `ORDER_ERROR_INVALID_TIME_IN_FORCE`, `ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION`, `ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING`, `ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT`, `ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT`, `ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT`, `ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC`, `ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN`, `ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN`, `ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION`, `ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION`, `ORDER_ERROR_MUST_BE_LIMIT_ORDER`, `ORDER_ERROR_MUST_BE_GTT_OR_GTC`, `ORDER_ERROR_WITHOUT_REFERENCE_PRICE`, `ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE`, `ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO`, `ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE`, `ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO`, `ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE`, `ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER`, `ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER`, `ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER`, `ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS`]"} schema={{"title":"If the Order `status` is `STATUS_REJECTED` then an [`OrderError`](#vega.OrderError) reason will be specified\n- The default for this field is `ORDER_ERROR_NONE` which signifies that there were no errors","default":"ORDER_ERROR_UNSPECIFIED","description":"- ORDER_ERROR_UNSPECIFIED: Default value, no error reported\n - ORDER_ERROR_INVALID_MARKET_ID: Order was submitted for a market that does not exist\n - ORDER_ERROR_INVALID_ORDER_ID: Order was submitted with an invalid identifier\n - ORDER_ERROR_OUT_OF_SEQUENCE: Order was amended with a sequence number that was not previous version + 1\n - ORDER_ERROR_INVALID_REMAINING_SIZE: Order was amended with an invalid remaining size (e.g. remaining greater than total size)\n - ORDER_ERROR_TIME_FAILURE: Node was unable to get Vega (blockchain) time\n - ORDER_ERROR_REMOVAL_FAILURE: Failed to remove an order from the book\n - ORDER_ERROR_INVALID_EXPIRATION_DATETIME: An order with `TimeInForce.TIME_IN_FORCE_GTT` was submitted or amended\nwith an expiration that was badly formatted or otherwise invalid\n - ORDER_ERROR_INVALID_ORDER_REFERENCE: Order was submitted or amended with an invalid reference field\n - ORDER_ERROR_EDIT_NOT_ALLOWED: Order amend was submitted for an order field that cannot not be amended (e.g. order identifier)\n - ORDER_ERROR_AMEND_FAILURE: Amend failure because amend details do not match original order\n - ORDER_ERROR_NOT_FOUND: Order not found in an order book or store\n - ORDER_ERROR_INVALID_PARTY_ID: Order was submitted with an invalid or missing party identifier\n - ORDER_ERROR_MARKET_CLOSED: Order was submitted for a market that has closed\n - ORDER_ERROR_MARGIN_CHECK_FAILED: Order was submitted, but the party did not have enough collateral to cover the order\n - ORDER_ERROR_MISSING_GENERAL_ACCOUNT: Order was submitted, but the party did not have an account for this asset\n - ORDER_ERROR_INTERNAL_ERROR: Unspecified internal error\n - ORDER_ERROR_INVALID_SIZE: Order was submitted with an invalid or missing size (e.g. 0)\n - ORDER_ERROR_INVALID_PERSISTENCE: Order was submitted with an invalid persistence for its type\n - ORDER_ERROR_INVALID_TYPE: Order was submitted with an invalid type field\n - ORDER_ERROR_SELF_TRADING: Order was stopped as it would have traded with another order submitted from the same party\n - ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES: Order was submitted, but the party did not have enough collateral to cover the fees for the order\n - ORDER_ERROR_INCORRECT_MARKET_TYPE: Order was submitted with an incorrect or invalid market type\n - ORDER_ERROR_INVALID_TIME_IN_FORCE: Order was submitted with invalid time in force\n - ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION: A GFN order has got to the market when it is in auction mode\n - ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING: A GFA order has got to the market when it is in continuous trading mode\n - ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT: Attempt to amend order to GTT without ExpiryAt\n - ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT: Attempt to amend ExpiryAt to a value before CreatedAt\n - ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT: Attempt to amend to GTC without an ExpiryAt value\n - ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC: Amending to FOK or IOC is invalid\n - ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN: Amending to GFA or GFN is invalid\n - ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN: Amending from GFA or GFN is invalid\n - ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION: IOC orders are not allowed during auction\n - ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION: FOK orders are not allowed during auction\n - ORDER_ERROR_MUST_BE_LIMIT_ORDER: Pegged orders must be LIMIT orders\n - ORDER_ERROR_MUST_BE_GTT_OR_GTC: Pegged orders can only have TIF GTC or GTT\n - ORDER_ERROR_WITHOUT_REFERENCE_PRICE: Pegged order must have a reference price\n - ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE: Buy pegged order cannot reference best ask price\n - ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO: Pegged order offset must be >= 0\n - ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE: Sell pegged order cannot reference best bid price\n - ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO: Pegged order offset must be > zero\n - ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE: The party has an insufficient balance, or does not have\na general account to submit the order (no deposits made\nfor the required asset)\n - ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER: Cannot amend a non pegged orders details\n - ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER: We are unable to re-price a pegged order because a market price is unavailable\n - ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER: It is not possible to amend the price of an existing pegged order\n - ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS: An FOK, IOC, or GFN order was rejected because it resulted in trades outside the price bounds","enum":["ORDER_ERROR_UNSPECIFIED","ORDER_ERROR_INVALID_MARKET_ID","ORDER_ERROR_INVALID_ORDER_ID","ORDER_ERROR_OUT_OF_SEQUENCE","ORDER_ERROR_INVALID_REMAINING_SIZE","ORDER_ERROR_TIME_FAILURE","ORDER_ERROR_REMOVAL_FAILURE","ORDER_ERROR_INVALID_EXPIRATION_DATETIME","ORDER_ERROR_INVALID_ORDER_REFERENCE","ORDER_ERROR_EDIT_NOT_ALLOWED","ORDER_ERROR_AMEND_FAILURE","ORDER_ERROR_NOT_FOUND","ORDER_ERROR_INVALID_PARTY_ID","ORDER_ERROR_MARKET_CLOSED","ORDER_ERROR_MARGIN_CHECK_FAILED","ORDER_ERROR_MISSING_GENERAL_ACCOUNT","ORDER_ERROR_INTERNAL_ERROR","ORDER_ERROR_INVALID_SIZE","ORDER_ERROR_INVALID_PERSISTENCE","ORDER_ERROR_INVALID_TYPE","ORDER_ERROR_SELF_TRADING","ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES","ORDER_ERROR_INCORRECT_MARKET_TYPE","ORDER_ERROR_INVALID_TIME_IN_FORCE","ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION","ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING","ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT","ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT","ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT","ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC","ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN","ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN","ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION","ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION","ORDER_ERROR_MUST_BE_LIMIT_ORDER","ORDER_ERROR_MUST_BE_GTT_OR_GTC","ORDER_ERROR_WITHOUT_REFERENCE_PRICE","ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE","ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO","ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE","ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO","ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE","ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER","ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER","ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER","ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS"],"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"Reference given for the order, this is typically used to retrieve an order submitted through consensus\n- Currently set internally by the node to return a unique reference identifier for the order submission"} qualifierMessage={undefined} schema={{"title":"Reference given for the order, this is typically used to retrieve an order submitted through consensus\n- Currently set internally by the node to return a unique reference identifier for the order submission","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"remaining"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Size remaining, when this reaches 0 then the order is fully filled and status becomes STATUS_FILLED","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"side"} required={false} schemaName={"Side for the order, e.g. SIDE_BUY or SIDE_SELL - See [`Side`](#vega.Side)"} qualifierMessage={"**Possible values:** [`SIDE_UNSPECIFIED`, `SIDE_BUY`, `SIDE_SELL`]"} schema={{"title":"Side for the order, e.g. SIDE_BUY or SIDE_SELL - See [`Side`](#vega.Side)","default":"SIDE_UNSPECIFIED","description":"- SIDE_UNSPECIFIED: Default value, always invalid\n - SIDE_BUY: Buy order\n - SIDE_SELL: Sell order","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"size"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Size for the order, for example, in a futures market the size equals the number of contracts","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"status"} required={false} schemaName={"The current status for the order. See [`Order.Status`](#vega.Order.Status)\n- For detail on `STATUS_REJECTED` please check the [`OrderError`](#vega.OrderError) value given in the `reason` field"} qualifierMessage={"**Possible values:** [`STATUS_UNSPECIFIED`, `STATUS_ACTIVE`, `STATUS_EXPIRED`, `STATUS_CANCELLED`, `STATUS_STOPPED`, `STATUS_FILLED`, `STATUS_REJECTED`, `STATUS_PARTIALLY_FILLED`, `STATUS_PARKED`]"} schema={{"title":"The current status for the order. See [`Order.Status`](#vega.Order.Status)\n- For detail on `STATUS_REJECTED` please check the [`OrderError`](#vega.OrderError) value given in the `reason` field","default":"STATUS_UNSPECIFIED","description":"Status values for an order\nSee resulting status in [What order types are available to trade on Vega?](https://docs.testnet.vega.xyz/docs/trading-questions/#what-order-types-are-available-to-trade-on-vega) for more detail.\n\n - STATUS_UNSPECIFIED: Default value, always invalid\n - STATUS_ACTIVE: Used for active unfilled or partially filled orders\n - STATUS_EXPIRED: Used for expired GTT orders\n - STATUS_CANCELLED: Used for orders cancelled by the party that created the order\n - STATUS_STOPPED: Used for unfilled FOK or IOC orders, and for orders that were stopped by the network\n - STATUS_FILLED: Used for closed fully filled orders\n - STATUS_REJECTED: Used for orders when not enough collateral was available to fill the margin requirements\n - STATUS_PARTIALLY_FILLED: Used for closed partially filled IOC orders\n - STATUS_PARKED: Order has been removed from the order book and has been parked, this applies to pegged orders only","enum":["STATUS_UNSPECIFIED","STATUS_ACTIVE","STATUS_EXPIRED","STATUS_CANCELLED","STATUS_STOPPED","STATUS_FILLED","STATUS_REJECTED","STATUS_PARTIALLY_FILLED","STATUS_PARKED"],"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaName={"Time in force indicates how long an order will remain active before it is executed or expires.\n- See [`Order.TimeInForce`](#vega.Order.TimeInForce)"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} schema={{"title":"Time in force indicates how long an order will remain active before it is executed or expires.\n- See [`Order.TimeInForce`](#vega.Order.TimeInForce)","default":"TIME_IN_FORCE_UNSPECIFIED","description":"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled\n - TIME_IN_FORCE_GTT: Good until specified time\n - TIME_IN_FORCE_IOC: Immediate or cancel\n - TIME_IN_FORCE_FOK: Fill or kill\n - TIME_IN_FORCE_GFA: Good for auction\n - TIME_IN_FORCE_GFN: Good for normal","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"Type for the order - See [`Order.Type`](#vega.Order.Type)"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_LIMIT`, `TYPE_MARKET`, `TYPE_NETWORK`]"} schema={{"title":"Type for the order - See [`Order.Type`](#vega.Order.Type)","default":"TYPE_UNSPECIFIED","description":"- TYPE_UNSPECIFIED: Default value, always invalid\n - TYPE_LIMIT: Used for Limit orders\n - TYPE_MARKET: Used for Market orders\n - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"updatedAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","title":"Timestamp for when the Order was last updated, in nanoseconds since the epoch\n- See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"The version for the order, initial value is version 1 and is incremented after each successful amend","type":"string"}}></SchemaItem></div></details></SchemaItem></ul></details></TabItem></MimeTabs><div><ApiTabs><TabItem label={"200"} value={"200"}><div>

A successful response.

</div><div><MimeTabs schemaType={"response"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>fee</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"infrastructureFee"} required={false} schemaName={"Fee amount paid for maintaining the Vega infrastructure"} qualifierMessage={undefined} schema={{"title":"Fee amount paid for maintaining the Vega infrastructure","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"liquidityFee"} required={false} schemaName={"Fee amount paid to market makers"} qualifierMessage={undefined} schema={{"title":"Fee amount paid to market makers","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"makerFee"} required={false} schemaName={"Fee amount paid to the non-aggressive party of the trade"} qualifierMessage={undefined} schema={{"title":"Fee amount paid to the non-aggressive party of the trade","type":"string"}}></SchemaItem></div></details></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"fee\": {\n    \"infrastructureFee\": \"string\",\n    \"liquidityFee\": \"string\",\n    \"makerFee\": \"string\"\n  }\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"default"} value={"default"}><div>

An unexpected error response.

</div><div><MimeTabs schemaType={"response"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"code"} required={false} schemaName={"int32"} qualifierMessage={undefined} schema={{"format":"int32","type":"integer"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>details</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"@type"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"message"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"code\": 0,\n  \"details\": [\n    {\n      \"@type\": \"string\"\n    }\n  ],\n  \"message\": \"string\"\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem></ApiTabs></div>
