---
id: block-explorer-list-transactions
title: "List transactions"
description: "List transactions from the Vega blockchain"
sidebar_label: "List transactions"
hide_title: true
hide_table_of_contents: true
api: {"parameters":[{"description":"Number of transactions to be returned from the blockchain.\nThis is deprecated, use first and last instead.","in":"query","name":"limit","required":false,"schema":{"format":"int64","type":"integer"}},{"description":"Optional cursor to paginate the request.","in":"query","name":"before","required":false,"schema":{"type":"string"}},{"description":"Optional cursor to paginate the request.","in":"query","name":"after","required":false,"schema":{"type":"string"}},{"description":"Transaction command types filter, for listing transactions with specified command types.","explode":true,"in":"query","name":"cmdTypes","required":false,"schema":{"items":{"type":"string"},"type":"array"}},{"description":"Transaction command types exclusion filter, for listing all the transactions except the ones with specified command types.","explode":true,"in":"query","name":"excludeCmdTypes","required":false,"schema":{"items":{"type":"string"},"type":"array"}},{"description":"Party IDs filter, can be sender or receiver.","explode":true,"in":"query","name":"parties","required":false,"schema":{"items":{"type":"string"},"type":"array"}},{"description":"Number of transactions to be returned from the blockchain. Use in conjunction with the `after` cursor to paginate forwards.\nOn its own, this will return the first `first` transactions.","in":"query","name":"first","required":false,"schema":{"format":"int64","type":"integer"}},{"description":"Number of transactions to be returned from the blockchain. Use in conjunction with the `before` cursor to paginate backwards.\nOn its own, this will return the last `last` transactions.","in":"query","name":"last","required":false,"schema":{"format":"int64","type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"properties":{"transactions":{"items":{"properties":{"block":{"format":"uint64","title":"Height of the block the transaction was found in","type":"string"},"code":{"format":"int64","title":"Results code of the transaction. 0 indicates the transaction was successful","type":"integer"},"command":{"title":"Actual command of the transaction","description":"Input data for a transaction containing a network command for the Vega network to execute.\nOnce populated the protobuf message should be marshalled into a byte array and included in a transaction message.","properties":{"announceNode":{"description":"Command used by a node operator to announce its node as a pending validator.","properties":{"avatarUrl":{"description":"URL to the node operator's avatar.","type":"string"},"chainPubKey":{"description":"Public key for the blockchain, currently the node's CometBFT key.","type":"string"},"country":{"description":"Country code (ISO 3166-1 alpha-2) for the location of the node.","type":"string"},"ethereumAddress":{"description":"Ethereum public key of the node being announced.","type":"string"},"ethereumSignature":{"description":"Signature from the node made using the ethereum wallet.","properties":{"algo":{"description":"Algorithm used to create the signature.","type":"string"},"value":{"description":"Hex encoded bytes of the signature.","type":"string"},"version":{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}},"type":"object","title":"v1Signature"},"fromEpoch":{"description":"Epoch from which the node is expected to be ready to validate blocks.","format":"uint64","type":"string"},"id":{"description":"Node ID of the validator, which is the node's public master key.","type":"string"},"infoUrl":{"description":"URL to the node operators homepage allowing stake holders to make an informed decision when delegating.","type":"string"},"name":{"description":"Human-readable name of the node.","type":"string"},"submitterAddress":{"description":"Ethereum public key to use as a submitter to allow automatic signature generation.","type":"string"},"vegaPubKey":{"description":"Vega public key of the node being announced.","type":"string"},"vegaPubKeyIndex":{"description":"Vega public key derivation index.","format":"int64","type":"integer"},"vegaSignature":{"description":"Signature from the node made using the Vega wallet.","properties":{"algo":{"description":"Algorithm used to create the signature.","type":"string"},"value":{"description":"Hex encoded bytes of the signature.","type":"string"},"version":{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}},"type":"object","title":"v1Signature"}},"type":"object","title":"v1AnnounceNode"},"applyReferralCode":{"description":"Command to apply a referral code.","properties":{"id":{"description":"Referral code, normally the referral set ID, for the party to join.","type":"string"}},"type":"object","title":"v1ApplyReferralCode"},"batchMarketInstructions":{"description":"Command to submit a batch of order instructions.","properties":{"amendments":{"description":"List of order amendments to be processed sequentially.","items":{"description":"A command that allows a party to update the details of an existing order.\nAny field that is left unset or as a default value indicates that this field on the original order will be left unchanged.\nIt is not possible to change an order's type through this command.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for the new expiry time for the order.","format":"int64","type":"string"},"marketId":{"description":"Market ID that the order was originally submitted to.","type":"string"},"orderId":{"description":"ID of the order to amend.","type":"string"},"peggedOffset":{"description":"New pegged offset for the order.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"},"peggedReference":{"description":"New pegged reference for the order.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"},"price":{"description":"New price for the order. This field is an unsigned integer scaled to the market's decimal places.","type":"string"},"sizeDelta":{"description":"Amend the size for the order by the delta specified:\n- To reduce the size from the current value set a negative integer value\n- To increase the size from the current value, set a positive integer value\n- To leave the size unchanged set a value of zero\nThis field needs to be scaled using the market's position decimal places.","format":"int64","type":"string"},"timeInForce":{"description":"New time in force for the order.","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}},"type":"object","title":"v1OrderAmendment"},"type":"array"},"cancellations":{"description":"List of order cancellations to be processed sequentially.","items":{"description":"A command that instructs the network to cancel orders, active or partially filled, that were previously submitted by the sender of this transaction.\nIt is not possible to cancel another party's order with this command.","properties":{"marketId":{"description":"Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled.","type":"string"},"orderId":{"description":"Restrict cancellations to an order with the given ID. If set, then a market ID must also be provided.","type":"string"}},"type":"object","title":"v1OrderCancellation"},"type":"array"},"stopOrdersCancellation":{"description":"List of stop order cancellations to be processed sequentially.","items":{"description":"A command that instructs the network to cancel untriggered stop orders that were submitted by the sender of this transaction.\nIf any cancelled stop order is part of an OCO, both stop orders will be cancelled.\nIt is not possible to cancel another party's stop orders with this command.","properties":{"marketId":{"description":"Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled.","type":"string"},"stopOrderId":{"description":"Restrict cancellations to a stop order with the given ID. If set, then a market ID must also be provided.","type":"string"}},"type":"object","title":"v1StopOrdersCancellation"},"type":"array"},"stopOrdersSubmission":{"description":"List of stop order submissions to be processed sequentially.","items":{"description":"A command that allows a party to submit a stop order for a given market.\nA stop order is a normal order that remains off the order book and is only submitted if a given trigger is breached from a particular direction.\nIf both rises-above and falls-below are configured, then if one is triggered the other will be cancelled (OCO).","properties":{"fallsBelow":{"description":"Stop order that will be triggered if the price falls below a given trigger price.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire.","format":"int64","type":"string"},"expiryStrategy":{"description":"Strategy to adopt if the expiry time is reached.","default":"EXPIRY_STRATEGY_UNSPECIFIED","enum":["EXPIRY_STRATEGY_UNSPECIFIED","EXPIRY_STRATEGY_CANCELS","EXPIRY_STRATEGY_SUBMIT"],"type":"string","title":"StopOrderExpiryStrategy"},"orderSubmission":{"description":"Order to be submitted once the trigger is breached.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"},"icebergOpts":{"description":"Iceberg order details. If set, the order will exist on the order book in chunks.","properties":{"minimumVisibleSize":{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"},"peakSize":{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}},"title":"Iceberg order options","type":"object"},"marketId":{"description":"Market ID to submit the order to.","type":"string"},"peggedOrder":{"description":"Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.","properties":{"offset":{"description":"Offset from the price reference.","type":"string"},"reference":{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}},"title":"Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET\nThey can be used for any limit order that is valid during continuous trading","type":"object"},"postOnly":{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"},"price":{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"},"reduceOnly":{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"},"reference":{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"},"side":{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"},"size":{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"},"timeInForce":{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"},"type":{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}},"type":"object","title":"v1OrderSubmission"},"price":{"description":"Order will be submitted if the last traded price on the market breaches the given price.","type":"string"},"trailingPercentOffset":{"description":"Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted.","type":"string"}},"type":"object","title":"v1StopOrderSetup"},"risesAbove":{"description":"Stop order that will be triggered if the price rises above a given trigger price.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire.","format":"int64","type":"string"},"expiryStrategy":{"description":"Strategy to adopt if the expiry time is reached.","default":"EXPIRY_STRATEGY_UNSPECIFIED","enum":["EXPIRY_STRATEGY_UNSPECIFIED","EXPIRY_STRATEGY_CANCELS","EXPIRY_STRATEGY_SUBMIT"],"type":"string","title":"StopOrderExpiryStrategy"},"orderSubmission":{"description":"Order to be submitted once the trigger is breached.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"},"icebergOpts":{"description":"Iceberg order details. If set, the order will exist on the order book in chunks.","properties":{"minimumVisibleSize":{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"},"peakSize":{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}},"title":"Iceberg order options","type":"object"},"marketId":{"description":"Market ID to submit the order to.","type":"string"},"peggedOrder":{"description":"Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.","properties":{"offset":{"description":"Offset from the price reference.","type":"string"},"reference":{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}},"title":"Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET\nThey can be used for any limit order that is valid during continuous trading","type":"object"},"postOnly":{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"},"price":{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"},"reduceOnly":{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"},"reference":{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"},"side":{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"},"size":{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"},"timeInForce":{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"},"type":{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}},"type":"object","title":"v1OrderSubmission"},"price":{"description":"Order will be submitted if the last traded price on the market breaches the given price.","type":"string"},"trailingPercentOffset":{"description":"Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted.","type":"string"}},"type":"object","title":"v1StopOrderSetup"}},"type":"object","title":"v1StopOrdersSubmission"},"type":"array"},"submissions":{"description":"List of order submissions to be processed sequentially.","items":{"description":"A command that submits an order to the Vega network for a given market.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"},"icebergOpts":{"description":"Iceberg order details. If set, the order will exist on the order book in chunks.","properties":{"minimumVisibleSize":{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"},"peakSize":{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}},"title":"Iceberg order options","type":"object"},"marketId":{"description":"Market ID to submit the order to.","type":"string"},"peggedOrder":{"description":"Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.","properties":{"offset":{"description":"Offset from the price reference.","type":"string"},"reference":{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}},"title":"Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET\nThey can be used for any limit order that is valid during continuous trading","type":"object"},"postOnly":{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"},"price":{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"},"reduceOnly":{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"},"reference":{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"},"side":{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"},"size":{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"},"timeInForce":{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"},"type":{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}},"type":"object","title":"v1OrderSubmission"},"type":"array"}},"type":"object","title":"v1BatchMarketInstructions"},"blockHeight":{"description":"Block height which has been used to calculate the transaction proof-of-work.","format":"uint64","type":"string"},"cancelTransfer":{"description":"Command to cancel a recurring transfer.","properties":{"transferId":{"description":"Transfer ID of the transfer to cancel.","type":"string"}},"type":"object","title":"commandsv1CancelTransfer"},"chainEvent":{"description":"Validator command sent automatically to notify the Vega chain of an off-chain event.","properties":{"builtin":{"description":"Built-in asset event.","properties":{"deposit":{"description":"Built-in asset deposit.","properties":{"amount":{"description":"Amount to be deposited. This field is an unsigned integer scaled to the asset's decimal places.","type":"string"},"partyId":{"description":"Vega party ID i.e. public key.","type":"string"},"vegaAssetId":{"description":"Vega network internal asset ID.","type":"string"}},"title":"Deposit for a Vega built-in asset","type":"object"},"withdrawal":{"description":"Built-in asset withdrawal.","properties":{"amount":{"description":"The amount to be withdrawn. This field is an unsigned integer scaled to the asset's decimal places.","type":"string"},"partyId":{"description":"Vega network party ID i.e. public key.","type":"string"},"vegaAssetId":{"description":"Vega network internal asset ID.","type":"string"}},"title":"Withdrawal for a Vega built-in asset","type":"object"}},"title":"Event related to a Vega built-in asset","type":"object"},"contractCall":{"description":"Ethereum contract call event.","properties":{"blockHeight":{"description":"Ethereum block height.","format":"uint64","type":"string"},"blockTime":{"description":"Ethereum block time in Unix seconds.","format":"uint64","type":"string"},"error":{"description":"Error message if the call failed.","type":"string"},"result":{"description":"Result of contract call, packed according to the ABI stored in the associated data source spec.","format":"byte","type":"string"},"specId":{"description":"ID of the data source spec that triggered this contract call.","type":"string"}},"title":"Result of calling an arbitrary Ethereum contract method","type":"object"},"erc20":{"description":"Ethereum ERC20 event.","properties":{"assetDelist":{"description":"De-list an ERC20 asset.","properties":{"vegaAssetId":{"description":"Vega network internal asset ID.","type":"string"}},"title":"Asset deny-listing for an ERC20 token","type":"object"},"assetLimitsUpdated":{"description":"Update an ERC20 asset.","properties":{"lifetimeLimits":{"description":"Updated lifetime limits.","type":"string"},"sourceEthereumAddress":{"description":"Ethereum wallet that initiated the deposit.","type":"string"},"vegaAssetId":{"description":"Vega network internal asset ID.","type":"string"},"withdrawThreshold":{"description":"Updated withdrawal threshold.","type":"string"}},"type":"object","title":"vegaERC20AssetLimitsUpdated"},"assetList":{"description":"List an ERC20 asset.","properties":{"assetSource":{"description":"Ethereum address of the asset.","type":"string"},"vegaAssetId":{"description":"Vega network internal asset ID.","type":"string"}},"title":"Asset allow-listing for an ERC20 token","type":"object"},"block":{"description":"Block in which the transaction was added.","format":"uint64","type":"string"},"bridgeResumed":{"description":"Bridge operations has been resumed.","type":"boolean"},"bridgeStopped":{"description":"Bridge operations has been stopped.","type":"boolean"},"deposit":{"description":"Deposit ERC20 asset.","properties":{"amount":{"description":"Amount to be deposited.","type":"string"},"sourceEthereumAddress":{"description":"Ethereum wallet that initiated the deposit.","type":"string"},"targetPartyId":{"description":"Vega party ID i.e. public key that is the target of the deposit.","type":"string"},"vegaAssetId":{"description":"Vega network internal asset ID.","type":"string"}},"title":"Asset deposit for an ERC20 token","type":"object"},"index":{"description":"Index of the log in the transaction.","format":"uint64","type":"string"},"withdrawal":{"description":"Withdraw ERC20 asset.","properties":{"referenceNonce":{"description":"Reference nonce used for the transaction.","type":"string"},"targetEthereumAddress":{"description":"Target Ethereum wallet address.","type":"string"},"vegaAssetId":{"description":"Vega network internal asset ID.","type":"string"}},"title":"Asset withdrawal for an ERC20 token","type":"object"}},"title":"Event related to an ERC20 token","type":"object"},"erc20Multisig":{"description":"Ethereum ERC20 multisig event.","properties":{"block":{"format":"uint64","title":"Block in which the transaction was added","type":"string"},"index":{"format":"uint64","title":"Index of the log in the transaction","type":"string"},"signerAdded":{"title":"Add a signer to the erc20 bridge","properties":{"blockTime":{"description":"Time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable.","format":"int64","type":"string"},"newSigner":{"title":"Ethereum address of the new signer","type":"string"},"nonce":{"title":"Nonce created by the Vega network used for this new signer","type":"string"}},"type":"object"},"signerRemoved":{"title":"Remove a signer from the erc20 bridge","properties":{"blockTime":{"description":"Time at which the block was produced.\nWill be used to inform the core at what time\nthe stake was made unavailable.","format":"int64","type":"string"},"nonce":{"title":"Nonce created by the Vega network used for this old signer","type":"string"},"oldSigner":{"title":"Ethereum address of the old signer","type":"string"}},"type":"object"},"thresholdSet":{"title":"Threshold set","properties":{"blockTime":{"description":"Time at which the block was produced.\nWill be used to inform the core at what time\nthe stake was made unavailable.","format":"int64","type":"string"},"newThreshold":{"format":"int64","title":"New threshold value to set","type":"integer"},"nonce":{"title":"Nonce created by the Vega network","type":"string"}},"type":"object"}},"title":"Event related to the ERC20 MultiSig","type":"object"},"nonce":{"description":"Arbitrary one-time integer used to prevent replay attacks.","format":"uint64","type":"string"},"stakingEvent":{"description":"Ethereum Staking event.","properties":{"block":{"description":"Block in which the transaction was added.","format":"uint64","type":"string"},"index":{"description":"Index of the log in the transaction.","format":"uint64","type":"string"},"stakeDeposited":{"properties":{"amount":{"description":"Amount deposited as an unsigned base 10 integer scaled to the asset's decimal places.","type":"string"},"blockTime":{"description":"Time at which the block was produced.\nWill be used to inform the core at what time\nthe stake started to be available.","format":"int64","type":"string"},"ethereumAddress":{"title":"Ethereum Address of the user depositing stake (hex encode with 0x prefix)","type":"string"},"vegaPublicKey":{"description":"Hex encoded public key of the party receiving the stake deposit.","type":"string"}},"type":"object","title":"vegaStakeDeposited"},"stakeRemoved":{"properties":{"amount":{"description":"Amount removed as a base 10 unsigned integer scaled to the asset's decimal places.","type":"string"},"blockTime":{"description":"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable.","format":"int64","type":"string"},"ethereumAddress":{"description":"Ethereum address of the user removing stake. This should be hex encoded with 0x prefix.","type":"string"},"vegaPublicKey":{"description":"Hex encoded public key of the party from which to remove stake.","type":"string"}},"type":"object","title":"vegaStakeRemoved"},"totalSupply":{"properties":{"tokenAddress":{"title":"Address of the staking asset","type":"string"},"totalSupply":{"description":"Total supply observed for the token as an unsigned based 10 integer scaled to the asset's decimal places.","type":"string"}},"type":"object","title":"vegaStakeTotalSupply"}},"type":"object","title":"vegaStakingEvent"},"txId":{"description":"ID of the transaction on the foreign chain that caused the event.","type":"string"}},"type":"object","title":"v1ChainEvent"},"createReferralSet":{"description":"Command to create a referral set.","properties":{"isTeam":{"description":"Whether or not the referral set should be considered a team that can participate in team games on the network.","type":"boolean"},"team":{"description":"Team details, if the referral set is to be considered a team.","properties":{"avatarUrl":{"description":"External link to an avatar for the team.","type":"string"},"closed":{"description":"Whether or not the team is closed to new party members.","type":"boolean"},"name":{"description":"Name of the team.","type":"string"},"teamUrl":{"description":"External link to the team's homepage.","type":"string"}},"type":"object","title":"v1CreateReferralSetTeam"}},"type":"object","title":"v1CreateReferralSet"},"delegateSubmission":{"description":"Command to delegate tokens to a validator.","properties":{"amount":{"description":"Amount of stake to delegate, as an unsigned integer scaled to the governance asset's decimal places.","type":"string"},"nodeId":{"description":"Node ID to delegate stake to.","type":"string"}},"type":"object","title":"v1DelegateSubmission"},"ethereumKeyRotateSubmission":{"description":"Validator command sent manually by a node operator to rotate their node's Ethereum keys.","properties":{"currentAddress":{"description":"Ethereum address of the node's current Ethereum keys.","type":"string"},"ethereumSignature":{"description":"Signature signed by the new Ethereum key that can be verified to prove ownership.","properties":{"algo":{"description":"Algorithm used to create the signature.","type":"string"},"value":{"description":"Hex encoded bytes of the signature.","type":"string"},"version":{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}},"type":"object","title":"v1Signature"},"newAddress":{"description":"Ethereum address that is being rotated to.","type":"string"},"submitterAddress":{"description":"Ethereum public key to use as a submitter to allow automatic signature generation.","type":"string"},"targetBlock":{"description":"Block height at which the key rotation will take effect.","format":"uint64","type":"string"}},"type":"object","title":"v1EthereumKeyRotateSubmission"},"issueSignatures":{"description":"Command to request signatures to amend the multisig-control contract.","properties":{"kind":{"description":"What kind of signatures to generate, namely for whether a signer is being added or removed.","default":"NODE_SIGNATURE_KIND_UNSPECIFIED","enum":["NODE_SIGNATURE_KIND_UNSPECIFIED","NODE_SIGNATURE_KIND_ASSET_NEW","NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED","NODE_SIGNATURE_KIND_ASSET_UPDATE"],"title":"Kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc","type":"string"},"submitter":{"description":"Ethereum address which will submit the signatures to the smart contract.","type":"string"},"validatorNodeId":{"description":"Node ID of the validator node that will be signed in or out of the smart contract.","type":"string"}},"type":"object","title":"v1IssueSignatures"},"keyRotateSubmission":{"description":"Validator command sent manually by a node operator to rotate their node's Vega keys.","properties":{"currentPubKeyHash":{"description":"Hash of the node's current Vega public key.","type":"string"},"newPubKey":{"description":"Vega public key that would be rotated to.","type":"string"},"newPubKeyIndex":{"description":"New Vega public key derivation index.","format":"int64","type":"integer"},"targetBlock":{"description":"Block height at which the key rotation will take effect.","format":"uint64","type":"string"}},"type":"object","title":"v1KeyRotateSubmission"},"liquidityProvisionAmendment":{"description":"Command to amend a liquidity commitment.","properties":{"commitmentAmount":{"description":"New commitment amount.","type":"string"},"fee":{"description":"New nominated liquidity fee factor.","type":"string"},"marketId":{"description":"Market that the submitter wants to amend the liquidity commitment for.","type":"string"},"reference":{"description":"New arbitrary reference to be added to every order created out of this liquidity provision submission.","type":"string"}},"type":"object","title":"v1LiquidityProvisionAmendment"},"liquidityProvisionCancellation":{"description":"Command to cancel a liquidity commitment.","properties":{"marketId":{"description":"Market that the submitter will stop providing liquidity for.","type":"string"}},"type":"object","title":"v1LiquidityProvisionCancellation"},"liquidityProvisionSubmission":{"description":"Command to submit a liquidity commitment.","properties":{"commitmentAmount":{"description":"Amount that the submitter will commit as liquidity to the market, specified as a unitless number in the settlement asset of the market.\nThis field is an unsigned integer scaled using the asset's decimal places.","type":"string"},"fee":{"description":"Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers.","type":"string"},"marketId":{"description":"Market that the submitter wishes to provide liquidity for.","type":"string"},"reference":{"description":"Arbitrary reference to be added to every order created out of this liquidity provision submission.","type":"string"}},"type":"object","title":"v1LiquidityProvisionSubmission"},"nodeSignature":{"description":"Validator command sent automatically to provide signatures for the Ethereum bridge.","properties":{"id":{"description":"ID of the resource that the signature relates to.","type":"string"},"kind":{"description":"Kind of resource being signed.","default":"NODE_SIGNATURE_KIND_UNSPECIFIED","enum":["NODE_SIGNATURE_KIND_UNSPECIFIED","NODE_SIGNATURE_KIND_ASSET_NEW","NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED","NODE_SIGNATURE_KIND_ASSET_UPDATE"],"title":"Kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc","type":"string"},"sig":{"description":"Signature generated by the node.","format":"byte","type":"string"}},"type":"object","title":"v1NodeSignature"},"nodeVote":{"description":"Validator command sent automatically to vote on that validity of an external resource.","properties":{"reference":{"description":"Reference identifying the resource that has been verified.","type":"string"},"type":{"description":"Type of external event that has been verified.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_STAKE_DEPOSITED","TYPE_STAKE_REMOVED","TYPE_FUNDS_DEPOSITED","TYPE_SIGNER_ADDED","TYPE_SIGNER_REMOVED","TYPE_BRIDGE_STOPPED","TYPE_BRIDGE_RESUMED","TYPE_ASSET_LISTED","TYPE_LIMITS_UPDATED","TYPE_STAKE_TOTAL_SUPPLY","TYPE_SIGNER_THRESHOLD_SET","TYPE_GOVERNANCE_VALIDATE_ASSET","TYPE_ETHEREUM_CONTRACT_CALL_RESULT"],"title":"- TYPE_UNSPECIFIED: Represents an unspecified or missing value from the input\n - TYPE_STAKE_DEPOSITED: Node vote for a new stake deposit\n - TYPE_STAKE_REMOVED: Node vote for a new stake removed event\n - TYPE_FUNDS_DEPOSITED: Node vote for a new collateral deposit\n - TYPE_SIGNER_ADDED: Node vote for a new signer added to the erc20 bridge\n - TYPE_SIGNER_REMOVED: Node vote for a signer removed from the erc20 bridge\n - TYPE_BRIDGE_STOPPED: Node vote for a bridge stopped event\n - TYPE_BRIDGE_RESUMED: Node vote for a bridge resumed event\n - TYPE_ASSET_LISTED: Node vote for a newly listed asset\n - TYPE_LIMITS_UPDATED: Node vote for an asset limits update\n - TYPE_STAKE_TOTAL_SUPPLY: Node vote to share the total supply of the staking token\n - TYPE_SIGNER_THRESHOLD_SET: Node vote to update the threshold of the signer set for the multisig contract\n - TYPE_GOVERNANCE_VALIDATE_ASSET: Node vote to validate a new assert governance proposal\n - TYPE_ETHEREUM_CONTRACT_CALL_RESULT: Node vote for an Ethereum contract call result","type":"string"}},"type":"object","title":"v1NodeVote"},"nonce":{"description":"Arbitrary number used to provide uniqueness to the signature of two otherwise identical input data, preventing replay attacks.\nMust be set to a different value for all new transactions sent by a party. It is advised to generate this number randomly.","format":"uint64","type":"string"},"oracleDataSubmission":{"description":"Command to submit external oracle data.","properties":{"payload":{"description":"Data provided by the data source.","format":"byte","type":"string"},"source":{"description":"Source from which the data is coming from.","default":"ORACLE_SOURCE_UNSPECIFIED","enum":["ORACLE_SOURCE_UNSPECIFIED","ORACLE_SOURCE_OPEN_ORACLE","ORACLE_SOURCE_JSON","ORACLE_SOURCE_ETHEREUM"],"title":"Supported oracle sources","type":"string"}},"title":"Command to submit new oracle data from third party providers","type":"object"},"orderAmendment":{"description":"A command that allows a party to update the details of an existing order.\nAny field that is left unset or as a default value indicates that this field on the original order will be left unchanged.\nIt is not possible to change an order's type through this command.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for the new expiry time for the order.","format":"int64","type":"string"},"marketId":{"description":"Market ID that the order was originally submitted to.","type":"string"},"orderId":{"description":"ID of the order to amend.","type":"string"},"peggedOffset":{"description":"New pegged offset for the order.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"},"peggedReference":{"description":"New pegged reference for the order.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"},"price":{"description":"New price for the order. This field is an unsigned integer scaled to the market's decimal places.","type":"string"},"sizeDelta":{"description":"Amend the size for the order by the delta specified:\n- To reduce the size from the current value set a negative integer value\n- To increase the size from the current value, set a positive integer value\n- To leave the size unchanged set a value of zero\nThis field needs to be scaled using the market's position decimal places.","format":"int64","type":"string"},"timeInForce":{"description":"New time in force for the order.","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}},"type":"object","title":"v1OrderAmendment"},"orderCancellation":{"description":"A command that instructs the network to cancel orders, active or partially filled, that were previously submitted by the sender of this transaction.\nIt is not possible to cancel another party's order with this command.","properties":{"marketId":{"description":"Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled.","type":"string"},"orderId":{"description":"Restrict cancellations to an order with the given ID. If set, then a market ID must also be provided.","type":"string"}},"type":"object","title":"v1OrderCancellation"},"orderSubmission":{"description":"A command that submits an order to the Vega network for a given market.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"},"icebergOpts":{"description":"Iceberg order details. If set, the order will exist on the order book in chunks.","properties":{"minimumVisibleSize":{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"},"peakSize":{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}},"title":"Iceberg order options","type":"object"},"marketId":{"description":"Market ID to submit the order to.","type":"string"},"peggedOrder":{"description":"Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.","properties":{"offset":{"description":"Offset from the price reference.","type":"string"},"reference":{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}},"title":"Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET\nThey can be used for any limit order that is valid during continuous trading","type":"object"},"postOnly":{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"},"price":{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"},"reduceOnly":{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"},"reference":{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"},"side":{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"},"size":{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"},"timeInForce":{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"},"type":{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}},"type":"object","title":"v1OrderSubmission"},"proposalSubmission":{"description":"Command to submit a governance proposal.","properties":{"rationale":{"description":"Rationale behind a proposal.","properties":{"description":{"description":"Description to show a short title / something in case the link goes offline.\nThis is to be between 0 and 20k unicode characters.\nThis is mandatory for all proposals.","type":"string"},"title":{"description":"Title to be used to give a short description of the proposal in lists.\nThis is to be between 0 and 100 unicode characters.\nThis is mandatory for all proposals.","type":"string"}},"type":"object","title":"vegaProposalRationale"},"reference":{"description":"Arbitrary human-readable reference identifying the proposal.","type":"string"},"terms":{"description":"Proposal terms containing the type and details of the proposal, as well as time spans for voting and enactment.","properties":{"cancelTransfer":{"description":"Cancel a governance transfer.","properties":{"changes":{"title":"Configuration for cancellation of a governance-initiated transfer","properties":{"transferId":{"description":"ID of the governance transfer proposal.","type":"string"}},"type":"object"}},"type":"object","title":"vegaCancelTransfer"},"closingTimestamp":{"description":"Timestamp as Unix time in seconds when voting closes for this proposal,\nconstrained by `minClose` and `maxClose` network parameters.","format":"int64","type":"string"},"enactmentTimestamp":{"description":"Timestamp as Unix time in seconds when proposal gets enacted if passed,\nconstrained by `minEnact` and `maxEnact` network parameters.","format":"int64","type":"string"},"newAsset":{"description":"Proposal change for creating new assets on Vega.","properties":{"changes":{"description":"Configuration of the new asset.","properties":{"builtinAsset":{"description":"Vega built-in asset.","properties":{"maxFaucetAmountMint":{"description":"Maximum amount that can be requested by a party through the built-in asset faucet at a time.","type":"string"}},"title":"Vega internal asset","type":"object"},"decimals":{"description":"Number of decimal / precision handled by this asset.","format":"uint64","type":"string"},"erc20":{"description":"Ethereum ERC20 asset.","properties":{"contractAddress":{"description":"Address of the contract for the token, on the ethereum network.","type":"string"},"lifetimeLimit":{"description":"Lifetime limits deposit per address\nnote: this is a temporary measure that can be changed by governance.","type":"string"},"withdrawThreshold":{"description":"Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.\nThere’s no limit on the size of a withdrawal\nnote: this is a temporary measure that can be changed by governance.","type":"string"}},"title":"ERC20 token based asset, living on the ethereum network","type":"object"},"name":{"description":"Name of the asset (e.g: Great British Pound).","type":"string"},"quantum":{"description":"Minimum economically meaningful amount in the asset.","type":"string"},"symbol":{"description":"Symbol of the asset (e.g: GBP).","type":"string"}},"title":"Vega representation of an external asset","type":"object"}},"title":"New asset on Vega","type":"object"},"newFreeform":{"description":"Proposal change for a freeform request, which can be voted on but does not change the behaviour of the system,\nand can be used to gauge community sentiment.","type":"object","title":"vegaNewFreeform"},"newMarket":{"description":"Proposal change for creating new futures market on Vega.","properties":{"changes":{"description":"Configuration of the new market.","properties":{"decimalPlaces":{"description":"Decimal places used for the new futures market, sets the smallest price increment on the book.","format":"uint64","type":"string"},"instrument":{"description":"New futures market instrument configuration.","properties":{"code":{"description":"Instrument code, human-readable shortcode used to describe the instrument.","type":"string"},"future":{"description":"Future.","properties":{"dataSourceSpecBinding":{"description":"Binding between the data source spec and the settlement data.","properties":{"settlementDataProperty":{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement data.","type":"string"},"tradingTerminationProperty":{"description":"Name of the property in the data source data that signals termination of trading.","type":"string"}},"title":"DataSourceSpecToFutureBinding describes which property of the data source data is to be\nused as settlement data and which to use as the trading terminated trigger","type":"object"},"dataSourceSpecForSettlementData":{"description":"Data source spec describing the data source for settlement.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"dataSourceSpecForTradingTermination":{"description":"The external data source spec describing the data source of trading termination.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"quoteName":{"description":"Product quote name.","type":"string"},"settlementAsset":{"description":"Asset ID for the product's settlement asset.","type":"string"}},"title":"Future product configuration","type":"object"},"name":{"description":"Instrument name.","type":"string"},"perpetual":{"description":"Perpetual.","properties":{"clampLowerBound":{"description":"Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"},"clampUpperBound":{"description":"Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"},"dataSourceSpecBinding":{"description":"Binding between the data source spec and the settlement data.","properties":{"settlementDataProperty":{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"},"settlementScheduleProperty":{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"}},"title":"Describes which property of the data source data is to be\nused as settlement data and which to use as the trading terminated trigger","type":"object"},"dataSourceSpecForSettlementData":{"description":"Data source spec describing the data source for settlement.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"dataSourceSpecForSettlementSchedule":{"description":"Data source spec describing the data source for settlement schedule.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"interestRate":{"description":"Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1].","type":"string"},"marginFundingFactor":{"description":"Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1].","type":"string"},"quoteName":{"description":"Product quote name.","type":"string"},"settlementAsset":{"description":"Asset ID for the product's settlement asset.","type":"string"}},"title":"Perpetual product configuration","type":"object"},"spot":{"description":"Spot.","properties":{"baseAsset":{"description":"Base asset ID.","type":"string"},"name":{"description":"Product name.","type":"string"},"quoteAsset":{"description":"Quote asset ID.","type":"string"}},"title":"Spot product configuration","type":"object"}},"title":"Instrument configuration","type":"object"},"linearSlippageFactor":{"description":"Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume.","type":"string"},"liquidityMonitoringParameters":{"description":"Liquidity monitoring parameters.","properties":{"auctionExtension":{"description":"Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction.","format":"int64","type":"string"},"targetStakeParameters":{"description":"Specifies parameters related to target stake calculation.","properties":{"scalingFactor":{"description":"Specifies scaling factors used in target stake calculation.","format":"double","type":"number"},"timeWindow":{"description":"Specifies length of time window expressed in seconds for target stake calculation.","format":"int64","type":"string"}},"title":"TargetStakeParameters contains parameters used in target stake calculation","type":"object"},"triggeringRatio":{"description":"Specifies the triggering ratio for entering liquidity auction.","type":"string"}},"title":"LiquidityMonitoringParameters contains settings used for liquidity monitoring","type":"object"},"liquiditySlaParameters":{"title":"Liquidity SLA parameters","properties":{"commitmentMinTimeFraction":{"description":"Specifies the minimum fraction of time LPs must spend \"on the book\" providing their committed liquidity.","type":"string"},"performanceHysteresisEpochs":{"description":"Specifies the number of liquidity epochs over which past performance will continue to affect rewards.","format":"uint64","type":"string"},"priceRange":{"type":"string"},"slaCompetitionFactor":{"description":"Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers\nthat achieved a higher SLA performance than them.","type":"string"}},"type":"object"},"logNormal":{"description":"Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected.","properties":{"params":{"description":"Risk model parameters for log normal.","properties":{"mu":{"description":"Mu parameter, annualised growth rate of the underlying asset.","format":"double","type":"number"},"r":{"description":"R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.","format":"double","type":"number"},"sigma":{"description":"Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.","format":"double","type":"number"}},"title":"Risk model parameters for log normal","type":"object"},"riskAversionParameter":{"description":"Risk Aversion Parameter.","format":"double","type":"number"},"tau":{"description":"Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall\ncalculation to obtain the maintenance margin, must be a strictly non-negative real number.","format":"double","type":"number"}},"title":"Risk model for log normal","type":"object"},"lpPriceRange":{"description":"DEPRECATED: Use liquidity SLA parameters instead.\nPercentage move up and down from the mid price which specifies the range of\nprice levels over which automated liquidity provisions will be deployed.","type":"string"},"metadata":{"description":"Optional new futures market metadata, tags.","items":{"type":"string"},"type":"array"},"positionDecimalPlaces":{"description":"Decimal places for order sizes, sets what size the smallest order / position on the futures market can be.","format":"int64","type":"string"},"priceMonitoringParameters":{"description":"Price monitoring parameters.","properties":{"triggers":{"items":{"properties":{"auctionExtension":{"description":"Price monitoring auction extension duration in seconds should the price\nbreach its theoretical level over the specified horizon at the specified\nprobability level.","format":"int64","type":"string"},"horizon":{"description":"Price monitoring projection horizon τ in seconds.","format":"int64","type":"string"},"probability":{"description":"Price monitoring probability level p.","type":"string"}},"title":"PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration","type":"object"},"type":"array"}},"title":"PriceMonitoringParameters contains a collection of triggers to be used for a given market","type":"object"},"quadraticSlippageFactor":{"description":"Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume.","type":"string"},"simple":{"description":"Simple risk model parameters, valid only if MODEL_SIMPLE is selected.","properties":{"factorLong":{"description":"Pre-defined risk factor value for long.","format":"double","type":"number"},"factorShort":{"description":"Pre-defined risk factor value for short.","format":"double","type":"number"},"maxMoveUp":{"description":"Pre-defined maximum price move up that the model considers as valid.","format":"double","type":"number"},"minMoveDown":{"description":"Pre-defined minimum price move down that the model considers as valid.","format":"double","type":"number"},"probabilityOfTrading":{"description":"Pre-defined constant probability of trading.","format":"double","type":"number"}},"title":"Risk model parameters for simple modelling","type":"object"},"successor":{"description":"Successor configuration. If this proposal is meant to succeed a given market, then this should be set.","properties":{"insurancePoolFraction":{"description":"A decimal value between or equal to 0 and 1, specifying the fraction of the insurance pool balance that is carried over from the parent market to the successor.","type":"string"},"parentMarketId":{"description":"ID of the market that the successor should take over from.","type":"string"}},"type":"object","title":"vegaSuccessorConfiguration"}},"title":"Configuration for a new futures market on Vega","type":"object"}},"title":"New market on Vega","type":"object"},"newSpotMarket":{"description":"Proposal change for creating new spot market on Vega.","properties":{"changes":{"description":"Configuration of the new spot market.","properties":{"decimalPlaces":{"description":"Decimal places used for the new spot market, sets the smallest price increment on the book.","format":"uint64","type":"string"},"instrument":{"description":"New spot market instrument configuration.","properties":{"code":{"description":"Instrument code, human-readable shortcode used to describe the instrument.","type":"string"},"future":{"description":"Future.","properties":{"dataSourceSpecBinding":{"description":"Binding between the data source spec and the settlement data.","properties":{"settlementDataProperty":{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement data.","type":"string"},"tradingTerminationProperty":{"description":"Name of the property in the data source data that signals termination of trading.","type":"string"}},"title":"DataSourceSpecToFutureBinding describes which property of the data source data is to be\nused as settlement data and which to use as the trading terminated trigger","type":"object"},"dataSourceSpecForSettlementData":{"description":"Data source spec describing the data source for settlement.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"dataSourceSpecForTradingTermination":{"description":"The external data source spec describing the data source of trading termination.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"quoteName":{"description":"Product quote name.","type":"string"},"settlementAsset":{"description":"Asset ID for the product's settlement asset.","type":"string"}},"title":"Future product configuration","type":"object"},"name":{"description":"Instrument name.","type":"string"},"perpetual":{"description":"Perpetual.","properties":{"clampLowerBound":{"description":"Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"},"clampUpperBound":{"description":"Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"},"dataSourceSpecBinding":{"description":"Binding between the data source spec and the settlement data.","properties":{"settlementDataProperty":{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"},"settlementScheduleProperty":{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"}},"title":"Describes which property of the data source data is to be\nused as settlement data and which to use as the trading terminated trigger","type":"object"},"dataSourceSpecForSettlementData":{"description":"Data source spec describing the data source for settlement.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"dataSourceSpecForSettlementSchedule":{"description":"Data source spec describing the data source for settlement schedule.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"interestRate":{"description":"Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1].","type":"string"},"marginFundingFactor":{"description":"Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1].","type":"string"},"quoteName":{"description":"Product quote name.","type":"string"},"settlementAsset":{"description":"Asset ID for the product's settlement asset.","type":"string"}},"title":"Perpetual product configuration","type":"object"},"spot":{"description":"Spot.","properties":{"baseAsset":{"description":"Base asset ID.","type":"string"},"name":{"description":"Product name.","type":"string"},"quoteAsset":{"description":"Quote asset ID.","type":"string"}},"title":"Spot product configuration","type":"object"}},"title":"Instrument configuration","type":"object"},"logNormal":{"description":"Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected.","properties":{"params":{"description":"Risk model parameters for log normal.","properties":{"mu":{"description":"Mu parameter, annualised growth rate of the underlying asset.","format":"double","type":"number"},"r":{"description":"R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.","format":"double","type":"number"},"sigma":{"description":"Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.","format":"double","type":"number"}},"title":"Risk model parameters for log normal","type":"object"},"riskAversionParameter":{"description":"Risk Aversion Parameter.","format":"double","type":"number"},"tau":{"description":"Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall\ncalculation to obtain the maintenance margin, must be a strictly non-negative real number.","format":"double","type":"number"}},"title":"Risk model for log normal","type":"object"},"metadata":{"description":"Optional new spot market metadata, tags.","items":{"type":"string"},"type":"array"},"positionDecimalPlaces":{"description":"Decimal places for order sizes, sets what size the smallest order / position on the spot market can be.","format":"int64","type":"string"},"priceMonitoringParameters":{"description":"Price monitoring parameters.","properties":{"triggers":{"items":{"properties":{"auctionExtension":{"description":"Price monitoring auction extension duration in seconds should the price\nbreach its theoretical level over the specified horizon at the specified\nprobability level.","format":"int64","type":"string"},"horizon":{"description":"Price monitoring projection horizon τ in seconds.","format":"int64","type":"string"},"probability":{"description":"Price monitoring probability level p.","type":"string"}},"title":"PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration","type":"object"},"type":"array"}},"title":"PriceMonitoringParameters contains a collection of triggers to be used for a given market","type":"object"},"simple":{"description":"Simple risk model parameters, valid only if MODEL_SIMPLE is selected.","properties":{"factorLong":{"description":"Pre-defined risk factor value for long.","format":"double","type":"number"},"factorShort":{"description":"Pre-defined risk factor value for short.","format":"double","type":"number"},"maxMoveUp":{"description":"Pre-defined maximum price move up that the model considers as valid.","format":"double","type":"number"},"minMoveDown":{"description":"Pre-defined minimum price move down that the model considers as valid.","format":"double","type":"number"},"probabilityOfTrading":{"description":"Pre-defined constant probability of trading.","format":"double","type":"number"}},"title":"Risk model parameters for simple modelling","type":"object"},"slaParams":{"description":"Specifies the liquidity provision SLA parameters.","properties":{"commitmentMinTimeFraction":{"description":"Specifies the minimum fraction of time LPs must spend \"on the book\" providing their committed liquidity.","type":"string"},"performanceHysteresisEpochs":{"description":"Specifies the number of liquidity epochs over which past performance will continue to affect rewards.","format":"uint64","type":"string"},"priceRange":{"type":"string"},"slaCompetitionFactor":{"description":"Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers\nthat achieved a higher SLA performance than them.","type":"string"}},"type":"object","title":"vegaLiquiditySLAParameters"},"targetStakeParameters":{"description":"Specifies parameters related to target stake calculation.","properties":{"scalingFactor":{"description":"Specifies scaling factors used in target stake calculation.","format":"double","type":"number"},"timeWindow":{"description":"Specifies length of time window expressed in seconds for target stake calculation.","format":"int64","type":"string"}},"title":"TargetStakeParameters contains parameters used in target stake calculation","type":"object"}},"title":"Configuration for a new spot market on Vega","type":"object"}},"title":"New spot market on Vega","type":"object"},"newTransfer":{"description":"Proposal change for a governance transfer.","properties":{"changes":{"description":"Configuration for a new transfer.","properties":{"amount":{"title":"Maximum amount to transfer","type":"string"},"asset":{"title":"ID of asset to transfer","type":"string"},"destination":{"title":"Specifies the account to transfer to, depending on the account type:\nNetwork treasury: leave empty\nParty: party's public key\nMarket insurance pool: market ID","type":"string"},"destinationType":{"title":"Specifies the account type to transfer to: reward pool, party, network insurance pool, market insurance pool","default":"ACCOUNT_TYPE_UNSPECIFIED","description":"- ACCOUNT_TYPE_UNSPECIFIED: Default value\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.\nEach party will have a margin account for each market they have traded in.\nRequired initial margin is allocated to each market from user's general account.\nCollateral in the margin account can't be withdrawn or used as margin on another market until\nit is released back to the general account.\nVega protocol uses an internal accounting system to segregate funds held as\nmargin from other funds to ensure they are never lost or 'double spent'\n\nMargin account funds will vary as margin requirements on positions change\n - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will\nhave multiple general accounts, one for each asset they want\nto trade with\n\nGeneral accounts are where funds are initially deposited or withdrawn from,\nit is also the account where funds are taken to fulfil fees and initial margin requirements\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade - These fees reward parties\nwho provide the best priced liquidity that actually allows trading to take place\n - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments\n - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)\n - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset\n - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset\n - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)\n - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers\n - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers\n - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers\n - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold\n - ACCOUNT_TYPE_HOLDING: Per asset account for holding in-flight unfilled orders' funds\n - ACCOUNT_TYPE_LP_LIQUIDITY_FEES: Network controlled liquidity provider's account, per market, to hold accrued liquidity fees.\n - ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION: Network controlled liquidity fees bonus distribution account, per market.\n - ACCOUNT_TYPE_NETWORK_TREASURY: Network controlled treasury\n - ACCOUNT_TYPE_VESTING_REWARDS: Account holding user's rewards for the vesting period\n - ACCOUNT_TYPE_VESTED_REWARDS: Account holding user's rewards after the vesting period\n - ACCOUNT_TYPE_REWARD_AVERAGE_POSITION: Per asset market reward account given for average position\n - ACCOUNT_TYPE_REWARD_RELATIVE_RETURN: Per asset market reward account given for relative return\n - ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY: Per asset market reward account given for return volatility\n - ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING: Per asset market reward account given to validators by their ranking\n - ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD: Per asset account for pending fee referral reward payouts","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS","ACCOUNT_TYPE_HOLDING","ACCOUNT_TYPE_LP_LIQUIDITY_FEES","ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION","ACCOUNT_TYPE_NETWORK_TREASURY","ACCOUNT_TYPE_VESTING_REWARDS","ACCOUNT_TYPE_VESTED_REWARDS","ACCOUNT_TYPE_REWARD_AVERAGE_POSITION","ACCOUNT_TYPE_REWARD_RELATIVE_RETURN","ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY","ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING","ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD"],"type":"string"},"fractionOfBalance":{"title":"Maximum fraction of the source account's balance to transfer as a decimal - i.e. 0.1 = 10% of the balance","type":"string"},"oneOff":{"properties":{"deliverOn":{"description":"Timestamp in Unix nanoseconds for when the transfer should be delivered into the receiver's account.","format":"int64","type":"string"}},"title":"Specific details for a one off transfer","type":"object"},"recurring":{"properties":{"dispatchStrategy":{"description":"Optional parameter defining how a transfer is dispatched.","properties":{"assetForMetric":{"description":"Asset to use for metric.","type":"string"},"distributionStrategy":{"title":"Controls how the reward is distributed between qualifying parties","default":"DISTRIBUTION_STRATEGY_UNSPECIFIED","description":" - DISTRIBUTION_STRATEGY_PRO_RATA: Rewards funded using the pro-rata strategy should be distributed pro-rata by each entity's reward metric, scaled by any active multipliers that party has.\n - DISTRIBUTION_STRATEGY_RANK: Rewards funded using the party rank.","enum":["DISTRIBUTION_STRATEGY_UNSPECIFIED","DISTRIBUTION_STRATEGY_PRO_RATA","DISTRIBUTION_STRATEGY_RANK"],"type":"string"},"entityScope":{"description":"Mandatory enum that defines the entities within scope.","default":"ENTITY_SCOPE_UNSPECIFIED","enum":["ENTITY_SCOPE_UNSPECIFIED","ENTITY_SCOPE_INDIVIDUALS","ENTITY_SCOPE_TEAMS"],"title":"- ENTITY_SCOPE_INDIVIDUALS: Rewards must be distributed directly to eligible parties.\n - ENTITY_SCOPE_TEAMS: Rewards must be distributed to directly eligible teams, and then amongst team members","type":"string"},"individualScope":{"description":"Optional enum if the entity scope defined is for individuals, which determines the subset of individuals that are eligible to be rewarded.","default":"INDIVIDUAL_SCOPE_UNSPECIFIED","enum":["INDIVIDUAL_SCOPE_UNSPECIFIED","INDIVIDUAL_SCOPE_ALL","INDIVIDUAL_SCOPE_IN_TEAM","INDIVIDUAL_SCOPE_NOT_IN_TEAM"],"type":"string","title":"vegaIndividualScope"},"lockPeriod":{"format":"uint64","title":"Number of epochs after distribution to delay vesting of rewards by","type":"string"},"markets":{"description":"Optional markets in scope.","items":{"type":"string"},"type":"array"},"metric":{"description":"Metric to apply.","default":"DISPATCH_METRIC_UNSPECIFIED","enum":["DISPATCH_METRIC_UNSPECIFIED","DISPATCH_METRIC_MAKER_FEES_PAID","DISPATCH_METRIC_MAKER_FEES_RECEIVED","DISPATCH_METRIC_LP_FEES_RECEIVED","DISPATCH_METRIC_MARKET_VALUE","DISPATCH_METRIC_AVERAGE_POSITION","DISPATCH_METRIC_RELATIVE_RETURN","DISPATCH_METRIC_RETURN_VOLATILITY","DISPATCH_METRIC_VALIDATOR_RANKING"],"title":"- DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that uses the total maker fees paid in the market\n - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that uses the total maker fees received in the market\n - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that uses the total LP fees received in the market\n - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that uses total value of the market if above the required threshold and not paid given proposer bonus yet\n - DISPATCH_METRIC_AVERAGE_POSITION: Dispatch metric that uses the time weighted average position\n - DISPATCH_METRIC_RELATIVE_RETURN: Dispatch metric that uses the relative PNL of the party in the market\n - DISPATCH_METRIC_RETURN_VOLATILITY: Dispatch metric that uses return volatility of the party in the market\n - DISPATCH_METRIC_VALIDATOR_RANKING: Dispatch metric that uses the validator ranking of the validator as metric","type":"string"},"nTopPerformers":{"title":"The proportion of the top performers in the team for a given metric to be averaged for the metric calculation if the scope is team","type":"string"},"notionalTimeWeightedAveragePositionRequirement":{"title":"Minimum notional time-weighted averaged position required for a party to be considered eligible. Defaults to 0","type":"string"},"rankTable":{"description":"Ordered list, using start rank, defining the rank bands and share ratio for each band. Mandatory for the rank distribution strategy.","items":{"properties":{"shareRatio":{"format":"int64","type":"integer"},"startRank":{"format":"int64","type":"integer"}},"type":"object","title":"vegaRank"},"type":"array"},"stakingRequirement":{"title":"Minimum number of governance (e.g. VEGA) tokens staked for a party to be considered eligible. Defaults to 0","type":"string"},"teamScope":{"items":{"type":"string"},"title":"Optional list applicable if the reward type has a scope of teams, which allows the funder to define a list of team IDs that are eligible to be rewarded from this transfer","type":"array"},"windowLength":{"format":"uint64","title":"Number of epochs to evaluate the metric on","type":"string"}},"type":"object","title":"vegaDispatchStrategy"},"endEpoch":{"description":"Last epoch at which this transfer shall be paid.","format":"uint64","type":"string"},"startEpoch":{"format":"uint64","type":"string"}},"title":"Specific details for a recurring transfer","type":"object"},"source":{"title":"If network treasury, field is empty, otherwise uses the market ID","type":"string"},"sourceType":{"title":"Source account type, such as network treasury, market insurance pool","default":"ACCOUNT_TYPE_UNSPECIFIED","description":"- ACCOUNT_TYPE_UNSPECIFIED: Default value\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.\nEach party will have a margin account for each market they have traded in.\nRequired initial margin is allocated to each market from user's general account.\nCollateral in the margin account can't be withdrawn or used as margin on another market until\nit is released back to the general account.\nVega protocol uses an internal accounting system to segregate funds held as\nmargin from other funds to ensure they are never lost or 'double spent'\n\nMargin account funds will vary as margin requirements on positions change\n - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will\nhave multiple general accounts, one for each asset they want\nto trade with\n\nGeneral accounts are where funds are initially deposited or withdrawn from,\nit is also the account where funds are taken to fulfil fees and initial margin requirements\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade - These fees reward parties\nwho provide the best priced liquidity that actually allows trading to take place\n - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments\n - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)\n - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset\n - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset\n - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)\n - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers\n - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers\n - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers\n - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold\n - ACCOUNT_TYPE_HOLDING: Per asset account for holding in-flight unfilled orders' funds\n - ACCOUNT_TYPE_LP_LIQUIDITY_FEES: Network controlled liquidity provider's account, per market, to hold accrued liquidity fees.\n - ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION: Network controlled liquidity fees bonus distribution account, per market.\n - ACCOUNT_TYPE_NETWORK_TREASURY: Network controlled treasury\n - ACCOUNT_TYPE_VESTING_REWARDS: Account holding user's rewards for the vesting period\n - ACCOUNT_TYPE_VESTED_REWARDS: Account holding user's rewards after the vesting period\n - ACCOUNT_TYPE_REWARD_AVERAGE_POSITION: Per asset market reward account given for average position\n - ACCOUNT_TYPE_REWARD_RELATIVE_RETURN: Per asset market reward account given for relative return\n - ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY: Per asset market reward account given for return volatility\n - ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING: Per asset market reward account given to validators by their ranking\n - ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD: Per asset account for pending fee referral reward payouts","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS","ACCOUNT_TYPE_HOLDING","ACCOUNT_TYPE_LP_LIQUIDITY_FEES","ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION","ACCOUNT_TYPE_NETWORK_TREASURY","ACCOUNT_TYPE_VESTING_REWARDS","ACCOUNT_TYPE_VESTED_REWARDS","ACCOUNT_TYPE_REWARD_AVERAGE_POSITION","ACCOUNT_TYPE_REWARD_RELATIVE_RETURN","ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY","ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING","ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD"],"type":"string"},"transferType":{"title":"\"All or nothing\" or \"best effort\":\nAll or nothing: Transfers the specified amount or does not transfer anything\nBest effort: Transfers the specified amount or the max allowable amount if this is less than the specified amount","default":"GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED","enum":["GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED","GOVERNANCE_TRANSFER_TYPE_ALL_OR_NOTHING","GOVERNANCE_TRANSFER_TYPE_BEST_EFFORT"],"type":"string"}},"type":"object","title":"vegaNewTransferConfiguration"}},"title":"New governance transfer","type":"object"},"updateAsset":{"description":"Proposal change for updating an asset.","properties":{"assetId":{"description":"Asset ID the update is for.","type":"string"},"changes":{"description":"Changes to apply on an existing asset.","properties":{"erc20":{"description":"Ethereum ERC20 asset update.","properties":{"lifetimeLimit":{"description":"Lifetime limits deposit per address.\nThis will be interpreted against the asset decimals.\nnote: this is a temporary measure that can be changed by governance.","type":"string"},"withdrawThreshold":{"description":"Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.\nThere’s no limit on the size of a withdrawal\nnote: this is a temporary measure that can be changed by governance.","type":"string"}},"type":"object","title":"vegaERC20Update"},"quantum":{"description":"Minimum economically meaningful amount in the asset.","type":"string"}},"type":"object","title":"vegaAssetDetailsUpdate"}},"title":"Update an existing asset on Vega","type":"object"},"updateMarket":{"description":"Proposal change for modifying an existing futures market on Vega.","properties":{"changes":{"description":"Updated configuration of the futures market.","properties":{"instrument":{"description":"Updated futures market instrument configuration.","properties":{"code":{"description":"Instrument code, human-readable shortcode used to describe the instrument.","type":"string"},"future":{"description":"Future.","properties":{"dataSourceSpecBinding":{"description":"The binding between the data source spec and the settlement data.","properties":{"settlementDataProperty":{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement data.","type":"string"},"tradingTerminationProperty":{"description":"Name of the property in the data source data that signals termination of trading.","type":"string"}},"title":"DataSourceSpecToFutureBinding describes which property of the data source data is to be\nused as settlement data and which to use as the trading terminated trigger","type":"object"},"dataSourceSpecForSettlementData":{"description":"The data source spec describing the data of settlement data.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"dataSourceSpecForTradingTermination":{"description":"The data source spec describing the data source for trading termination.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"quoteName":{"description":"Human-readable name/abbreviation of the quote name.","type":"string"}},"title":"Future product configuration","type":"object"},"perpetual":{"description":"Perpetual.","properties":{"clampLowerBound":{"description":"Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"},"clampUpperBound":{"description":"Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"},"dataSourceSpecBinding":{"description":"Binding between the data source spec and the settlement data.","properties":{"settlementDataProperty":{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"},"settlementScheduleProperty":{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"}},"title":"Describes which property of the data source data is to be\nused as settlement data and which to use as the trading terminated trigger","type":"object"},"dataSourceSpecForSettlementData":{"description":"Data source spec describing the data source for settlement.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"dataSourceSpecForSettlementSchedule":{"description":"Data source spec describing the data source for settlement schedule.","properties":{"external":{"description":"DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants.","properties":{"ethOracle":{"description":"Contains the data specification that is received from Ethereum sources.","properties":{"abi":{"description":"The ABI of that contract.","type":"string"},"address":{"description":"Ethereum address of the contract to call.","type":"string"},"args":{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"},"filters":{"items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"title":"Filters the data returned from the contract method","type":"array"},"method":{"description":"Name of the method on the contract to call.","type":"string"},"normalisers":{"description":"Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists.","items":{"properties":{"expression":{"type":"string"},"name":{"type":"string"}},"type":"object","title":"vegaNormaliser"},"type":"array"},"requiredConfirmations":{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"},"trigger":{"description":"Conditions for determining when to call the contract method.","properties":{"timeTrigger":{"description":"Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating.","properties":{"every":{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"},"initial":{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"},"until":{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}},"type":"object","title":"vegaEthTimeTrigger"}},"type":"object","title":"vegaEthCallTrigger"}},"type":"object","title":"vegaEthCallSpec"},"oracle":{"description":"All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters.","properties":{"filters":{"description":"Filters describes which source data are considered of interest or not for\nthe product (or the risk model).","items":{"description":"Filter describes the conditions under which a data source data is considered of\ninterest or not.","properties":{"conditions":{"description":"Conditions that should be matched by the data to be\nconsidered of interest.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"key":{"description":"Data source's data property key targeted by the filter.","properties":{"name":{"description":"Name of the property.","type":"string"},"numberDecimalPlaces":{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"},"type":{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}},"type":"object","title":"v1PropertyKey"}},"type":"object","title":"v1Filter"},"type":"array"},"signers":{"description":"Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list.","items":{"properties":{"ethAddress":{"description":"In case of an open oracle - Ethereum address will be submitted.","properties":{"address":{"type":"string"}},"type":"object","title":"v1ETHAddress"},"pubKey":{"description":"List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys.","properties":{"key":{"type":"string"}},"type":"object","title":"v1PubKey"}},"type":"object","title":"v1Signer"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfiguration"}},"type":"object","title":"vegaDataSourceDefinitionExternal"},"internal":{"description":"Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants.","properties":{"time":{"description":"Internal data source used for emitting timestamps.","properties":{"conditions":{"description":"Conditions that the timestamps should meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTime"},"timeTrigger":{"description":"Internal data source used for emitting timestamps automatically using predefined intervals and conditions.","properties":{"conditions":{"description":"Conditions that the timestamps need to meet in order to be considered.","items":{"properties":{"operator":{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"},"value":{"description":"Value to be compared with by the operator.","type":"string"}},"title":"Condition describes the condition that must be validated by the network","type":"object"},"type":"array"},"triggers":{"items":{"description":"Trigger for an internal time data source.","properties":{"every":{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"},"initial":{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}},"type":"object","title":"v1InternalTimeTrigger"},"title":"An internal time trigger","type":"array"}},"type":"object","title":"vegaDataSourceSpecConfigurationTimeTrigger"}},"type":"object","title":"vegaDataSourceDefinitionInternal"}},"type":"object","title":"vegaDataSourceDefinition"},"interestRate":{"description":"Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1].","type":"string"},"marginFundingFactor":{"description":"Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1].","type":"string"},"quoteName":{"description":"Human-readable name/abbreviation of the quote name.","type":"string"}},"title":"Perpetual product configuration","type":"object"}},"title":"Instrument configuration","type":"object"},"linearSlippageFactor":{"description":"Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume.","type":"string"},"liquidityMonitoringParameters":{"description":"Liquidity monitoring parameters.","properties":{"auctionExtension":{"description":"Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction.","format":"int64","type":"string"},"targetStakeParameters":{"description":"Specifies parameters related to target stake calculation.","properties":{"scalingFactor":{"description":"Specifies scaling factors used in target stake calculation.","format":"double","type":"number"},"timeWindow":{"description":"Specifies length of time window expressed in seconds for target stake calculation.","format":"int64","type":"string"}},"title":"TargetStakeParameters contains parameters used in target stake calculation","type":"object"},"triggeringRatio":{"description":"Specifies the triggering ratio for entering liquidity auction.","type":"string"}},"title":"LiquidityMonitoringParameters contains settings used for liquidity monitoring","type":"object"},"liquiditySlaParameters":{"title":"Liquidity SLA parameters","properties":{"commitmentMinTimeFraction":{"description":"Specifies the minimum fraction of time LPs must spend \"on the book\" providing their committed liquidity.","type":"string"},"performanceHysteresisEpochs":{"description":"Specifies the number of liquidity epochs over which past performance will continue to affect rewards.","format":"uint64","type":"string"},"priceRange":{"type":"string"},"slaCompetitionFactor":{"description":"Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers\nthat achieved a higher SLA performance than them.","type":"string"}},"type":"object"},"logNormal":{"description":"Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected.","properties":{"params":{"description":"Risk model parameters for log normal.","properties":{"mu":{"description":"Mu parameter, annualised growth rate of the underlying asset.","format":"double","type":"number"},"r":{"description":"R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.","format":"double","type":"number"},"sigma":{"description":"Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.","format":"double","type":"number"}},"title":"Risk model parameters for log normal","type":"object"},"riskAversionParameter":{"description":"Risk Aversion Parameter.","format":"double","type":"number"},"tau":{"description":"Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall\ncalculation to obtain the maintenance margin, must be a strictly non-negative real number.","format":"double","type":"number"}},"title":"Risk model for log normal","type":"object"},"lpPriceRange":{"description":"DEPRECATED: Use liquidity SLA parameters instead.\nPercentage move up and down from the mid price which specifies the range of\nprice levels over which automated liquidity provisions will be deployed.","type":"string"},"metadata":{"description":"Optional futures market metadata, tags.","items":{"type":"string"},"type":"array"},"priceMonitoringParameters":{"description":"Price monitoring parameters.","properties":{"triggers":{"items":{"properties":{"auctionExtension":{"description":"Price monitoring auction extension duration in seconds should the price\nbreach its theoretical level over the specified horizon at the specified\nprobability level.","format":"int64","type":"string"},"horizon":{"description":"Price monitoring projection horizon τ in seconds.","format":"int64","type":"string"},"probability":{"description":"Price monitoring probability level p.","type":"string"}},"title":"PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration","type":"object"},"type":"array"}},"title":"PriceMonitoringParameters contains a collection of triggers to be used for a given market","type":"object"},"quadraticSlippageFactor":{"description":"Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume.","type":"string"},"simple":{"description":"Simple risk model parameters, valid only if MODEL_SIMPLE is selected.","properties":{"factorLong":{"description":"Pre-defined risk factor value for long.","format":"double","type":"number"},"factorShort":{"description":"Pre-defined risk factor value for short.","format":"double","type":"number"},"maxMoveUp":{"description":"Pre-defined maximum price move up that the model considers as valid.","format":"double","type":"number"},"minMoveDown":{"description":"Pre-defined minimum price move down that the model considers as valid.","format":"double","type":"number"},"probabilityOfTrading":{"description":"Pre-defined constant probability of trading.","format":"double","type":"number"}},"title":"Risk model parameters for simple modelling","type":"object"}},"title":"Configuration to update a futures market on Vega","type":"object"},"marketId":{"description":"Market ID the update is for.","type":"string"}},"title":"Update an existing market on Vega","type":"object"},"updateMarketState":{"description":"Proposal change for updating the state of a market.","properties":{"changes":{"title":"Configuration for governance-initiated change of a market's state","properties":{"marketId":{"title":"ID of the market","type":"string"},"price":{"title":"Settlement price, relevant only for market termination for futures markets","type":"string"},"updateType":{"title":"Type of the market update","default":"MARKET_STATE_UPDATE_TYPE_UNSPECIFIED","enum":["MARKET_STATE_UPDATE_TYPE_UNSPECIFIED","MARKET_STATE_UPDATE_TYPE_TERMINATE","MARKET_STATE_UPDATE_TYPE_SUSPEND","MARKET_STATE_UPDATE_TYPE_RESUME"],"type":"string"}},"type":"object"}},"type":"object","title":"vegaUpdateMarketState"},"updateNetworkParameter":{"description":"Proposal change for updating Vega network parameters.","properties":{"changes":{"description":"The network parameter to update.","properties":{"key":{"description":"Unique key of the network parameter.","type":"string"},"value":{"description":"Value for the network parameter.","type":"string"}},"title":"Represents a network parameter on Vega","type":"object"}},"title":"Update network configuration on Vega","type":"object"},"updateReferralProgram":{"description":"Proposal change for updating the referral program.","properties":{"changes":{"description":"Configuration for change to update a referral program.","properties":{"benefitTiers":{"description":"Defined benefit tiers in increasing order. First element will give Tier 1,\nsecond element will give Tier 2, and so on. Determines the level of\nbenefit a party can expect based on performance criteria.","items":{"properties":{"minimumEpochs":{"description":"Required number of epochs a party must have been in a referral set to\naccess this tier.","type":"string"},"minimumRunningNotionalTakerVolume":{"description":"Required running notional taker volume in quantum units for parties\nto access this tier.","type":"string"},"referralDiscountFactor":{"description":"Proportion of the referee's taker fees to be discounted.","type":"string"},"referralRewardFactor":{"description":"Proportion of the referee's taker fees to be rewarded to the referrer.","type":"string"}},"type":"object","title":"vegaBenefitTier"},"type":"array"},"endOfProgramTimestamp":{"description":"Timestamp as Unix time in seconds, after which when the current epoch\nends, the program will end and benefits will be disabled.","format":"int64","type":"string"},"stakingTiers":{"description":"Defined staking tiers in increasing order. First element will give Tier 1,\nsecond element will give Tier 2, and so on. Determines the level of\nbenefit a party can expect based on their staking.","items":{"properties":{"minimumStakedTokens":{"description":"Required number of governance tokens ($VEGA) a referrer must have staked to\nreceive the multiplier.","type":"string"},"referralRewardMultiplier":{"description":"Multiplier applied to the referral reward factor when calculating referral\nrewards due to the referrer.","type":"string"}},"type":"object","title":"vegaStakingTier"},"type":"array"},"windowLength":{"description":"Number of epochs over which to evaluate a referral set's running volume.","format":"uint64","type":"string"}},"type":"object","title":"vegaReferralProgramChanges"}},"type":"object","title":"vegaUpdateReferralProgram"},"updateSpotMarket":{"description":"Proposal change for modifying an existing spot market on Vega.","properties":{"changes":{"description":"Updated configuration of the spot market.","properties":{"logNormal":{"description":"Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected.","properties":{"params":{"description":"Risk model parameters for log normal.","properties":{"mu":{"description":"Mu parameter, annualised growth rate of the underlying asset.","format":"double","type":"number"},"r":{"description":"R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.","format":"double","type":"number"},"sigma":{"description":"Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.","format":"double","type":"number"}},"title":"Risk model parameters for log normal","type":"object"},"riskAversionParameter":{"description":"Risk Aversion Parameter.","format":"double","type":"number"},"tau":{"description":"Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall\ncalculation to obtain the maintenance margin, must be a strictly non-negative real number.","format":"double","type":"number"}},"title":"Risk model for log normal","type":"object"},"metadata":{"description":"Optional spot market metadata, tags.","items":{"type":"string"},"type":"array"},"priceMonitoringParameters":{"description":"Price monitoring parameters.","properties":{"triggers":{"items":{"properties":{"auctionExtension":{"description":"Price monitoring auction extension duration in seconds should the price\nbreach its theoretical level over the specified horizon at the specified\nprobability level.","format":"int64","type":"string"},"horizon":{"description":"Price monitoring projection horizon τ in seconds.","format":"int64","type":"string"},"probability":{"description":"Price monitoring probability level p.","type":"string"}},"title":"PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration","type":"object"},"type":"array"}},"title":"PriceMonitoringParameters contains a collection of triggers to be used for a given market","type":"object"},"simple":{"description":"Simple risk model parameters, valid only if MODEL_SIMPLE is selected.","properties":{"factorLong":{"description":"Pre-defined risk factor value for long.","format":"double","type":"number"},"factorShort":{"description":"Pre-defined risk factor value for short.","format":"double","type":"number"},"maxMoveUp":{"description":"Pre-defined maximum price move up that the model considers as valid.","format":"double","type":"number"},"minMoveDown":{"description":"Pre-defined minimum price move down that the model considers as valid.","format":"double","type":"number"},"probabilityOfTrading":{"description":"Pre-defined constant probability of trading.","format":"double","type":"number"}},"title":"Risk model parameters for simple modelling","type":"object"},"slaParams":{"description":"Specifies the liquidity provision SLA parameters.","properties":{"commitmentMinTimeFraction":{"description":"Specifies the minimum fraction of time LPs must spend \"on the book\" providing their committed liquidity.","type":"string"},"performanceHysteresisEpochs":{"description":"Specifies the number of liquidity epochs over which past performance will continue to affect rewards.","format":"uint64","type":"string"},"priceRange":{"type":"string"},"slaCompetitionFactor":{"description":"Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers\nthat achieved a higher SLA performance than them.","type":"string"}},"type":"object","title":"vegaLiquiditySLAParameters"},"targetStakeParameters":{"description":"Specifies parameters related to target stake calculation.","properties":{"scalingFactor":{"description":"Specifies scaling factors used in target stake calculation.","format":"double","type":"number"},"timeWindow":{"description":"Specifies length of time window expressed in seconds for target stake calculation.","format":"int64","type":"string"}},"title":"TargetStakeParameters contains parameters used in target stake calculation","type":"object"}},"title":"Configuration to update a spot market on Vega","type":"object"},"marketId":{"description":"Market ID the update is for.","type":"string"}},"title":"Update an existing spot market on Vega","type":"object"},"updateVolumeDiscountProgram":{"description":"Proposal change for updating the volume discount program.","properties":{"changes":{"title":"Configuration for a change to update a volume discount program","properties":{"benefitTiers":{"description":"Defined benefit tiers in increasing order. First element will give Tier 1,\nsecond element will give Tier 2, and so on. Determines the level of\nbenefit a party can expect based on performance criteria.","items":{"properties":{"minimumRunningNotionalTakerVolume":{"description":"Required running notional taker volume in quantum units for parties\nto access this tier.","type":"string"},"volumeDiscountFactor":{"description":"Proportion of the taker fees to be discounted.","type":"string"}},"type":"object","title":"vegaVolumeBenefitTier"},"type":"array"},"endOfProgramTimestamp":{"description":"Timestamp as Unix time in seconds, after which when the current epoch\nends, the program will end and benefits will be disabled.","format":"int64","type":"string"},"windowLength":{"description":"Number of epochs over which to evaluate a referral set's running volume.","format":"uint64","type":"string"}},"type":"object"}},"type":"object","title":"vegaUpdateVolumeDiscountProgram"},"validationTimestamp":{"description":"Validation timestamp as Unix time in seconds.","format":"int64","type":"string"}},"title":"Terms for a governance proposal on Vega","type":"object"}},"type":"object","title":"v1ProposalSubmission"},"protocolUpgradeProposal":{"description":"Validator command sent manually to propose a protocol upgrade.","properties":{"upgradeBlockHeight":{"description":"Block height at which to perform the upgrade.","format":"uint64","type":"string"},"vegaReleaseTag":{"description":"Release tag for the Vega binary.","type":"string"}},"type":"object","title":"v1ProtocolUpgradeProposal"},"stateVariableProposal":{"description":"Validator command sent automatically to reach consensus on floating point values.","properties":{"proposal":{"description":"Details of the state variable being proposed.","properties":{"eventId":{"description":"Event ID.","type":"string"},"kvb":{"description":"Key value tolerance triplets.","items":{"properties":{"key":{"type":"string"},"tolerance":{"type":"string"},"value":{"properties":{"matrixVal":{"properties":{"value":{"items":{"properties":{"value":{"items":{"type":"string"},"type":"array"}},"type":"object","title":"vegaVectorValue"},"type":"array"}},"type":"object","title":"vegaMatrixValue"},"scalarVal":{"properties":{"value":{"type":"string"}},"type":"object","title":"vegaScalarValue"},"vectorVal":{"properties":{"value":{"items":{"type":"string"},"type":"array"}},"type":"object","title":"vegaVectorValue"}},"type":"object","title":"vegaStateVarValue"}},"type":"object","title":"vegaKeyValueBundle"},"type":"array"},"stateVarId":{"description":"State variable ID.","type":"string"}},"type":"object","title":"vegaStateValueProposal"}},"type":"object","title":"v1StateVariableProposal"},"stopOrdersCancellation":{"description":"A command that instructs the network to cancel untriggered stop orders that were submitted by the sender of this transaction.\nIf any cancelled stop order is part of an OCO, both stop orders will be cancelled.\nIt is not possible to cancel another party's stop orders with this command.","properties":{"marketId":{"description":"Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled.","type":"string"},"stopOrderId":{"description":"Restrict cancellations to a stop order with the given ID. If set, then a market ID must also be provided.","type":"string"}},"type":"object","title":"v1StopOrdersCancellation"},"stopOrdersSubmission":{"description":"A command that allows a party to submit a stop order for a given market.\nA stop order is a normal order that remains off the order book and is only submitted if a given trigger is breached from a particular direction.\nIf both rises-above and falls-below are configured, then if one is triggered the other will be cancelled (OCO).","properties":{"fallsBelow":{"description":"Stop order that will be triggered if the price falls below a given trigger price.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire.","format":"int64","type":"string"},"expiryStrategy":{"description":"Strategy to adopt if the expiry time is reached.","default":"EXPIRY_STRATEGY_UNSPECIFIED","enum":["EXPIRY_STRATEGY_UNSPECIFIED","EXPIRY_STRATEGY_CANCELS","EXPIRY_STRATEGY_SUBMIT"],"type":"string","title":"StopOrderExpiryStrategy"},"orderSubmission":{"description":"Order to be submitted once the trigger is breached.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"},"icebergOpts":{"description":"Iceberg order details. If set, the order will exist on the order book in chunks.","properties":{"minimumVisibleSize":{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"},"peakSize":{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}},"title":"Iceberg order options","type":"object"},"marketId":{"description":"Market ID to submit the order to.","type":"string"},"peggedOrder":{"description":"Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.","properties":{"offset":{"description":"Offset from the price reference.","type":"string"},"reference":{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}},"title":"Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET\nThey can be used for any limit order that is valid during continuous trading","type":"object"},"postOnly":{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"},"price":{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"},"reduceOnly":{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"},"reference":{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"},"side":{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"},"size":{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"},"timeInForce":{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"},"type":{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}},"type":"object","title":"v1OrderSubmission"},"price":{"description":"Order will be submitted if the last traded price on the market breaches the given price.","type":"string"},"trailingPercentOffset":{"description":"Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted.","type":"string"}},"type":"object","title":"v1StopOrderSetup"},"risesAbove":{"description":"Stop order that will be triggered if the price rises above a given trigger price.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire.","format":"int64","type":"string"},"expiryStrategy":{"description":"Strategy to adopt if the expiry time is reached.","default":"EXPIRY_STRATEGY_UNSPECIFIED","enum":["EXPIRY_STRATEGY_UNSPECIFIED","EXPIRY_STRATEGY_CANCELS","EXPIRY_STRATEGY_SUBMIT"],"type":"string","title":"StopOrderExpiryStrategy"},"orderSubmission":{"description":"Order to be submitted once the trigger is breached.","properties":{"expiresAt":{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"},"icebergOpts":{"description":"Iceberg order details. If set, the order will exist on the order book in chunks.","properties":{"minimumVisibleSize":{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"},"peakSize":{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}},"title":"Iceberg order options","type":"object"},"marketId":{"description":"Market ID to submit the order to.","type":"string"},"peggedOrder":{"description":"Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.","properties":{"offset":{"description":"Offset from the price reference.","type":"string"},"reference":{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}},"title":"Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET\nThey can be used for any limit order that is valid during continuous trading","type":"object"},"postOnly":{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"},"price":{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"},"reduceOnly":{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"},"reference":{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"},"side":{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"},"size":{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"},"timeInForce":{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"},"type":{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}},"type":"object","title":"v1OrderSubmission"},"price":{"description":"Order will be submitted if the last traded price on the market breaches the given price.","type":"string"},"trailingPercentOffset":{"description":"Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted.","type":"string"}},"type":"object","title":"v1StopOrderSetup"}},"type":"object","title":"v1StopOrdersSubmission"},"transfer":{"description":"Command to submit a transfer.","properties":{"amount":{"description":"Amount to be taken from the source account, as an unsigned integer scaled to the asset's decimal places.","type":"string"},"asset":{"description":"Asset ID of the asset to be transferred.","type":"string"},"fromAccountType":{"description":"Account type from which the funds of the party should be taken.","default":"ACCOUNT_TYPE_UNSPECIFIED","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS","ACCOUNT_TYPE_HOLDING","ACCOUNT_TYPE_LP_LIQUIDITY_FEES","ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION","ACCOUNT_TYPE_NETWORK_TREASURY","ACCOUNT_TYPE_VESTING_REWARDS","ACCOUNT_TYPE_VESTED_REWARDS","ACCOUNT_TYPE_REWARD_AVERAGE_POSITION","ACCOUNT_TYPE_REWARD_RELATIVE_RETURN","ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY","ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING","ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD"],"title":"Various collateral/account types as used by Vega","type":"string"},"oneOff":{"description":"Details of a one-off transfer that is executed once at a specified time.","properties":{"deliverOn":{"description":"Timestamp, in Unix nanoseconds, for when the transfer should be executed, i.e., assets transferred into the receiver's account.","format":"int64","type":"string"}},"type":"object","title":"commandsv1OneOffTransfer"},"recurring":{"description":"Details of a transfer that is executed once every epoch until stopped.","properties":{"dispatchStrategy":{"description":"Optional parameter defining how a transfer is dispatched.","properties":{"assetForMetric":{"description":"Asset to use for metric.","type":"string"},"distributionStrategy":{"title":"Controls how the reward is distributed between qualifying parties","default":"DISTRIBUTION_STRATEGY_UNSPECIFIED","description":" - DISTRIBUTION_STRATEGY_PRO_RATA: Rewards funded using the pro-rata strategy should be distributed pro-rata by each entity's reward metric, scaled by any active multipliers that party has.\n - DISTRIBUTION_STRATEGY_RANK: Rewards funded using the party rank.","enum":["DISTRIBUTION_STRATEGY_UNSPECIFIED","DISTRIBUTION_STRATEGY_PRO_RATA","DISTRIBUTION_STRATEGY_RANK"],"type":"string"},"entityScope":{"description":"Mandatory enum that defines the entities within scope.","default":"ENTITY_SCOPE_UNSPECIFIED","enum":["ENTITY_SCOPE_UNSPECIFIED","ENTITY_SCOPE_INDIVIDUALS","ENTITY_SCOPE_TEAMS"],"title":"- ENTITY_SCOPE_INDIVIDUALS: Rewards must be distributed directly to eligible parties.\n - ENTITY_SCOPE_TEAMS: Rewards must be distributed to directly eligible teams, and then amongst team members","type":"string"},"individualScope":{"description":"Optional enum if the entity scope defined is for individuals, which determines the subset of individuals that are eligible to be rewarded.","default":"INDIVIDUAL_SCOPE_UNSPECIFIED","enum":["INDIVIDUAL_SCOPE_UNSPECIFIED","INDIVIDUAL_SCOPE_ALL","INDIVIDUAL_SCOPE_IN_TEAM","INDIVIDUAL_SCOPE_NOT_IN_TEAM"],"type":"string","title":"vegaIndividualScope"},"lockPeriod":{"format":"uint64","title":"Number of epochs after distribution to delay vesting of rewards by","type":"string"},"markets":{"description":"Optional markets in scope.","items":{"type":"string"},"type":"array"},"metric":{"description":"Metric to apply.","default":"DISPATCH_METRIC_UNSPECIFIED","enum":["DISPATCH_METRIC_UNSPECIFIED","DISPATCH_METRIC_MAKER_FEES_PAID","DISPATCH_METRIC_MAKER_FEES_RECEIVED","DISPATCH_METRIC_LP_FEES_RECEIVED","DISPATCH_METRIC_MARKET_VALUE","DISPATCH_METRIC_AVERAGE_POSITION","DISPATCH_METRIC_RELATIVE_RETURN","DISPATCH_METRIC_RETURN_VOLATILITY","DISPATCH_METRIC_VALIDATOR_RANKING"],"title":"- DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that uses the total maker fees paid in the market\n - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that uses the total maker fees received in the market\n - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that uses the total LP fees received in the market\n - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that uses total value of the market if above the required threshold and not paid given proposer bonus yet\n - DISPATCH_METRIC_AVERAGE_POSITION: Dispatch metric that uses the time weighted average position\n - DISPATCH_METRIC_RELATIVE_RETURN: Dispatch metric that uses the relative PNL of the party in the market\n - DISPATCH_METRIC_RETURN_VOLATILITY: Dispatch metric that uses return volatility of the party in the market\n - DISPATCH_METRIC_VALIDATOR_RANKING: Dispatch metric that uses the validator ranking of the validator as metric","type":"string"},"nTopPerformers":{"title":"The proportion of the top performers in the team for a given metric to be averaged for the metric calculation if the scope is team","type":"string"},"notionalTimeWeightedAveragePositionRequirement":{"title":"Minimum notional time-weighted averaged position required for a party to be considered eligible. Defaults to 0","type":"string"},"rankTable":{"description":"Ordered list, using start rank, defining the rank bands and share ratio for each band. Mandatory for the rank distribution strategy.","items":{"properties":{"shareRatio":{"format":"int64","type":"integer"},"startRank":{"format":"int64","type":"integer"}},"type":"object","title":"vegaRank"},"type":"array"},"stakingRequirement":{"title":"Minimum number of governance (e.g. VEGA) tokens staked for a party to be considered eligible. Defaults to 0","type":"string"},"teamScope":{"items":{"type":"string"},"title":"Optional list applicable if the reward type has a scope of teams, which allows the funder to define a list of team IDs that are eligible to be rewarded from this transfer","type":"array"},"windowLength":{"format":"uint64","title":"Number of epochs to evaluate the metric on","type":"string"}},"type":"object","title":"vegaDispatchStrategy"},"endEpoch":{"description":"Last epoch at which this transfer shall be executed.","format":"uint64","type":"string"},"factor":{"description":"Factor that the initial transfer amount is multiplied by for each epoch that it is executed.\nFor example if the initial transfer amount is 1000 and the factor is 0.5, then the amounts transferred per epoch will be 1000, 500, 250, 125, etc.","type":"string"},"startEpoch":{"description":"First epoch from which this transfer shall be executed.","format":"uint64","type":"string"}},"title":"Details for a recurring transfer","type":"object"},"reference":{"description":"Reference to be attached to the transfer.","type":"string"},"to":{"description":"Public key of the destination account.","type":"string"},"toAccountType":{"description":"Type of the destination account.","default":"ACCOUNT_TYPE_UNSPECIFIED","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS","ACCOUNT_TYPE_HOLDING","ACCOUNT_TYPE_LP_LIQUIDITY_FEES","ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION","ACCOUNT_TYPE_NETWORK_TREASURY","ACCOUNT_TYPE_VESTING_REWARDS","ACCOUNT_TYPE_VESTED_REWARDS","ACCOUNT_TYPE_REWARD_AVERAGE_POSITION","ACCOUNT_TYPE_REWARD_RELATIVE_RETURN","ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY","ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING","ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD"],"title":"Various collateral/account types as used by Vega","type":"string"}},"title":"Command that allows a party to move assets from one account to another.\nA transfer can be set up as a single one-off transfer, or a recurring transfer that occurs once at the start of each epoch.\nEach transfer incurs a fee as specified by the network parameter `transfer.fee.factor`","type":"object"},"undelegateSubmission":{"description":"Command to remove tokens delegated to a validator.","properties":{"amount":{"description":"Amount to undelegate, as an unsigned integer scaled to the governance asset's decimal places.\nIf not set, then all delegations to the given validator node will be removed.","type":"string"},"method":{"description":"Method of delegation.","default":"METHOD_UNSPECIFIED","enum":["METHOD_UNSPECIFIED","METHOD_NOW","METHOD_AT_END_OF_EPOCH"],"type":"string","title":"UndelegateSubmissionMethod"},"nodeId":{"description":"Node ID to undelegate stake from.","type":"string"}},"type":"object","title":"v1UndelegateSubmission"},"updateReferralSet":{"description":"Command to update a referral set.","properties":{"id":{"description":"ID of the referral set to update.","type":"string"},"isTeam":{"description":"Whether or not the referral set should be considered a team that can participate in team games on the network.","type":"boolean"},"team":{"description":"Team details, if the referral set is to be considered a team.","properties":{"avatarUrl":{"description":"New link to an avatar for the team.","type":"string"},"closed":{"description":"Whether or not the team is closed to new party members.","type":"boolean"},"name":{"description":"New name of the team.","type":"string"},"teamUrl":{"description":"New link to the team's homepage.","type":"string"}},"type":"object","title":"v1UpdateReferralSetTeam"}},"type":"object","title":"v1UpdateReferralSet"},"validatorHeartbeat":{"description":"Validator command sent automatically to signal regular participation in the network.","properties":{"ethereumSignature":{"description":"Signature from the validator made using their Ethereum wallet.","properties":{"algo":{"description":"Algorithm used to create the signature.","type":"string"},"value":{"description":"Hex encoded bytes of the signature.","type":"string"},"version":{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}},"type":"object","title":"v1Signature"},"message":{"description":"Message which has been signed.","type":"string"},"nodeId":{"description":"Node ID of the validator emitting the heartbeat.","type":"string"},"vegaSignature":{"description":"Signature from the validator made using their Vega wallet.","properties":{"algo":{"description":"Algorithm used to create the signature.","type":"string"},"value":{"description":"Hex encoded bytes of the signature.","type":"string"},"version":{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}},"type":"object","title":"v1Signature"}},"type":"object","title":"v1ValidatorHeartbeat"},"voteSubmission":{"description":"Command to submit a vote on a governance proposal.","properties":{"proposalId":{"description":"Submit vote for the specified proposal ID.","type":"string"},"value":{"description":"Actual value of the vote.","default":"VALUE_UNSPECIFIED","enum":["VALUE_UNSPECIFIED","VALUE_NO","VALUE_YES"],"title":"Vote value","type":"string"}},"type":"object","title":"v1VoteSubmission"},"withdrawSubmission":{"description":"Command to submit a withdrawal.","properties":{"amount":{"description":"Amount to be withdrawn, as an unsigned integer scaled to the asset's decimal places.","type":"string"},"asset":{"description":"Asset to be withdrawn.","type":"string"},"ext":{"description":"Details specific to the foreign chain, such as the receiver address.","properties":{"erc20":{"description":"ERC20 withdrawal details.","properties":{"receiverAddress":{"description":"Address into which the bridge will release the funds.","type":"string"}},"title":"Extension of data required for the withdraw submissions","type":"object"}},"title":"Withdrawal external details","type":"object"}},"type":"object","title":"v1WithdrawSubmission"}},"type":"object"},"createdAt":{"description":"Timestamp when the transaction happened, using RFC3399 format.","type":"string"},"cursor":{"title":"Cursor for this transaction. This is used for paginating results","type":"string"},"error":{"title":"Optional error happening when processing / checking the transaction\nThis should be set if error code is not 0","type":"string"},"hash":{"title":"Hash of the transaction","type":"string"},"index":{"format":"int64","title":"Index of the transaction in the block","type":"integer"},"pow":{"title":"Proof of Work parameters of the transaction","description":"Components needed for the network to verify proof-of-work.","properties":{"nonce":{"description":"Number which, combined with the transaction identifier, will produce a hash with the required number of leading zeros to be accepted by the network.","format":"uint64","type":"string"},"tid":{"description":"Unique transaction identifier used to seed the proof-of-work hash.","type":"string"}},"type":"object"},"signature":{"title":"Signature generated by the submitter for the transaction","description":"Signature definition that allows the network to authenticate external data.","properties":{"algo":{"description":"Algorithm used to create the signature.","type":"string"},"value":{"description":"Hex encoded bytes of the signature.","type":"string"},"version":{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}},"type":"object"},"submitter":{"title":"Vega public key of the transaction's submitter","type":"string"},"type":{"title":"Type of transaction","type":"string"},"version":{"title":"Version format of the transaction","default":"TX_VERSION_UNSPECIFIED","description":"Transaction versions to maintain backwards compatibility of transaction formats.\n\n - TX_VERSION_UNSPECIFIED: Transaction version is unspecified.\n - TX_VERSION_V2: Transaction requires the addition of a proof-of-work calculation.\n - TX_VERSION_V3: Transaction input data contains a prepended chain ID to prevent use of a single transaction across multiple networks.","enum":["TX_VERSION_UNSPECIFIED","TX_VERSION_V2","TX_VERSION_V3"],"type":"string"}},"type":"object","title":"blockexplorerapiv1Transaction"},"title":"Transaction corresponding to the specific request and filters","type":"array"}},"type":"object","title":"v1ListTransactionsResponse"}}},"description":"A successful response."},"default":{"content":{"application/json":{"schema":{"properties":{"code":{"format":"int32","type":"integer"},"details":{"items":{"additionalProperties":{},"properties":{"@type":{"type":"string"}},"type":"object","title":"protobufAny"},"type":"array"},"message":{"type":"string"}},"type":"object","title":"googlerpcStatus"}}},"description":"An unexpected error response."}},"tags":["BlockExplorer"],"description":"List transactions from the Vega blockchain","operationId":"BlockExplorer_ListTransactions","method":"get","path":"/transactions","servers":[{"url":"https://be.testnet.vega.xyz/rest","description":"Block Explorer"}],"info":{"title":"Vega block explorer APIs","version":"v0.73.10"},"postman":{"name":"List transactions","description":{"content":"List transactions from the Vega blockchain","type":"text/plain"},"url":{"path":["transactions"],"host":["{{baseUrl}}"],"query":[{"disabled":false,"description":{"content":"Number of transactions to be returned from the blockchain.\nThis is deprecated, use first and last instead.","type":"text/plain"},"key":"limit","value":""},{"disabled":false,"description":{"content":"Optional cursor to paginate the request.","type":"text/plain"},"key":"before","value":""},{"disabled":false,"description":{"content":"Optional cursor to paginate the request.","type":"text/plain"},"key":"after","value":""},{"disabled":false,"description":{"content":"Transaction command types filter, for listing transactions with specified command types.","type":"text/plain"},"key":"cmdTypes","value":""},{"disabled":false,"description":{"content":"Transaction command types exclusion filter, for listing all the transactions except the ones with specified command types.","type":"text/plain"},"key":"excludeCmdTypes","value":""},{"disabled":false,"description":{"content":"Party IDs filter, can be sender or receiver.","type":"text/plain"},"key":"parties","value":""},{"disabled":false,"description":{"content":"Number of transactions to be returned from the blockchain. Use in conjunction with the `after` cursor to paginate forwards.\nOn its own, this will return the first `first` transactions.","type":"text/plain"},"key":"first","value":""},{"disabled":false,"description":{"content":"Number of transactions to be returned from the blockchain. Use in conjunction with the `before` cursor to paginate backwards.\nOn its own, this will return the last `last` transactions.","type":"text/plain"},"key":"last","value":""}],"variable":[]},"header":[{"key":"Accept","value":"application/json"}],"method":"GET"}}
sidebar_class_name: "get api-method"
info_path: version-v0.73/api/rest/explorer/vega-block-explorer-apis
custom_edit_url: "https://github.com/vegaprotocol/documentation/issues/new?labels=documentation&title=[Documentation] Requesting changes to 'List transactions' (block-explorer-list-transactions)"
---

import ApiTabs from "@theme/ApiTabs";
import MimeTabs from "@theme/MimeTabs";
import ParamsItem from "@theme/ParamsItem";
import ResponseSamples from "@theme/ResponseSamples";
import SchemaItem from "@theme/SchemaItem";
import SchemaTabs from "@theme/SchemaTabs";
import DiscriminatorTabs from "@theme/DiscriminatorTabs";
import TabItem from "@theme/TabItem";

## List transactions



List transactions from the Vega blockchain

<details style={{"marginBottom":"1rem"}} data-collapsed={false} open={true}><summary style={{}}><strong>Query Parameters</strong></summary><div><ul><ParamsItem className={"paramsItem"} param={{"description":"Number of transactions to be returned from the blockchain.\nThis is deprecated, use first and last instead.","in":"query","name":"limit","required":false,"schema":{"format":"int64","type":"integer"}}}></ParamsItem><ParamsItem className={"paramsItem"} param={{"description":"Optional cursor to paginate the request.","in":"query","name":"before","required":false,"schema":{"type":"string"}}}></ParamsItem><ParamsItem className={"paramsItem"} param={{"description":"Optional cursor to paginate the request.","in":"query","name":"after","required":false,"schema":{"type":"string"}}}></ParamsItem><ParamsItem className={"paramsItem"} param={{"description":"Transaction command types filter, for listing transactions with specified command types.","explode":true,"in":"query","name":"cmdTypes","required":false,"schema":{"items":{"type":"string"},"type":"array"}}}></ParamsItem><ParamsItem className={"paramsItem"} param={{"description":"Transaction command types exclusion filter, for listing all the transactions except the ones with specified command types.","explode":true,"in":"query","name":"excludeCmdTypes","required":false,"schema":{"items":{"type":"string"},"type":"array"}}}></ParamsItem><ParamsItem className={"paramsItem"} param={{"description":"Party IDs filter, can be sender or receiver.","explode":true,"in":"query","name":"parties","required":false,"schema":{"items":{"type":"string"},"type":"array"}}}></ParamsItem><ParamsItem className={"paramsItem"} param={{"description":"Number of transactions to be returned from the blockchain. Use in conjunction with the `after` cursor to paginate forwards.\nOn its own, this will return the first `first` transactions.","in":"query","name":"first","required":false,"schema":{"format":"int64","type":"integer"}}}></ParamsItem><ParamsItem className={"paramsItem"} param={{"description":"Number of transactions to be returned from the blockchain. Use in conjunction with the `before` cursor to paginate backwards.\nOn its own, this will return the last `last` transactions.","in":"query","name":"last","required":false,"schema":{"format":"int64","type":"integer"}}}></ParamsItem></ul></div></details><div><ApiTabs><TabItem label={"200"} value={"200"}><div>

A successful response.

</div><div><MimeTabs schemaType={"response"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>transactions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"block"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Height of the block the transaction was found in","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"code"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","title":"Results code of the transaction. 0 indicates the transaction was successful","type":"integer"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>command</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Input data for a transaction containing a network command for the Vega network to execute.
Once populated the protobuf message should be marshalled into a byte array and included in a transaction message.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>announceNode</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command used by a node operator to announce its node as a pending validator.

</div><SchemaItem collapsible={false} name={"avatarUrl"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"URL to the node operator's avatar.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"chainPubKey"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Public key for the blockchain, currently the node's CometBFT key.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"country"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Country code (ISO 3166-1 alpha-2) for the location of the node.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"ethereumAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum public key of the node being announced.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethereumSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signature from the node made using the ethereum wallet.

</div><SchemaItem collapsible={false} name={"algo"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Algorithm used to create the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Hex encoded bytes of the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"fromEpoch"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Epoch from which the node is expected to be ready to validate blocks.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"id"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Node ID of the validator, which is the node's public master key.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"infoUrl"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"URL to the node operators homepage allowing stake holders to make an informed decision when delegating.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Human-readable name of the node.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"submitterAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum public key to use as a submitter to allow automatic signature generation.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaPubKey"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega public key of the node being announced.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaPubKeyIndex"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Vega public key derivation index.","format":"int64","type":"integer"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>vegaSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signature from the node made using the Vega wallet.

</div><SchemaItem collapsible={false} name={"algo"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Algorithm used to create the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Hex encoded bytes of the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>applyReferralCode</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to apply a referral code.

</div><SchemaItem collapsible={false} name={"id"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Referral code, normally the referral set ID, for the party to join.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>batchMarketInstructions</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to submit a batch of order instructions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>amendments</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of order amendments to be processed sequentially.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for the new expiry time for the order.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID that the order was originally submitted to.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"orderId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"ID of the order to amend.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peggedOffset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New pegged offset for the order.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peggedReference"} required={false} schemaName={"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} schema={{"description":"New pegged reference for the order.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New price for the order. This field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"sizeDelta"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Amend the size for the order by the delta specified:\n- To reduce the size from the current value set a negative integer value\n- To increase the size from the current value, set a positive integer value\n- To leave the size unchanged set a value of zero\nThis field needs to be scaled using the market's position decimal places.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaName={"Time In Force for an order"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} schema={{"description":"New time in force for the order.","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>cancellations</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of order cancellations to be processed sequentially.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"orderId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Restrict cancellations to an order with the given ID. If set, then a market ID must also be provided.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stopOrdersCancellation</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of stop order cancellations to be processed sequentially.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"stopOrderId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Restrict cancellations to a stop order with the given ID. If set, then a market ID must also be provided.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stopOrdersSubmission</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of stop order submissions to be processed sequentially.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>fallsBelow</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Stop order that will be triggered if the price falls below a given trigger price.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"expiryStrategy"} required={false} schemaName={"StopOrderExpiryStrategy"} qualifierMessage={"**Possible values:** [`EXPIRY_STRATEGY_UNSPECIFIED`, `EXPIRY_STRATEGY_CANCELS`, `EXPIRY_STRATEGY_SUBMIT`]"} schema={{"description":"Strategy to adopt if the expiry time is reached.","default":"EXPIRY_STRATEGY_UNSPECIFIED","enum":["EXPIRY_STRATEGY_UNSPECIFIED","EXPIRY_STRATEGY_CANCELS","EXPIRY_STRATEGY_SUBMIT"],"type":"string","title":"StopOrderExpiryStrategy"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Order to be submitted once the trigger is breached.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>icebergOpts</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Iceberg order details. If set, the order will exist on the order book in chunks.

</div><SchemaItem collapsible={false} name={"minimumVisibleSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peakSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID to submit the order to.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>peggedOrder</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.

</div><SchemaItem collapsible={false} name={"offset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Offset from the price reference.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} schema={{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"postOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reduceOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"side"} required={false} schemaName={"Side relates to the direction of an order, to Buy, or Sell"} qualifierMessage={"**Possible values:** [`SIDE_UNSPECIFIED`, `SIDE_BUY`, `SIDE_SELL`]"} schema={{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"size"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaName={"Time In Force for an order"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} schema={{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"Type values for an order"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_LIMIT`, `TYPE_MARKET`, `TYPE_NETWORK`]"} schema={{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Order will be submitted if the last traded price on the market breaches the given price.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"trailingPercentOffset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>risesAbove</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Stop order that will be triggered if the price rises above a given trigger price.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"expiryStrategy"} required={false} schemaName={"StopOrderExpiryStrategy"} qualifierMessage={"**Possible values:** [`EXPIRY_STRATEGY_UNSPECIFIED`, `EXPIRY_STRATEGY_CANCELS`, `EXPIRY_STRATEGY_SUBMIT`]"} schema={{"description":"Strategy to adopt if the expiry time is reached.","default":"EXPIRY_STRATEGY_UNSPECIFIED","enum":["EXPIRY_STRATEGY_UNSPECIFIED","EXPIRY_STRATEGY_CANCELS","EXPIRY_STRATEGY_SUBMIT"],"type":"string","title":"StopOrderExpiryStrategy"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Order to be submitted once the trigger is breached.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>icebergOpts</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Iceberg order details. If set, the order will exist on the order book in chunks.

</div><SchemaItem collapsible={false} name={"minimumVisibleSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peakSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID to submit the order to.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>peggedOrder</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.

</div><SchemaItem collapsible={false} name={"offset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Offset from the price reference.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} schema={{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"postOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reduceOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"side"} required={false} schemaName={"Side relates to the direction of an order, to Buy, or Sell"} qualifierMessage={"**Possible values:** [`SIDE_UNSPECIFIED`, `SIDE_BUY`, `SIDE_SELL`]"} schema={{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"size"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaName={"Time In Force for an order"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} schema={{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"Type values for an order"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_LIMIT`, `TYPE_MARKET`, `TYPE_NETWORK`]"} schema={{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Order will be submitted if the last traded price on the market breaches the given price.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"trailingPercentOffset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted.","type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>submissions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of order submissions to be processed sequentially.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>icebergOpts</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Iceberg order details. If set, the order will exist on the order book in chunks.

</div><SchemaItem collapsible={false} name={"minimumVisibleSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peakSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID to submit the order to.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>peggedOrder</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.

</div><SchemaItem collapsible={false} name={"offset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Offset from the price reference.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} schema={{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"postOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reduceOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"side"} required={false} schemaName={"Side relates to the direction of an order, to Buy, or Sell"} qualifierMessage={"**Possible values:** [`SIDE_UNSPECIFIED`, `SIDE_BUY`, `SIDE_SELL`]"} schema={{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"size"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaName={"Time In Force for an order"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} schema={{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"Type values for an order"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_LIMIT`, `TYPE_MARKET`, `TYPE_NETWORK`]"} schema={{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"blockHeight"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Block height which has been used to calculate the transaction proof-of-work.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>cancelTransfer</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to cancel a recurring transfer.

</div><SchemaItem collapsible={false} name={"transferId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Transfer ID of the transfer to cancel.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>chainEvent</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Validator command sent automatically to notify the Vega chain of an off-chain event.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>builtin</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Built-in asset event.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>deposit</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Built-in asset deposit.

</div><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Amount to be deposited. This field is an unsigned integer scaled to the asset's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"partyId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega party ID i.e. public key.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega network internal asset ID.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>withdrawal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Built-in asset withdrawal.

</div><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The amount to be withdrawn. This field is an unsigned integer scaled to the asset's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"partyId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega network party ID i.e. public key.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega network internal asset ID.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>contractCall</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Ethereum contract call event.

</div><SchemaItem collapsible={false} name={"blockHeight"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Ethereum block height.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Ethereum block time in Unix seconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"error"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Error message if the call failed.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"result"} required={false} schemaName={"byte"} qualifierMessage={undefined} schema={{"description":"Result of contract call, packed according to the ABI stored in the associated data source spec.","format":"byte","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"specId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"ID of the data source spec that triggered this contract call.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Ethereum ERC20 event.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>assetDelist</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

De-list an ERC20 asset.

</div><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega network internal asset ID.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>assetLimitsUpdated</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Update an ERC20 asset.

</div><SchemaItem collapsible={false} name={"lifetimeLimits"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Updated lifetime limits.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"sourceEthereumAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum wallet that initiated the deposit.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega network internal asset ID.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"withdrawThreshold"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Updated withdrawal threshold.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>assetList</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List an ERC20 asset.

</div><SchemaItem collapsible={false} name={"assetSource"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the asset.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega network internal asset ID.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"block"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Block in which the transaction was added.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"bridgeResumed"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"Bridge operations has been resumed.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"bridgeStopped"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"Bridge operations has been stopped.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>deposit</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Deposit ERC20 asset.

</div><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Amount to be deposited.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"sourceEthereumAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum wallet that initiated the deposit.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"targetPartyId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega party ID i.e. public key that is the target of the deposit.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega network internal asset ID.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"index"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Index of the log in the transaction.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>withdrawal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Withdraw ERC20 asset.

</div><SchemaItem collapsible={false} name={"referenceNonce"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Reference nonce used for the transaction.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"targetEthereumAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Target Ethereum wallet address.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega network internal asset ID.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20Multisig</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Ethereum ERC20 multisig event.

</div><SchemaItem collapsible={false} name={"block"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Block in which the transaction was added","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"index"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Index of the log in the transaction","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signerAdded</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"newSigner"} required={false} schemaName={"Ethereum address of the new signer"} qualifierMessage={undefined} schema={{"title":"Ethereum address of the new signer","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"nonce"} required={false} schemaName={"Nonce created by the Vega network used for this new signer"} qualifierMessage={undefined} schema={{"title":"Nonce created by the Vega network used for this new signer","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signerRemoved</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Time at which the block was produced.\nWill be used to inform the core at what time\nthe stake was made unavailable.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"nonce"} required={false} schemaName={"Nonce created by the Vega network used for this old signer"} qualifierMessage={undefined} schema={{"title":"Nonce created by the Vega network used for this old signer","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"oldSigner"} required={false} schemaName={"Ethereum address of the old signer"} qualifierMessage={undefined} schema={{"title":"Ethereum address of the old signer","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>thresholdSet</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Time at which the block was produced.\nWill be used to inform the core at what time\nthe stake was made unavailable.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"newThreshold"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","title":"New threshold value to set","type":"integer"}}></SchemaItem><SchemaItem collapsible={false} name={"nonce"} required={false} schemaName={"Nonce created by the Vega network"} qualifierMessage={undefined} schema={{"title":"Nonce created by the Vega network","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"nonce"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Arbitrary one-time integer used to prevent replay attacks.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stakingEvent</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Ethereum Staking event.

</div><SchemaItem collapsible={false} name={"block"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Block in which the transaction was added.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"index"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Index of the log in the transaction.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stakeDeposited</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Amount deposited as an unsigned base 10 integer scaled to the asset's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Time at which the block was produced.\nWill be used to inform the core at what time\nthe stake started to be available.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"ethereumAddress"} required={false} schemaName={"Ethereum Address of the user depositing stake (hex encode with 0x prefix)"} qualifierMessage={undefined} schema={{"title":"Ethereum Address of the user depositing stake (hex encode with 0x prefix)","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaPublicKey"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Hex encoded public key of the party receiving the stake deposit.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stakeRemoved</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Amount removed as a base 10 unsigned integer scaled to the asset's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"ethereumAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the user removing stake. This should be hex encoded with 0x prefix.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaPublicKey"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Hex encoded public key of the party from which to remove stake.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>totalSupply</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"tokenAddress"} required={false} schemaName={"Address of the staking asset"} qualifierMessage={undefined} schema={{"title":"Address of the staking asset","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"totalSupply"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Total supply observed for the token as an unsigned based 10 integer scaled to the asset's decimal places.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"txId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"ID of the transaction on the foreign chain that caused the event.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>createReferralSet</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to create a referral set.

</div><SchemaItem collapsible={false} name={"isTeam"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"Whether or not the referral set should be considered a team that can participate in team games on the network.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>team</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Team details, if the referral set is to be considered a team.

</div><SchemaItem collapsible={false} name={"avatarUrl"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"External link to an avatar for the team.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"closed"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"Whether or not the team is closed to new party members.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the team.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"teamUrl"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"External link to the team's homepage.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>delegateSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to delegate tokens to a validator.

</div><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Amount of stake to delegate, as an unsigned integer scaled to the governance asset's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"nodeId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Node ID to delegate stake to.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethereumKeyRotateSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Validator command sent manually by a node operator to rotate their node's Ethereum keys.

</div><SchemaItem collapsible={false} name={"currentAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the node's current Ethereum keys.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethereumSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signature signed by the new Ethereum key that can be verified to prove ownership.

</div><SchemaItem collapsible={false} name={"algo"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Algorithm used to create the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Hex encoded bytes of the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"newAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address that is being rotated to.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"submitterAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum public key to use as a submitter to allow automatic signature generation.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"targetBlock"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Block height at which the key rotation will take effect.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>issueSignatures</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to request signatures to amend the multisig-control contract.

</div><SchemaItem collapsible={false} name={"kind"} required={false} schemaName={"Kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc"} qualifierMessage={"**Possible values:** [`NODE_SIGNATURE_KIND_UNSPECIFIED`, `NODE_SIGNATURE_KIND_ASSET_NEW`, `NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL`, `NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED`, `NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED`, `NODE_SIGNATURE_KIND_ASSET_UPDATE`]"} schema={{"description":"What kind of signatures to generate, namely for whether a signer is being added or removed.","default":"NODE_SIGNATURE_KIND_UNSPECIFIED","enum":["NODE_SIGNATURE_KIND_UNSPECIFIED","NODE_SIGNATURE_KIND_ASSET_NEW","NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED","NODE_SIGNATURE_KIND_ASSET_UPDATE"],"title":"Kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"submitter"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address which will submit the signatures to the smart contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"validatorNodeId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Node ID of the validator node that will be signed in or out of the smart contract.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>keyRotateSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Validator command sent manually by a node operator to rotate their node's Vega keys.

</div><SchemaItem collapsible={false} name={"currentPubKeyHash"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Hash of the node's current Vega public key.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"newPubKey"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Vega public key that would be rotated to.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"newPubKeyIndex"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"New Vega public key derivation index.","format":"int64","type":"integer"}}></SchemaItem><SchemaItem collapsible={false} name={"targetBlock"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Block height at which the key rotation will take effect.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityProvisionAmendment</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to amend a liquidity commitment.

</div><SchemaItem collapsible={false} name={"commitmentAmount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New commitment amount.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"fee"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New nominated liquidity fee factor.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market that the submitter wants to amend the liquidity commitment for.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New arbitrary reference to be added to every order created out of this liquidity provision submission.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityProvisionCancellation</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to cancel a liquidity commitment.

</div><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market that the submitter will stop providing liquidity for.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityProvisionSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to submit a liquidity commitment.

</div><SchemaItem collapsible={false} name={"commitmentAmount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Amount that the submitter will commit as liquidity to the market, specified as a unitless number in the settlement asset of the market.\nThis field is an unsigned integer scaled using the asset's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"fee"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market that the submitter wishes to provide liquidity for.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Arbitrary reference to be added to every order created out of this liquidity provision submission.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>nodeSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Validator command sent automatically to provide signatures for the Ethereum bridge.

</div><SchemaItem collapsible={false} name={"id"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"ID of the resource that the signature relates to.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"kind"} required={false} schemaName={"Kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc"} qualifierMessage={"**Possible values:** [`NODE_SIGNATURE_KIND_UNSPECIFIED`, `NODE_SIGNATURE_KIND_ASSET_NEW`, `NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL`, `NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED`, `NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED`, `NODE_SIGNATURE_KIND_ASSET_UPDATE`]"} schema={{"description":"Kind of resource being signed.","default":"NODE_SIGNATURE_KIND_UNSPECIFIED","enum":["NODE_SIGNATURE_KIND_UNSPECIFIED","NODE_SIGNATURE_KIND_ASSET_NEW","NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED","NODE_SIGNATURE_KIND_ASSET_UPDATE"],"title":"Kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"sig"} required={false} schemaName={"byte"} qualifierMessage={undefined} schema={{"description":"Signature generated by the node.","format":"byte","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>nodeVote</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Validator command sent automatically to vote on that validity of an external resource.

</div><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Reference identifying the resource that has been verified.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"- TYPE_UNSPECIFIED: Represents an unspecified or missing value from the input\n - TYPE_STAKE_DEPOSITED: Node vote for a new stake deposit\n - TYPE_STAKE_REMOVED: Node vote for a new stake removed event\n - TYPE_FUNDS_DEPOSITED: Node vote for a new collateral deposit\n - TYPE_SIGNER_ADDED: Node vote for a new signer added to the erc20 bridge\n - TYPE_SIGNER_REMOVED: Node vote for a signer removed from the erc20 bridge\n - TYPE_BRIDGE_STOPPED: Node vote for a bridge stopped event\n - TYPE_BRIDGE_RESUMED: Node vote for a bridge resumed event\n - TYPE_ASSET_LISTED: Node vote for a newly listed asset\n - TYPE_LIMITS_UPDATED: Node vote for an asset limits update\n - TYPE_STAKE_TOTAL_SUPPLY: Node vote to share the total supply of the staking token\n - TYPE_SIGNER_THRESHOLD_SET: Node vote to update the threshold of the signer set for the multisig contract\n - TYPE_GOVERNANCE_VALIDATE_ASSET: Node vote to validate a new assert governance proposal\n - TYPE_ETHEREUM_CONTRACT_CALL_RESULT: Node vote for an Ethereum contract call result"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_STAKE_DEPOSITED`, `TYPE_STAKE_REMOVED`, `TYPE_FUNDS_DEPOSITED`, `TYPE_SIGNER_ADDED`, `TYPE_SIGNER_REMOVED`, `TYPE_BRIDGE_STOPPED`, `TYPE_BRIDGE_RESUMED`, `TYPE_ASSET_LISTED`, `TYPE_LIMITS_UPDATED`, `TYPE_STAKE_TOTAL_SUPPLY`, `TYPE_SIGNER_THRESHOLD_SET`, `TYPE_GOVERNANCE_VALIDATE_ASSET`, `TYPE_ETHEREUM_CONTRACT_CALL_RESULT`]"} schema={{"description":"Type of external event that has been verified.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_STAKE_DEPOSITED","TYPE_STAKE_REMOVED","TYPE_FUNDS_DEPOSITED","TYPE_SIGNER_ADDED","TYPE_SIGNER_REMOVED","TYPE_BRIDGE_STOPPED","TYPE_BRIDGE_RESUMED","TYPE_ASSET_LISTED","TYPE_LIMITS_UPDATED","TYPE_STAKE_TOTAL_SUPPLY","TYPE_SIGNER_THRESHOLD_SET","TYPE_GOVERNANCE_VALIDATE_ASSET","TYPE_ETHEREUM_CONTRACT_CALL_RESULT"],"title":"- TYPE_UNSPECIFIED: Represents an unspecified or missing value from the input\n - TYPE_STAKE_DEPOSITED: Node vote for a new stake deposit\n - TYPE_STAKE_REMOVED: Node vote for a new stake removed event\n - TYPE_FUNDS_DEPOSITED: Node vote for a new collateral deposit\n - TYPE_SIGNER_ADDED: Node vote for a new signer added to the erc20 bridge\n - TYPE_SIGNER_REMOVED: Node vote for a signer removed from the erc20 bridge\n - TYPE_BRIDGE_STOPPED: Node vote for a bridge stopped event\n - TYPE_BRIDGE_RESUMED: Node vote for a bridge resumed event\n - TYPE_ASSET_LISTED: Node vote for a newly listed asset\n - TYPE_LIMITS_UPDATED: Node vote for an asset limits update\n - TYPE_STAKE_TOTAL_SUPPLY: Node vote to share the total supply of the staking token\n - TYPE_SIGNER_THRESHOLD_SET: Node vote to update the threshold of the signer set for the multisig contract\n - TYPE_GOVERNANCE_VALIDATE_ASSET: Node vote to validate a new assert governance proposal\n - TYPE_ETHEREUM_CONTRACT_CALL_RESULT: Node vote for an Ethereum contract call result","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"nonce"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Arbitrary number used to provide uniqueness to the signature of two otherwise identical input data, preventing replay attacks.\nMust be set to a different value for all new transactions sent by a party. It is advised to generate this number randomly.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracleDataSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to submit external oracle data.

</div><SchemaItem collapsible={false} name={"payload"} required={false} schemaName={"byte"} qualifierMessage={undefined} schema={{"description":"Data provided by the data source.","format":"byte","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"source"} required={false} schemaName={"Supported oracle sources"} qualifierMessage={"**Possible values:** [`ORACLE_SOURCE_UNSPECIFIED`, `ORACLE_SOURCE_OPEN_ORACLE`, `ORACLE_SOURCE_JSON`, `ORACLE_SOURCE_ETHEREUM`]"} schema={{"description":"Source from which the data is coming from.","default":"ORACLE_SOURCE_UNSPECIFIED","enum":["ORACLE_SOURCE_UNSPECIFIED","ORACLE_SOURCE_OPEN_ORACLE","ORACLE_SOURCE_JSON","ORACLE_SOURCE_ETHEREUM"],"title":"Supported oracle sources","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderAmendment</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A command that allows a party to update the details of an existing order.
Any field that is left unset or as a default value indicates that this field on the original order will be left unchanged.
It is not possible to change an order's type through this command.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for the new expiry time for the order.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID that the order was originally submitted to.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"orderId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"ID of the order to amend.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peggedOffset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New pegged offset for the order.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peggedReference"} required={false} schemaName={"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} schema={{"description":"New pegged reference for the order.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New price for the order. This field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"sizeDelta"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Amend the size for the order by the delta specified:\n- To reduce the size from the current value set a negative integer value\n- To increase the size from the current value, set a positive integer value\n- To leave the size unchanged set a value of zero\nThis field needs to be scaled using the market's position decimal places.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaName={"Time In Force for an order"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} schema={{"description":"New time in force for the order.","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderCancellation</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A command that instructs the network to cancel orders, active or partially filled, that were previously submitted by the sender of this transaction.
It is not possible to cancel another party's order with this command.

</div><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"orderId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Restrict cancellations to an order with the given ID. If set, then a market ID must also be provided.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A command that submits an order to the Vega network for a given market.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>icebergOpts</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Iceberg order details. If set, the order will exist on the order book in chunks.

</div><SchemaItem collapsible={false} name={"minimumVisibleSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peakSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID to submit the order to.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>peggedOrder</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.

</div><SchemaItem collapsible={false} name={"offset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Offset from the price reference.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} schema={{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"postOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reduceOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"side"} required={false} schemaName={"Side relates to the direction of an order, to Buy, or Sell"} qualifierMessage={"**Possible values:** [`SIDE_UNSPECIFIED`, `SIDE_BUY`, `SIDE_SELL`]"} schema={{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"size"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaName={"Time In Force for an order"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} schema={{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"Type values for an order"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_LIMIT`, `TYPE_MARKET`, `TYPE_NETWORK`]"} schema={{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>proposalSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to submit a governance proposal.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>rationale</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Rationale behind a proposal.

</div><SchemaItem collapsible={false} name={"description"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Description to show a short title / something in case the link goes offline.\nThis is to be between 0 and 20k unicode characters.\nThis is mandatory for all proposals.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"title"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Title to be used to give a short description of the proposal in lists.\nThis is to be between 0 and 100 unicode characters.\nThis is mandatory for all proposals.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Arbitrary human-readable reference identifying the proposal.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>terms</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal terms containing the type and details of the proposal, as well as time spans for voting and enactment.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>cancelTransfer</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Cancel a governance transfer.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"transferId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"ID of the governance transfer proposal.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"closingTimestamp"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp as Unix time in seconds when voting closes for this proposal,\nconstrained by `minClose` and `maxClose` network parameters.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"enactmentTimestamp"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp as Unix time in seconds when proposal gets enacted if passed,\nconstrained by `minEnact` and `maxEnact` network parameters.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>newAsset</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for creating new assets on Vega.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Configuration of the new asset.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>builtinAsset</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Vega built-in asset.

</div><SchemaItem collapsible={false} name={"maxFaucetAmountMint"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Maximum amount that can be requested by a party through the built-in asset faucet at a time.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"decimals"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Number of decimal / precision handled by this asset.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Ethereum ERC20 asset.

</div><SchemaItem collapsible={false} name={"contractAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Address of the contract for the token, on the ethereum network.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"lifetimeLimit"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Lifetime limits deposit per address\nnote: this is a temporary measure that can be changed by governance.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"withdrawThreshold"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.\nThere’s no limit on the size of a withdrawal\nnote: this is a temporary measure that can be changed by governance.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the asset (e.g: Great British Pound).","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"quantum"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Minimum economically meaningful amount in the asset.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"symbol"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Symbol of the asset (e.g: GBP).","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"newFreeform"} required={false} schemaName={"object"} qualifierMessage={undefined} schema={{"description":"Proposal change for a freeform request, which can be voted on but does not change the behaviour of the system,\nand can be used to gauge community sentiment.","type":"object","title":"vegaNewFreeform"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>newMarket</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for creating new futures market on Vega.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Configuration of the new market.

</div><SchemaItem collapsible={false} name={"decimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Decimal places used for the new futures market, sets the smallest price increment on the book.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>instrument</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

New futures market instrument configuration.

</div><SchemaItem collapsible={false} name={"code"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Instrument code, human-readable shortcode used to describe the instrument.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>future</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Future.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecBinding</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Binding between the data source spec and the settlement data.

</div><SchemaItem collapsible={false} name={"settlementDataProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement data.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"tradingTerminationProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the data source data that signals termination of trading.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForSettlementData</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source spec describing the data source for settlement.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForTradingTermination</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

The external data source spec describing the data source of trading termination.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"quoteName"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Product quote name.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"settlementAsset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Asset ID for the product's settlement asset.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Instrument name.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>perpetual</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Perpetual.

</div><SchemaItem collapsible={false} name={"clampLowerBound"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"clampUpperBound"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecBinding</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Binding between the data source spec and the settlement data.

</div><SchemaItem collapsible={false} name={"settlementDataProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"settlementScheduleProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForSettlementData</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source spec describing the data source for settlement.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForSettlementSchedule</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source spec describing the data source for settlement schedule.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"interestRate"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"marginFundingFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"quoteName"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Product quote name.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"settlementAsset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Asset ID for the product's settlement asset.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>spot</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Spot.

</div><SchemaItem collapsible={false} name={"baseAsset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Base asset ID.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Product name.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"quoteAsset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Quote asset ID.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"linearSlippageFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Liquidity monitoring parameters.

</div><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>targetStakeParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Specifies parameters related to target stake calculation.

</div><SchemaItem collapsible={false} name={"scalingFactor"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Specifies scaling factors used in target stake calculation.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"timeWindow"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Specifies length of time window expressed in seconds for target stake calculation.","format":"int64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"triggeringRatio"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the triggering ratio for entering liquidity auction.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquiditySlaParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"commitmentMinTimeFraction"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the minimum fraction of time LPs must spend \"on the book\" providing their committed liquidity.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"performanceHysteresisEpochs"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Specifies the number of liquidity epochs over which past performance will continue to affect rewards.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"priceRange"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"slaCompetitionFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers\nthat achieved a higher SLA performance than them.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>logNormal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>params</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Risk model parameters for log normal.

</div><SchemaItem collapsible={false} name={"mu"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Mu parameter, annualised growth rate of the underlying asset.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"r"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"sigma"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"riskAversionParameter"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Risk Aversion Parameter.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"tau"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall\ncalculation to obtain the maintenance margin, must be a strictly non-negative real number.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"lpPriceRange"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"DEPRECATED: Use liquidity SLA parameters instead.\nPercentage move up and down from the mid price which specifies the range of\nprice levels over which automated liquidity provisions will be deployed.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"metadata"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"description":"Optional new futures market metadata, tags.","items":{"type":"string"},"type":"array"}}></SchemaItem><SchemaItem collapsible={false} name={"positionDecimalPlaces"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Decimal places for order sizes, sets what size the smallest order / position on the futures market can be.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>priceMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Price monitoring parameters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Price monitoring auction extension duration in seconds should the price\nbreach its theoretical level over the specified horizon at the specified\nprobability level.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"horizon"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Price monitoring projection horizon τ in seconds.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"probability"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price monitoring probability level p.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"quadraticSlippageFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>simple</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Simple risk model parameters, valid only if MODEL_SIMPLE is selected.

</div><SchemaItem collapsible={false} name={"factorLong"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined risk factor value for long.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"factorShort"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined risk factor value for short.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"maxMoveUp"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined maximum price move up that the model considers as valid.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"minMoveDown"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined minimum price move down that the model considers as valid.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"probabilityOfTrading"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined constant probability of trading.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>successor</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Successor configuration. If this proposal is meant to succeed a given market, then this should be set.

</div><SchemaItem collapsible={false} name={"insurancePoolFraction"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"A decimal value between or equal to 0 and 1, specifying the fraction of the insurance pool balance that is carried over from the parent market to the successor.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"parentMarketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"ID of the market that the successor should take over from.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>newSpotMarket</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for creating new spot market on Vega.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Configuration of the new spot market.

</div><SchemaItem collapsible={false} name={"decimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Decimal places used for the new spot market, sets the smallest price increment on the book.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>instrument</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

New spot market instrument configuration.

</div><SchemaItem collapsible={false} name={"code"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Instrument code, human-readable shortcode used to describe the instrument.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>future</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Future.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecBinding</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Binding between the data source spec and the settlement data.

</div><SchemaItem collapsible={false} name={"settlementDataProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement data.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"tradingTerminationProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the data source data that signals termination of trading.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForSettlementData</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source spec describing the data source for settlement.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForTradingTermination</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

The external data source spec describing the data source of trading termination.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"quoteName"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Product quote name.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"settlementAsset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Asset ID for the product's settlement asset.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Instrument name.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>perpetual</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Perpetual.

</div><SchemaItem collapsible={false} name={"clampLowerBound"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"clampUpperBound"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecBinding</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Binding between the data source spec and the settlement data.

</div><SchemaItem collapsible={false} name={"settlementDataProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"settlementScheduleProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForSettlementData</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source spec describing the data source for settlement.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForSettlementSchedule</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source spec describing the data source for settlement schedule.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"interestRate"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"marginFundingFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"quoteName"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Product quote name.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"settlementAsset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Asset ID for the product's settlement asset.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>spot</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Spot.

</div><SchemaItem collapsible={false} name={"baseAsset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Base asset ID.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Product name.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"quoteAsset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Quote asset ID.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>logNormal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>params</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Risk model parameters for log normal.

</div><SchemaItem collapsible={false} name={"mu"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Mu parameter, annualised growth rate of the underlying asset.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"r"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"sigma"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"riskAversionParameter"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Risk Aversion Parameter.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"tau"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall\ncalculation to obtain the maintenance margin, must be a strictly non-negative real number.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"metadata"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"description":"Optional new spot market metadata, tags.","items":{"type":"string"},"type":"array"}}></SchemaItem><SchemaItem collapsible={false} name={"positionDecimalPlaces"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Decimal places for order sizes, sets what size the smallest order / position on the spot market can be.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>priceMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Price monitoring parameters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Price monitoring auction extension duration in seconds should the price\nbreach its theoretical level over the specified horizon at the specified\nprobability level.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"horizon"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Price monitoring projection horizon τ in seconds.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"probability"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price monitoring probability level p.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>simple</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Simple risk model parameters, valid only if MODEL_SIMPLE is selected.

</div><SchemaItem collapsible={false} name={"factorLong"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined risk factor value for long.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"factorShort"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined risk factor value for short.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"maxMoveUp"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined maximum price move up that the model considers as valid.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"minMoveDown"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined minimum price move down that the model considers as valid.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"probabilityOfTrading"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined constant probability of trading.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>slaParams</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Specifies the liquidity provision SLA parameters.

</div><SchemaItem collapsible={false} name={"commitmentMinTimeFraction"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the minimum fraction of time LPs must spend \"on the book\" providing their committed liquidity.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"performanceHysteresisEpochs"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Specifies the number of liquidity epochs over which past performance will continue to affect rewards.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"priceRange"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"slaCompetitionFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers\nthat achieved a higher SLA performance than them.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>targetStakeParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Specifies parameters related to target stake calculation.

</div><SchemaItem collapsible={false} name={"scalingFactor"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Specifies scaling factors used in target stake calculation.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"timeWindow"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Specifies length of time window expressed in seconds for target stake calculation.","format":"int64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>newTransfer</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for a governance transfer.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Configuration for a new transfer.

</div><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"Maximum amount to transfer"} qualifierMessage={undefined} schema={{"title":"Maximum amount to transfer","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"asset"} required={false} schemaName={"ID of asset to transfer"} qualifierMessage={undefined} schema={{"title":"ID of asset to transfer","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"destination"} required={false} schemaName={"Specifies the account to transfer to, depending on the account type:\nNetwork treasury: leave empty\nParty: party's public key\nMarket insurance pool: market ID"} qualifierMessage={undefined} schema={{"title":"Specifies the account to transfer to, depending on the account type:\nNetwork treasury: leave empty\nParty: party's public key\nMarket insurance pool: market ID","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"destinationType"} required={false} schemaName={"Specifies the account type to transfer to: reward pool, party, network insurance pool, market insurance pool"} qualifierMessage={"**Possible values:** [`ACCOUNT_TYPE_UNSPECIFIED`, `ACCOUNT_TYPE_INSURANCE`, `ACCOUNT_TYPE_SETTLEMENT`, `ACCOUNT_TYPE_MARGIN`, `ACCOUNT_TYPE_GENERAL`, `ACCOUNT_TYPE_FEES_INFRASTRUCTURE`, `ACCOUNT_TYPE_FEES_LIQUIDITY`, `ACCOUNT_TYPE_FEES_MAKER`, `ACCOUNT_TYPE_BOND`, `ACCOUNT_TYPE_EXTERNAL`, `ACCOUNT_TYPE_GLOBAL_INSURANCE`, `ACCOUNT_TYPE_GLOBAL_REWARD`, `ACCOUNT_TYPE_PENDING_TRANSFERS`, `ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES`, `ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS`, `ACCOUNT_TYPE_HOLDING`, `ACCOUNT_TYPE_LP_LIQUIDITY_FEES`, `ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION`, `ACCOUNT_TYPE_NETWORK_TREASURY`, `ACCOUNT_TYPE_VESTING_REWARDS`, `ACCOUNT_TYPE_VESTED_REWARDS`, `ACCOUNT_TYPE_REWARD_AVERAGE_POSITION`, `ACCOUNT_TYPE_REWARD_RELATIVE_RETURN`, `ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY`, `ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING`, `ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD`]"} schema={{"title":"Specifies the account type to transfer to: reward pool, party, network insurance pool, market insurance pool","default":"ACCOUNT_TYPE_UNSPECIFIED","description":"- ACCOUNT_TYPE_UNSPECIFIED: Default value\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.\nEach party will have a margin account for each market they have traded in.\nRequired initial margin is allocated to each market from user's general account.\nCollateral in the margin account can't be withdrawn or used as margin on another market until\nit is released back to the general account.\nVega protocol uses an internal accounting system to segregate funds held as\nmargin from other funds to ensure they are never lost or 'double spent'\n\nMargin account funds will vary as margin requirements on positions change\n - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will\nhave multiple general accounts, one for each asset they want\nto trade with\n\nGeneral accounts are where funds are initially deposited or withdrawn from,\nit is also the account where funds are taken to fulfil fees and initial margin requirements\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade - These fees reward parties\nwho provide the best priced liquidity that actually allows trading to take place\n - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments\n - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)\n - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset\n - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset\n - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)\n - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers\n - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers\n - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers\n - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold\n - ACCOUNT_TYPE_HOLDING: Per asset account for holding in-flight unfilled orders' funds\n - ACCOUNT_TYPE_LP_LIQUIDITY_FEES: Network controlled liquidity provider's account, per market, to hold accrued liquidity fees.\n - ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION: Network controlled liquidity fees bonus distribution account, per market.\n - ACCOUNT_TYPE_NETWORK_TREASURY: Network controlled treasury\n - ACCOUNT_TYPE_VESTING_REWARDS: Account holding user's rewards for the vesting period\n - ACCOUNT_TYPE_VESTED_REWARDS: Account holding user's rewards after the vesting period\n - ACCOUNT_TYPE_REWARD_AVERAGE_POSITION: Per asset market reward account given for average position\n - ACCOUNT_TYPE_REWARD_RELATIVE_RETURN: Per asset market reward account given for relative return\n - ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY: Per asset market reward account given for return volatility\n - ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING: Per asset market reward account given to validators by their ranking\n - ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD: Per asset account for pending fee referral reward payouts","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS","ACCOUNT_TYPE_HOLDING","ACCOUNT_TYPE_LP_LIQUIDITY_FEES","ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION","ACCOUNT_TYPE_NETWORK_TREASURY","ACCOUNT_TYPE_VESTING_REWARDS","ACCOUNT_TYPE_VESTED_REWARDS","ACCOUNT_TYPE_REWARD_AVERAGE_POSITION","ACCOUNT_TYPE_REWARD_RELATIVE_RETURN","ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY","ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING","ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD"],"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"fractionOfBalance"} required={false} schemaName={"Maximum fraction of the source account's balance to transfer as a decimal - i.e. 0.1 = 10% of the balance"} qualifierMessage={undefined} schema={{"title":"Maximum fraction of the source account's balance to transfer as a decimal - i.e. 0.1 = 10% of the balance","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oneOff</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"deliverOn"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp in Unix nanoseconds for when the transfer should be delivered into the receiver's account.","format":"int64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>recurring</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dispatchStrategy</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Optional parameter defining how a transfer is dispatched.

</div><SchemaItem collapsible={false} name={"assetForMetric"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Asset to use for metric.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"distributionStrategy"} required={false} schemaName={"Controls how the reward is distributed between qualifying parties"} qualifierMessage={"**Possible values:** [`DISTRIBUTION_STRATEGY_UNSPECIFIED`, `DISTRIBUTION_STRATEGY_PRO_RATA`, `DISTRIBUTION_STRATEGY_RANK`]"} schema={{"title":"Controls how the reward is distributed between qualifying parties","default":"DISTRIBUTION_STRATEGY_UNSPECIFIED","description":" - DISTRIBUTION_STRATEGY_PRO_RATA: Rewards funded using the pro-rata strategy should be distributed pro-rata by each entity's reward metric, scaled by any active multipliers that party has.\n - DISTRIBUTION_STRATEGY_RANK: Rewards funded using the party rank.","enum":["DISTRIBUTION_STRATEGY_UNSPECIFIED","DISTRIBUTION_STRATEGY_PRO_RATA","DISTRIBUTION_STRATEGY_RANK"],"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"entityScope"} required={false} schemaName={"- ENTITY_SCOPE_INDIVIDUALS: Rewards must be distributed directly to eligible parties.\n - ENTITY_SCOPE_TEAMS: Rewards must be distributed to directly eligible teams, and then amongst team members"} qualifierMessage={"**Possible values:** [`ENTITY_SCOPE_UNSPECIFIED`, `ENTITY_SCOPE_INDIVIDUALS`, `ENTITY_SCOPE_TEAMS`]"} schema={{"description":"Mandatory enum that defines the entities within scope.","default":"ENTITY_SCOPE_UNSPECIFIED","enum":["ENTITY_SCOPE_UNSPECIFIED","ENTITY_SCOPE_INDIVIDUALS","ENTITY_SCOPE_TEAMS"],"title":"- ENTITY_SCOPE_INDIVIDUALS: Rewards must be distributed directly to eligible parties.\n - ENTITY_SCOPE_TEAMS: Rewards must be distributed to directly eligible teams, and then amongst team members","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"individualScope"} required={false} schemaName={"vegaIndividualScope"} qualifierMessage={"**Possible values:** [`INDIVIDUAL_SCOPE_UNSPECIFIED`, `INDIVIDUAL_SCOPE_ALL`, `INDIVIDUAL_SCOPE_IN_TEAM`, `INDIVIDUAL_SCOPE_NOT_IN_TEAM`]"} schema={{"description":"Optional enum if the entity scope defined is for individuals, which determines the subset of individuals that are eligible to be rewarded.","default":"INDIVIDUAL_SCOPE_UNSPECIFIED","enum":["INDIVIDUAL_SCOPE_UNSPECIFIED","INDIVIDUAL_SCOPE_ALL","INDIVIDUAL_SCOPE_IN_TEAM","INDIVIDUAL_SCOPE_NOT_IN_TEAM"],"type":"string","title":"vegaIndividualScope"}}></SchemaItem><SchemaItem collapsible={false} name={"lockPeriod"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of epochs after distribution to delay vesting of rewards by","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"markets"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"description":"Optional markets in scope.","items":{"type":"string"},"type":"array"}}></SchemaItem><SchemaItem collapsible={false} name={"metric"} required={false} schemaName={"- DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that uses the total maker fees paid in the market\n - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that uses the total maker fees received in the market\n - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that uses the total LP fees received in the market\n - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that uses total value of the market if above the required threshold and not paid given proposer bonus yet\n - DISPATCH_METRIC_AVERAGE_POSITION: Dispatch metric that uses the time weighted average position\n - DISPATCH_METRIC_RELATIVE_RETURN: Dispatch metric that uses the relative PNL of the party in the market\n - DISPATCH_METRIC_RETURN_VOLATILITY: Dispatch metric that uses return volatility of the party in the market\n - DISPATCH_METRIC_VALIDATOR_RANKING: Dispatch metric that uses the validator ranking of the validator as metric"} qualifierMessage={"**Possible values:** [`DISPATCH_METRIC_UNSPECIFIED`, `DISPATCH_METRIC_MAKER_FEES_PAID`, `DISPATCH_METRIC_MAKER_FEES_RECEIVED`, `DISPATCH_METRIC_LP_FEES_RECEIVED`, `DISPATCH_METRIC_MARKET_VALUE`, `DISPATCH_METRIC_AVERAGE_POSITION`, `DISPATCH_METRIC_RELATIVE_RETURN`, `DISPATCH_METRIC_RETURN_VOLATILITY`, `DISPATCH_METRIC_VALIDATOR_RANKING`]"} schema={{"description":"Metric to apply.","default":"DISPATCH_METRIC_UNSPECIFIED","enum":["DISPATCH_METRIC_UNSPECIFIED","DISPATCH_METRIC_MAKER_FEES_PAID","DISPATCH_METRIC_MAKER_FEES_RECEIVED","DISPATCH_METRIC_LP_FEES_RECEIVED","DISPATCH_METRIC_MARKET_VALUE","DISPATCH_METRIC_AVERAGE_POSITION","DISPATCH_METRIC_RELATIVE_RETURN","DISPATCH_METRIC_RETURN_VOLATILITY","DISPATCH_METRIC_VALIDATOR_RANKING"],"title":"- DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that uses the total maker fees paid in the market\n - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that uses the total maker fees received in the market\n - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that uses the total LP fees received in the market\n - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that uses total value of the market if above the required threshold and not paid given proposer bonus yet\n - DISPATCH_METRIC_AVERAGE_POSITION: Dispatch metric that uses the time weighted average position\n - DISPATCH_METRIC_RELATIVE_RETURN: Dispatch metric that uses the relative PNL of the party in the market\n - DISPATCH_METRIC_RETURN_VOLATILITY: Dispatch metric that uses return volatility of the party in the market\n - DISPATCH_METRIC_VALIDATOR_RANKING: Dispatch metric that uses the validator ranking of the validator as metric","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"nTopPerformers"} required={false} schemaName={"The proportion of the top performers in the team for a given metric to be averaged for the metric calculation if the scope is team"} qualifierMessage={undefined} schema={{"title":"The proportion of the top performers in the team for a given metric to be averaged for the metric calculation if the scope is team","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"notionalTimeWeightedAveragePositionRequirement"} required={false} schemaName={"Minimum notional time-weighted averaged position required for a party to be considered eligible. Defaults to 0"} qualifierMessage={undefined} schema={{"title":"Minimum notional time-weighted averaged position required for a party to be considered eligible. Defaults to 0","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>rankTable</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Ordered list, using start rank, defining the rank bands and share ratio for each band. Mandatory for the rank distribution strategy.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"shareRatio"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","type":"integer"}}></SchemaItem><SchemaItem collapsible={false} name={"startRank"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","type":"integer"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"stakingRequirement"} required={false} schemaName={"Minimum number of governance (e.g. VEGA) tokens staked for a party to be considered eligible. Defaults to 0"} qualifierMessage={undefined} schema={{"title":"Minimum number of governance (e.g. VEGA) tokens staked for a party to be considered eligible. Defaults to 0","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"teamScope"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"items":{"type":"string"},"title":"Optional list applicable if the reward type has a scope of teams, which allows the funder to define a list of team IDs that are eligible to be rewarded from this transfer","type":"array"}}></SchemaItem><SchemaItem collapsible={false} name={"windowLength"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of epochs to evaluate the metric on","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"endEpoch"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Last epoch at which this transfer shall be paid.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"startEpoch"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"source"} required={false} schemaName={"If network treasury, field is empty, otherwise uses the market ID"} qualifierMessage={undefined} schema={{"title":"If network treasury, field is empty, otherwise uses the market ID","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"sourceType"} required={false} schemaName={"Source account type, such as network treasury, market insurance pool"} qualifierMessage={"**Possible values:** [`ACCOUNT_TYPE_UNSPECIFIED`, `ACCOUNT_TYPE_INSURANCE`, `ACCOUNT_TYPE_SETTLEMENT`, `ACCOUNT_TYPE_MARGIN`, `ACCOUNT_TYPE_GENERAL`, `ACCOUNT_TYPE_FEES_INFRASTRUCTURE`, `ACCOUNT_TYPE_FEES_LIQUIDITY`, `ACCOUNT_TYPE_FEES_MAKER`, `ACCOUNT_TYPE_BOND`, `ACCOUNT_TYPE_EXTERNAL`, `ACCOUNT_TYPE_GLOBAL_INSURANCE`, `ACCOUNT_TYPE_GLOBAL_REWARD`, `ACCOUNT_TYPE_PENDING_TRANSFERS`, `ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES`, `ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS`, `ACCOUNT_TYPE_HOLDING`, `ACCOUNT_TYPE_LP_LIQUIDITY_FEES`, `ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION`, `ACCOUNT_TYPE_NETWORK_TREASURY`, `ACCOUNT_TYPE_VESTING_REWARDS`, `ACCOUNT_TYPE_VESTED_REWARDS`, `ACCOUNT_TYPE_REWARD_AVERAGE_POSITION`, `ACCOUNT_TYPE_REWARD_RELATIVE_RETURN`, `ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY`, `ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING`, `ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD`]"} schema={{"title":"Source account type, such as network treasury, market insurance pool","default":"ACCOUNT_TYPE_UNSPECIFIED","description":"- ACCOUNT_TYPE_UNSPECIFIED: Default value\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.\nEach party will have a margin account for each market they have traded in.\nRequired initial margin is allocated to each market from user's general account.\nCollateral in the margin account can't be withdrawn or used as margin on another market until\nit is released back to the general account.\nVega protocol uses an internal accounting system to segregate funds held as\nmargin from other funds to ensure they are never lost or 'double spent'\n\nMargin account funds will vary as margin requirements on positions change\n - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will\nhave multiple general accounts, one for each asset they want\nto trade with\n\nGeneral accounts are where funds are initially deposited or withdrawn from,\nit is also the account where funds are taken to fulfil fees and initial margin requirements\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade - These fees reward parties\nwho provide the best priced liquidity that actually allows trading to take place\n - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments\n - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)\n - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset\n - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset\n - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)\n - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers\n - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers\n - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers\n - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold\n - ACCOUNT_TYPE_HOLDING: Per asset account for holding in-flight unfilled orders' funds\n - ACCOUNT_TYPE_LP_LIQUIDITY_FEES: Network controlled liquidity provider's account, per market, to hold accrued liquidity fees.\n - ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION: Network controlled liquidity fees bonus distribution account, per market.\n - ACCOUNT_TYPE_NETWORK_TREASURY: Network controlled treasury\n - ACCOUNT_TYPE_VESTING_REWARDS: Account holding user's rewards for the vesting period\n - ACCOUNT_TYPE_VESTED_REWARDS: Account holding user's rewards after the vesting period\n - ACCOUNT_TYPE_REWARD_AVERAGE_POSITION: Per asset market reward account given for average position\n - ACCOUNT_TYPE_REWARD_RELATIVE_RETURN: Per asset market reward account given for relative return\n - ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY: Per asset market reward account given for return volatility\n - ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING: Per asset market reward account given to validators by their ranking\n - ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD: Per asset account for pending fee referral reward payouts","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS","ACCOUNT_TYPE_HOLDING","ACCOUNT_TYPE_LP_LIQUIDITY_FEES","ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION","ACCOUNT_TYPE_NETWORK_TREASURY","ACCOUNT_TYPE_VESTING_REWARDS","ACCOUNT_TYPE_VESTED_REWARDS","ACCOUNT_TYPE_REWARD_AVERAGE_POSITION","ACCOUNT_TYPE_REWARD_RELATIVE_RETURN","ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY","ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING","ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD"],"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"transferType"} required={false} schemaName={"\"All or nothing\" or \"best effort\":\nAll or nothing: Transfers the specified amount or does not transfer anything\nBest effort: Transfers the specified amount or the max allowable amount if this is less than the specified amount"} qualifierMessage={"**Possible values:** [`GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED`, `GOVERNANCE_TRANSFER_TYPE_ALL_OR_NOTHING`, `GOVERNANCE_TRANSFER_TYPE_BEST_EFFORT`]"} schema={{"title":"\"All or nothing\" or \"best effort\":\nAll or nothing: Transfers the specified amount or does not transfer anything\nBest effort: Transfers the specified amount or the max allowable amount if this is less than the specified amount","default":"GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED","enum":["GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED","GOVERNANCE_TRANSFER_TYPE_ALL_OR_NOTHING","GOVERNANCE_TRANSFER_TYPE_BEST_EFFORT"],"type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateAsset</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for updating an asset.

</div><SchemaItem collapsible={false} name={"assetId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Asset ID the update is for.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Changes to apply on an existing asset.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Ethereum ERC20 asset update.

</div><SchemaItem collapsible={false} name={"lifetimeLimit"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Lifetime limits deposit per address.\nThis will be interpreted against the asset decimals.\nnote: this is a temporary measure that can be changed by governance.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"withdrawThreshold"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.\nThere’s no limit on the size of a withdrawal\nnote: this is a temporary measure that can be changed by governance.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"quantum"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Minimum economically meaningful amount in the asset.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateMarket</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for modifying an existing futures market on Vega.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Updated configuration of the futures market.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>instrument</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Updated futures market instrument configuration.

</div><SchemaItem collapsible={false} name={"code"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Instrument code, human-readable shortcode used to describe the instrument.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>future</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Future.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecBinding</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

The binding between the data source spec and the settlement data.

</div><SchemaItem collapsible={false} name={"settlementDataProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement data.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"tradingTerminationProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the data source data that signals termination of trading.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForSettlementData</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

The data source spec describing the data of settlement data.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForTradingTermination</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

The data source spec describing the data source for trading termination.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"quoteName"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Human-readable name/abbreviation of the quote name.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>perpetual</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Perpetual.

</div><SchemaItem collapsible={false} name={"clampLowerBound"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"clampUpperBound"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecBinding</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Binding between the data source spec and the settlement data.

</div><SchemaItem collapsible={false} name={"settlementDataProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"settlementScheduleProperty"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the perpetual market will use the value of\nthis property as settlement data.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForSettlementData</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source spec describing the data source for settlement.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dataSourceSpecForSettlementSchedule</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source spec describing the data source for settlement schedule.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>external</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

DataSourceDefinitionExternal is the top level object used for all external
data sources. It contains one of any of the defined `SourceType` variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethOracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Contains the data specification that is received from Ethereum sources.

</div><SchemaItem collapsible={false} name={"abi"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"The ABI of that contract.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Ethereum address of the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"args"} required={false} schemaName={"object[]"} qualifierMessage={undefined} schema={{"description":"List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI.","items":{"type":"object"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the method on the contract to call.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>normalisers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Normalisers are used to convert the data returned from the contract method
into a standard format. The key of the map is the name of the property,
which identifies the specific piece of data to other parts of the data
sourcing framework, for example filters. The value is a JSONPath expression
for expressing where in the contract call result the required data is
located, for example $[0] indicates the first result. $[1].price would look
in the second result returned from the contract for a structure with a key
called 'price' and use that if it exists.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"expression"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiredConfirmations"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of confirmations required before the query is considered verified","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>trigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions for determining when to call the contract method.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
one-off or repeating.

</div><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"until"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracle</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

All types of external data sources use the same configuration set for meeting
requirements in order for the data to be useful for Vega - valid signatures
and matching filters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Filters describes which source data are considered of interest or not for
the product (or the risk model).

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that should be matched by the data to be
considered of interest.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Data source's data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Name of the property.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"numberDecimalPlaces"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"v1PropertyKeyType"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} schema={{"description":"Data type of the property.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"type":"string","title":"v1PropertyKeyType"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signers is the list of authorized signatures that signed the data for this
source. All the signatures in the data source data should be contained in
this external source. All the signatures in the data should be contained in
this list.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethAddress</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

In case of an open oracle - Ethereum address will be submitted.

</div><SchemaItem collapsible={false} name={"address"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pubKey</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

List of authorized public keys that signed the data for this
source. All the public keys in the data should be contained in these
public keys.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>internal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Top level object used for all internal data sources.
It contains one of any of the defined source type variants.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>time</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps should meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>timeTrigger</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Internal data source used for emitting timestamps automatically using predefined intervals and conditions.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Conditions that the timestamps need to meet in order to be considered.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"operator"} required={false} schemaName={"ConditionOperator"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} schema={{"description":"Type of comparison to make on the value.","default":"OPERATOR_UNSPECIFIED","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"type":"string","title":"ConditionOperator"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value to be compared with by the operator.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"every"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"initial"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Trigger when the vega time is greater or equal to this time, in Unix seconds.","format":"int64","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"interestRate"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"marginFundingFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1].","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"quoteName"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Human-readable name/abbreviation of the quote name.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"linearSlippageFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Liquidity monitoring parameters.

</div><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>targetStakeParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Specifies parameters related to target stake calculation.

</div><SchemaItem collapsible={false} name={"scalingFactor"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Specifies scaling factors used in target stake calculation.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"timeWindow"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Specifies length of time window expressed in seconds for target stake calculation.","format":"int64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"triggeringRatio"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the triggering ratio for entering liquidity auction.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquiditySlaParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"commitmentMinTimeFraction"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the minimum fraction of time LPs must spend \"on the book\" providing their committed liquidity.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"performanceHysteresisEpochs"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Specifies the number of liquidity epochs over which past performance will continue to affect rewards.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"priceRange"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"slaCompetitionFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers\nthat achieved a higher SLA performance than them.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>logNormal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>params</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Risk model parameters for log normal.

</div><SchemaItem collapsible={false} name={"mu"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Mu parameter, annualised growth rate of the underlying asset.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"r"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"sigma"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"riskAversionParameter"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Risk Aversion Parameter.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"tau"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall\ncalculation to obtain the maintenance margin, must be a strictly non-negative real number.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"lpPriceRange"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"DEPRECATED: Use liquidity SLA parameters instead.\nPercentage move up and down from the mid price which specifies the range of\nprice levels over which automated liquidity provisions will be deployed.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"metadata"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"description":"Optional futures market metadata, tags.","items":{"type":"string"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>priceMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Price monitoring parameters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Price monitoring auction extension duration in seconds should the price\nbreach its theoretical level over the specified horizon at the specified\nprobability level.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"horizon"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Price monitoring projection horizon τ in seconds.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"probability"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price monitoring probability level p.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"quadraticSlippageFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>simple</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Simple risk model parameters, valid only if MODEL_SIMPLE is selected.

</div><SchemaItem collapsible={false} name={"factorLong"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined risk factor value for long.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"factorShort"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined risk factor value for short.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"maxMoveUp"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined maximum price move up that the model considers as valid.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"minMoveDown"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined minimum price move down that the model considers as valid.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"probabilityOfTrading"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined constant probability of trading.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID the update is for.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateMarketState</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for updating the state of a market.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"ID of the market"} qualifierMessage={undefined} schema={{"title":"ID of the market","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"Settlement price, relevant only for market termination for futures markets"} qualifierMessage={undefined} schema={{"title":"Settlement price, relevant only for market termination for futures markets","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"updateType"} required={false} schemaName={"Type of the market update"} qualifierMessage={"**Possible values:** [`MARKET_STATE_UPDATE_TYPE_UNSPECIFIED`, `MARKET_STATE_UPDATE_TYPE_TERMINATE`, `MARKET_STATE_UPDATE_TYPE_SUSPEND`, `MARKET_STATE_UPDATE_TYPE_RESUME`]"} schema={{"title":"Type of the market update","default":"MARKET_STATE_UPDATE_TYPE_UNSPECIFIED","enum":["MARKET_STATE_UPDATE_TYPE_UNSPECIFIED","MARKET_STATE_UPDATE_TYPE_TERMINATE","MARKET_STATE_UPDATE_TYPE_SUSPEND","MARKET_STATE_UPDATE_TYPE_RESUME"],"type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateNetworkParameter</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for updating Vega network parameters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

The network parameter to update.

</div><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Unique key of the network parameter.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Value for the network parameter.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateReferralProgram</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for updating the referral program.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Configuration for change to update a referral program.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>benefitTiers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Defined benefit tiers in increasing order. First element will give Tier 1,
second element will give Tier 2, and so on. Determines the level of
benefit a party can expect based on performance criteria.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"minimumEpochs"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Required number of epochs a party must have been in a referral set to\naccess this tier.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"minimumRunningNotionalTakerVolume"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Required running notional taker volume in quantum units for parties\nto access this tier.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"referralDiscountFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Proportion of the referee's taker fees to be discounted.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"referralRewardFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Proportion of the referee's taker fees to be rewarded to the referrer.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"endOfProgramTimestamp"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp as Unix time in seconds, after which when the current epoch\nends, the program will end and benefits will be disabled.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stakingTiers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Defined staking tiers in increasing order. First element will give Tier 1,
second element will give Tier 2, and so on. Determines the level of
benefit a party can expect based on their staking.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"minimumStakedTokens"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Required number of governance tokens ($VEGA) a referrer must have staked to\nreceive the multiplier.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"referralRewardMultiplier"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Multiplier applied to the referral reward factor when calculating referral\nrewards due to the referrer.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"windowLength"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Number of epochs over which to evaluate a referral set's running volume.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateSpotMarket</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for modifying an existing spot market on Vega.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Updated configuration of the spot market.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>logNormal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>params</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Risk model parameters for log normal.

</div><SchemaItem collapsible={false} name={"mu"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Mu parameter, annualised growth rate of the underlying asset.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"r"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"sigma"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"riskAversionParameter"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Risk Aversion Parameter.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"tau"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall\ncalculation to obtain the maintenance margin, must be a strictly non-negative real number.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"metadata"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"description":"Optional spot market metadata, tags.","items":{"type":"string"},"type":"array"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>priceMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Price monitoring parameters.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Price monitoring auction extension duration in seconds should the price\nbreach its theoretical level over the specified horizon at the specified\nprobability level.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"horizon"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Price monitoring projection horizon τ in seconds.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"probability"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price monitoring probability level p.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>simple</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Simple risk model parameters, valid only if MODEL_SIMPLE is selected.

</div><SchemaItem collapsible={false} name={"factorLong"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined risk factor value for long.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"factorShort"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined risk factor value for short.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"maxMoveUp"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined maximum price move up that the model considers as valid.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"minMoveDown"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined minimum price move down that the model considers as valid.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"probabilityOfTrading"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Pre-defined constant probability of trading.","format":"double","type":"number"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>slaParams</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Specifies the liquidity provision SLA parameters.

</div><SchemaItem collapsible={false} name={"commitmentMinTimeFraction"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the minimum fraction of time LPs must spend \"on the book\" providing their committed liquidity.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"performanceHysteresisEpochs"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Specifies the number of liquidity epochs over which past performance will continue to affect rewards.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"priceRange"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"slaCompetitionFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers\nthat achieved a higher SLA performance than them.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>targetStakeParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Specifies parameters related to target stake calculation.

</div><SchemaItem collapsible={false} name={"scalingFactor"} required={false} schemaName={"double"} qualifierMessage={undefined} schema={{"description":"Specifies scaling factors used in target stake calculation.","format":"double","type":"number"}}></SchemaItem><SchemaItem collapsible={false} name={"timeWindow"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Specifies length of time window expressed in seconds for target stake calculation.","format":"int64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID the update is for.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateVolumeDiscountProgram</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Proposal change for updating the volume discount program.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>benefitTiers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Defined benefit tiers in increasing order. First element will give Tier 1,
second element will give Tier 2, and so on. Determines the level of
benefit a party can expect based on performance criteria.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"minimumRunningNotionalTakerVolume"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Required running notional taker volume in quantum units for parties\nto access this tier.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"volumeDiscountFactor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Proportion of the taker fees to be discounted.","type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"endOfProgramTimestamp"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp as Unix time in seconds, after which when the current epoch\nends, the program will end and benefits will be disabled.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"windowLength"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Number of epochs over which to evaluate a referral set's running volume.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"validationTimestamp"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Validation timestamp as Unix time in seconds.","format":"int64","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>protocolUpgradeProposal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Validator command sent manually to propose a protocol upgrade.

</div><SchemaItem collapsible={false} name={"upgradeBlockHeight"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Block height at which to perform the upgrade.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"vegaReleaseTag"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Release tag for the Vega binary.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stateVariableProposal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Validator command sent automatically to reach consensus on floating point values.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>proposal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Details of the state variable being proposed.

</div><SchemaItem collapsible={false} name={"eventId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Event ID.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>kvb</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Key value tolerance triplets.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"key"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"tolerance"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>value</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>matrixVal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>value</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"items":{"type":"string"},"type":"array"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>scalarVal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>vectorVal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"items":{"type":"string"},"type":"array"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"stateVarId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"State variable ID.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stopOrdersCancellation</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A command that instructs the network to cancel untriggered stop orders that were submitted by the sender of this transaction.
If any cancelled stop order is part of an OCO, both stop orders will be cancelled.
It is not possible to cancel another party's stop orders with this command.

</div><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"stopOrderId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Restrict cancellations to a stop order with the given ID. If set, then a market ID must also be provided.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stopOrdersSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A command that allows a party to submit a stop order for a given market.
A stop order is a normal order that remains off the order book and is only submitted if a given trigger is breached from a particular direction.
If both rises-above and falls-below are configured, then if one is triggered the other will be cancelled (OCO).

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>fallsBelow</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Stop order that will be triggered if the price falls below a given trigger price.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"expiryStrategy"} required={false} schemaName={"StopOrderExpiryStrategy"} qualifierMessage={"**Possible values:** [`EXPIRY_STRATEGY_UNSPECIFIED`, `EXPIRY_STRATEGY_CANCELS`, `EXPIRY_STRATEGY_SUBMIT`]"} schema={{"description":"Strategy to adopt if the expiry time is reached.","default":"EXPIRY_STRATEGY_UNSPECIFIED","enum":["EXPIRY_STRATEGY_UNSPECIFIED","EXPIRY_STRATEGY_CANCELS","EXPIRY_STRATEGY_SUBMIT"],"type":"string","title":"StopOrderExpiryStrategy"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Order to be submitted once the trigger is breached.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>icebergOpts</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Iceberg order details. If set, the order will exist on the order book in chunks.

</div><SchemaItem collapsible={false} name={"minimumVisibleSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peakSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID to submit the order to.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>peggedOrder</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.

</div><SchemaItem collapsible={false} name={"offset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Offset from the price reference.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} schema={{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"postOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reduceOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"side"} required={false} schemaName={"Side relates to the direction of an order, to Buy, or Sell"} qualifierMessage={"**Possible values:** [`SIDE_UNSPECIFIED`, `SIDE_BUY`, `SIDE_SELL`]"} schema={{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"size"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaName={"Time In Force for an order"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} schema={{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"Type values for an order"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_LIMIT`, `TYPE_MARKET`, `TYPE_NETWORK`]"} schema={{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Order will be submitted if the last traded price on the market breaches the given price.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"trailingPercentOffset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>risesAbove</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Stop order that will be triggered if the price rises above a given trigger price.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"expiryStrategy"} required={false} schemaName={"StopOrderExpiryStrategy"} qualifierMessage={"**Possible values:** [`EXPIRY_STRATEGY_UNSPECIFIED`, `EXPIRY_STRATEGY_CANCELS`, `EXPIRY_STRATEGY_SUBMIT`]"} schema={{"description":"Strategy to adopt if the expiry time is reached.","default":"EXPIRY_STRATEGY_UNSPECIFIED","enum":["EXPIRY_STRATEGY_UNSPECIFIED","EXPIRY_STRATEGY_CANCELS","EXPIRY_STRATEGY_SUBMIT"],"type":"string","title":"StopOrderExpiryStrategy"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Order to be submitted once the trigger is breached.

</div><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.","format":"int64","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>icebergOpts</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Iceberg order details. If set, the order will exist on the order book in chunks.

</div><SchemaItem collapsible={false} name={"minimumVisibleSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Minimum allowed remaining size of the order before it is replenished back to its peak size.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"peakSize"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size of the order that is made visible and can be traded with during the execution of a single order.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Market ID to submit the order to.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>peggedOrder</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times.

</div><SchemaItem collapsible={false} name={"offset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Offset from the price reference.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} schema={{"description":"Price point the order is linked to.","default":"PEGGED_REFERENCE_UNSPECIFIED","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"title":"Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"postOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"reduceOnly"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"side"} required={false} schemaName={"Side relates to the direction of an order, to Buy, or Sell"} qualifierMessage={"**Possible values:** [`SIDE_UNSPECIFIED`, `SIDE_BUY`, `SIDE_SELL`]"} schema={{"description":"Which side of the order book the order is for, e.g. buy or sell.","default":"SIDE_UNSPECIFIED","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"title":"Side relates to the direction of an order, to Buy, or Sell","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"size"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Size for the order, for example, in a futures market the size equals the number of units.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaName={"Time In Force for an order"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} schema={{"description":"Time in force indicates how long an order will remain active before it is executed or expires..","default":"TIME_IN_FORCE_UNSPECIFIED","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"title":"Time In Force for an order","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"Type values for an order"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_LIMIT`, `TYPE_MARKET`, `TYPE_NETWORK`]"} schema={{"description":"Type of the order.","default":"TYPE_UNSPECIFIED","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"title":"Type values for an order","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Order will be submitted if the last traded price on the market breaches the given price.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"trailingPercentOffset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>transfer</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to submit a transfer.

</div><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Amount to be taken from the source account, as an unsigned integer scaled to the asset's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"asset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Asset ID of the asset to be transferred.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"fromAccountType"} required={false} schemaName={"Various collateral/account types as used by Vega"} qualifierMessage={"**Possible values:** [`ACCOUNT_TYPE_UNSPECIFIED`, `ACCOUNT_TYPE_INSURANCE`, `ACCOUNT_TYPE_SETTLEMENT`, `ACCOUNT_TYPE_MARGIN`, `ACCOUNT_TYPE_GENERAL`, `ACCOUNT_TYPE_FEES_INFRASTRUCTURE`, `ACCOUNT_TYPE_FEES_LIQUIDITY`, `ACCOUNT_TYPE_FEES_MAKER`, `ACCOUNT_TYPE_BOND`, `ACCOUNT_TYPE_EXTERNAL`, `ACCOUNT_TYPE_GLOBAL_INSURANCE`, `ACCOUNT_TYPE_GLOBAL_REWARD`, `ACCOUNT_TYPE_PENDING_TRANSFERS`, `ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES`, `ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS`, `ACCOUNT_TYPE_HOLDING`, `ACCOUNT_TYPE_LP_LIQUIDITY_FEES`, `ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION`, `ACCOUNT_TYPE_NETWORK_TREASURY`, `ACCOUNT_TYPE_VESTING_REWARDS`, `ACCOUNT_TYPE_VESTED_REWARDS`, `ACCOUNT_TYPE_REWARD_AVERAGE_POSITION`, `ACCOUNT_TYPE_REWARD_RELATIVE_RETURN`, `ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY`, `ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING`, `ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD`]"} schema={{"description":"Account type from which the funds of the party should be taken.","default":"ACCOUNT_TYPE_UNSPECIFIED","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS","ACCOUNT_TYPE_HOLDING","ACCOUNT_TYPE_LP_LIQUIDITY_FEES","ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION","ACCOUNT_TYPE_NETWORK_TREASURY","ACCOUNT_TYPE_VESTING_REWARDS","ACCOUNT_TYPE_VESTED_REWARDS","ACCOUNT_TYPE_REWARD_AVERAGE_POSITION","ACCOUNT_TYPE_REWARD_RELATIVE_RETURN","ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY","ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING","ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD"],"title":"Various collateral/account types as used by Vega","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oneOff</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Details of a one-off transfer that is executed once at a specified time.

</div><SchemaItem collapsible={false} name={"deliverOn"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Timestamp, in Unix nanoseconds, for when the transfer should be executed, i.e., assets transferred into the receiver's account.","format":"int64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>recurring</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Details of a transfer that is executed once every epoch until stopped.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dispatchStrategy</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Optional parameter defining how a transfer is dispatched.

</div><SchemaItem collapsible={false} name={"assetForMetric"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Asset to use for metric.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"distributionStrategy"} required={false} schemaName={"Controls how the reward is distributed between qualifying parties"} qualifierMessage={"**Possible values:** [`DISTRIBUTION_STRATEGY_UNSPECIFIED`, `DISTRIBUTION_STRATEGY_PRO_RATA`, `DISTRIBUTION_STRATEGY_RANK`]"} schema={{"title":"Controls how the reward is distributed between qualifying parties","default":"DISTRIBUTION_STRATEGY_UNSPECIFIED","description":" - DISTRIBUTION_STRATEGY_PRO_RATA: Rewards funded using the pro-rata strategy should be distributed pro-rata by each entity's reward metric, scaled by any active multipliers that party has.\n - DISTRIBUTION_STRATEGY_RANK: Rewards funded using the party rank.","enum":["DISTRIBUTION_STRATEGY_UNSPECIFIED","DISTRIBUTION_STRATEGY_PRO_RATA","DISTRIBUTION_STRATEGY_RANK"],"type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"entityScope"} required={false} schemaName={"- ENTITY_SCOPE_INDIVIDUALS: Rewards must be distributed directly to eligible parties.\n - ENTITY_SCOPE_TEAMS: Rewards must be distributed to directly eligible teams, and then amongst team members"} qualifierMessage={"**Possible values:** [`ENTITY_SCOPE_UNSPECIFIED`, `ENTITY_SCOPE_INDIVIDUALS`, `ENTITY_SCOPE_TEAMS`]"} schema={{"description":"Mandatory enum that defines the entities within scope.","default":"ENTITY_SCOPE_UNSPECIFIED","enum":["ENTITY_SCOPE_UNSPECIFIED","ENTITY_SCOPE_INDIVIDUALS","ENTITY_SCOPE_TEAMS"],"title":"- ENTITY_SCOPE_INDIVIDUALS: Rewards must be distributed directly to eligible parties.\n - ENTITY_SCOPE_TEAMS: Rewards must be distributed to directly eligible teams, and then amongst team members","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"individualScope"} required={false} schemaName={"vegaIndividualScope"} qualifierMessage={"**Possible values:** [`INDIVIDUAL_SCOPE_UNSPECIFIED`, `INDIVIDUAL_SCOPE_ALL`, `INDIVIDUAL_SCOPE_IN_TEAM`, `INDIVIDUAL_SCOPE_NOT_IN_TEAM`]"} schema={{"description":"Optional enum if the entity scope defined is for individuals, which determines the subset of individuals that are eligible to be rewarded.","default":"INDIVIDUAL_SCOPE_UNSPECIFIED","enum":["INDIVIDUAL_SCOPE_UNSPECIFIED","INDIVIDUAL_SCOPE_ALL","INDIVIDUAL_SCOPE_IN_TEAM","INDIVIDUAL_SCOPE_NOT_IN_TEAM"],"type":"string","title":"vegaIndividualScope"}}></SchemaItem><SchemaItem collapsible={false} name={"lockPeriod"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of epochs after distribution to delay vesting of rewards by","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"markets"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"description":"Optional markets in scope.","items":{"type":"string"},"type":"array"}}></SchemaItem><SchemaItem collapsible={false} name={"metric"} required={false} schemaName={"- DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that uses the total maker fees paid in the market\n - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that uses the total maker fees received in the market\n - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that uses the total LP fees received in the market\n - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that uses total value of the market if above the required threshold and not paid given proposer bonus yet\n - DISPATCH_METRIC_AVERAGE_POSITION: Dispatch metric that uses the time weighted average position\n - DISPATCH_METRIC_RELATIVE_RETURN: Dispatch metric that uses the relative PNL of the party in the market\n - DISPATCH_METRIC_RETURN_VOLATILITY: Dispatch metric that uses return volatility of the party in the market\n - DISPATCH_METRIC_VALIDATOR_RANKING: Dispatch metric that uses the validator ranking of the validator as metric"} qualifierMessage={"**Possible values:** [`DISPATCH_METRIC_UNSPECIFIED`, `DISPATCH_METRIC_MAKER_FEES_PAID`, `DISPATCH_METRIC_MAKER_FEES_RECEIVED`, `DISPATCH_METRIC_LP_FEES_RECEIVED`, `DISPATCH_METRIC_MARKET_VALUE`, `DISPATCH_METRIC_AVERAGE_POSITION`, `DISPATCH_METRIC_RELATIVE_RETURN`, `DISPATCH_METRIC_RETURN_VOLATILITY`, `DISPATCH_METRIC_VALIDATOR_RANKING`]"} schema={{"description":"Metric to apply.","default":"DISPATCH_METRIC_UNSPECIFIED","enum":["DISPATCH_METRIC_UNSPECIFIED","DISPATCH_METRIC_MAKER_FEES_PAID","DISPATCH_METRIC_MAKER_FEES_RECEIVED","DISPATCH_METRIC_LP_FEES_RECEIVED","DISPATCH_METRIC_MARKET_VALUE","DISPATCH_METRIC_AVERAGE_POSITION","DISPATCH_METRIC_RELATIVE_RETURN","DISPATCH_METRIC_RETURN_VOLATILITY","DISPATCH_METRIC_VALIDATOR_RANKING"],"title":"- DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that uses the total maker fees paid in the market\n - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that uses the total maker fees received in the market\n - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that uses the total LP fees received in the market\n - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that uses total value of the market if above the required threshold and not paid given proposer bonus yet\n - DISPATCH_METRIC_AVERAGE_POSITION: Dispatch metric that uses the time weighted average position\n - DISPATCH_METRIC_RELATIVE_RETURN: Dispatch metric that uses the relative PNL of the party in the market\n - DISPATCH_METRIC_RETURN_VOLATILITY: Dispatch metric that uses return volatility of the party in the market\n - DISPATCH_METRIC_VALIDATOR_RANKING: Dispatch metric that uses the validator ranking of the validator as metric","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"nTopPerformers"} required={false} schemaName={"The proportion of the top performers in the team for a given metric to be averaged for the metric calculation if the scope is team"} qualifierMessage={undefined} schema={{"title":"The proportion of the top performers in the team for a given metric to be averaged for the metric calculation if the scope is team","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"notionalTimeWeightedAveragePositionRequirement"} required={false} schemaName={"Minimum notional time-weighted averaged position required for a party to be considered eligible. Defaults to 0"} qualifierMessage={undefined} schema={{"title":"Minimum notional time-weighted averaged position required for a party to be considered eligible. Defaults to 0","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>rankTable</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Ordered list, using start rank, defining the rank bands and share ratio for each band. Mandatory for the rank distribution strategy.

</div><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"shareRatio"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","type":"integer"}}></SchemaItem><SchemaItem collapsible={false} name={"startRank"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","type":"integer"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"stakingRequirement"} required={false} schemaName={"Minimum number of governance (e.g. VEGA) tokens staked for a party to be considered eligible. Defaults to 0"} qualifierMessage={undefined} schema={{"title":"Minimum number of governance (e.g. VEGA) tokens staked for a party to be considered eligible. Defaults to 0","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"teamScope"} required={false} schemaName={"string[]"} qualifierMessage={undefined} schema={{"items":{"type":"string"},"title":"Optional list applicable if the reward type has a scope of teams, which allows the funder to define a list of team IDs that are eligible to be rewarded from this transfer","type":"array"}}></SchemaItem><SchemaItem collapsible={false} name={"windowLength"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"format":"uint64","title":"Number of epochs to evaluate the metric on","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"endEpoch"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Last epoch at which this transfer shall be executed.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"factor"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Factor that the initial transfer amount is multiplied by for each epoch that it is executed.\nFor example if the initial transfer amount is 1000 and the factor is 0.5, then the amounts transferred per epoch will be 1000, 500, 250, 125, etc.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"startEpoch"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"First epoch from which this transfer shall be executed.","format":"uint64","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Reference to be attached to the transfer.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"to"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Public key of the destination account.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"toAccountType"} required={false} schemaName={"Various collateral/account types as used by Vega"} qualifierMessage={"**Possible values:** [`ACCOUNT_TYPE_UNSPECIFIED`, `ACCOUNT_TYPE_INSURANCE`, `ACCOUNT_TYPE_SETTLEMENT`, `ACCOUNT_TYPE_MARGIN`, `ACCOUNT_TYPE_GENERAL`, `ACCOUNT_TYPE_FEES_INFRASTRUCTURE`, `ACCOUNT_TYPE_FEES_LIQUIDITY`, `ACCOUNT_TYPE_FEES_MAKER`, `ACCOUNT_TYPE_BOND`, `ACCOUNT_TYPE_EXTERNAL`, `ACCOUNT_TYPE_GLOBAL_INSURANCE`, `ACCOUNT_TYPE_GLOBAL_REWARD`, `ACCOUNT_TYPE_PENDING_TRANSFERS`, `ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES`, `ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS`, `ACCOUNT_TYPE_HOLDING`, `ACCOUNT_TYPE_LP_LIQUIDITY_FEES`, `ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION`, `ACCOUNT_TYPE_NETWORK_TREASURY`, `ACCOUNT_TYPE_VESTING_REWARDS`, `ACCOUNT_TYPE_VESTED_REWARDS`, `ACCOUNT_TYPE_REWARD_AVERAGE_POSITION`, `ACCOUNT_TYPE_REWARD_RELATIVE_RETURN`, `ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY`, `ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING`, `ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD`]"} schema={{"description":"Type of the destination account.","default":"ACCOUNT_TYPE_UNSPECIFIED","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS","ACCOUNT_TYPE_HOLDING","ACCOUNT_TYPE_LP_LIQUIDITY_FEES","ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION","ACCOUNT_TYPE_NETWORK_TREASURY","ACCOUNT_TYPE_VESTING_REWARDS","ACCOUNT_TYPE_VESTED_REWARDS","ACCOUNT_TYPE_REWARD_AVERAGE_POSITION","ACCOUNT_TYPE_REWARD_RELATIVE_RETURN","ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY","ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING","ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD"],"title":"Various collateral/account types as used by Vega","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>undelegateSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to remove tokens delegated to a validator.

</div><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Amount to undelegate, as an unsigned integer scaled to the governance asset's decimal places.\nIf not set, then all delegations to the given validator node will be removed.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaName={"UndelegateSubmissionMethod"} qualifierMessage={"**Possible values:** [`METHOD_UNSPECIFIED`, `METHOD_NOW`, `METHOD_AT_END_OF_EPOCH`]"} schema={{"description":"Method of delegation.","default":"METHOD_UNSPECIFIED","enum":["METHOD_UNSPECIFIED","METHOD_NOW","METHOD_AT_END_OF_EPOCH"],"type":"string","title":"UndelegateSubmissionMethod"}}></SchemaItem><SchemaItem collapsible={false} name={"nodeId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Node ID to undelegate stake from.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateReferralSet</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to update a referral set.

</div><SchemaItem collapsible={false} name={"id"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"ID of the referral set to update.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"isTeam"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"Whether or not the referral set should be considered a team that can participate in team games on the network.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>team</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Team details, if the referral set is to be considered a team.

</div><SchemaItem collapsible={false} name={"avatarUrl"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New link to an avatar for the team.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"closed"} required={false} schemaName={"boolean"} qualifierMessage={undefined} schema={{"description":"Whether or not the team is closed to new party members.","type":"boolean"}}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New name of the team.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"teamUrl"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"New link to the team's homepage.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>validatorHeartbeat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Validator command sent automatically to signal regular participation in the network.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethereumSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signature from the validator made using their Ethereum wallet.

</div><SchemaItem collapsible={false} name={"algo"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Algorithm used to create the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Hex encoded bytes of the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"message"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Message which has been signed.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"nodeId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Node ID of the validator emitting the heartbeat.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>vegaSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signature from the validator made using their Vega wallet.

</div><SchemaItem collapsible={false} name={"algo"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Algorithm used to create the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Hex encoded bytes of the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>voteSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to submit a vote on a governance proposal.

</div><SchemaItem collapsible={false} name={"proposalId"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Submit vote for the specified proposal ID.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"Vote value"} qualifierMessage={"**Possible values:** [`VALUE_UNSPECIFIED`, `VALUE_NO`, `VALUE_YES`]"} schema={{"description":"Actual value of the vote.","default":"VALUE_UNSPECIFIED","enum":["VALUE_UNSPECIFIED","VALUE_NO","VALUE_YES"],"title":"Vote value","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>withdrawSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Command to submit a withdrawal.

</div><SchemaItem collapsible={false} name={"amount"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Amount to be withdrawn, as an unsigned integer scaled to the asset's decimal places.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"asset"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Asset to be withdrawn.","type":"string"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ext</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Details specific to the foreign chain, such as the receiver address.

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

ERC20 withdrawal details.

</div><SchemaItem collapsible={false} name={"receiverAddress"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Address into which the bridge will release the funds.","type":"string"}}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"createdAt"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Timestamp when the transaction happened, using RFC3399 format.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"cursor"} required={false} schemaName={"Cursor for this transaction. This is used for paginating results"} qualifierMessage={undefined} schema={{"title":"Cursor for this transaction. This is used for paginating results","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"error"} required={false} schemaName={"Optional error happening when processing / checking the transaction\nThis should be set if error code is not 0"} qualifierMessage={undefined} schema={{"title":"Optional error happening when processing / checking the transaction\nThis should be set if error code is not 0","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"hash"} required={false} schemaName={"Hash of the transaction"} qualifierMessage={undefined} schema={{"title":"Hash of the transaction","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"index"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"format":"int64","title":"Index of the transaction in the block","type":"integer"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>pow</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Components needed for the network to verify proof-of-work.

</div><SchemaItem collapsible={false} name={"nonce"} required={false} schemaName={"uint64"} qualifierMessage={undefined} schema={{"description":"Number which, combined with the transaction identifier, will produce a hash with the required number of leading zeros to be accepted by the network.","format":"uint64","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"tid"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Unique transaction identifier used to seed the proof-of-work hash.","type":"string"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Signature definition that allows the network to authenticate external data.

</div><SchemaItem collapsible={false} name={"algo"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Algorithm used to create the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"description":"Hex encoded bytes of the signature.","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaName={"int64"} qualifierMessage={undefined} schema={{"description":"Version of the algorithm used to create the signature.","format":"int64","type":"integer"}}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"submitter"} required={false} schemaName={"Vega public key of the transaction's submitter"} qualifierMessage={undefined} schema={{"title":"Vega public key of the transaction's submitter","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaName={"Type of transaction"} qualifierMessage={undefined} schema={{"title":"Type of transaction","type":"string"}}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaName={"Version format of the transaction"} qualifierMessage={"**Possible values:** [`TX_VERSION_UNSPECIFIED`, `TX_VERSION_V2`, `TX_VERSION_V3`]"} schema={{"title":"Version format of the transaction","default":"TX_VERSION_UNSPECIFIED","description":"Transaction versions to maintain backwards compatibility of transaction formats.\n\n - TX_VERSION_UNSPECIFIED: Transaction version is unspecified.\n - TX_VERSION_V2: Transaction requires the addition of a proof-of-work calculation.\n - TX_VERSION_V3: Transaction input data contains a prepended chain ID to prevent use of a single transaction across multiple networks.","enum":["TX_VERSION_UNSPECIFIED","TX_VERSION_V2","TX_VERSION_V3"],"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"transactions\": [\n    {\n      \"block\": \"string\",\n      \"code\": 0,\n      \"command\": {\n        \"announceNode\": {\n          \"avatarUrl\": \"string\",\n          \"chainPubKey\": \"string\",\n          \"country\": \"string\",\n          \"ethereumAddress\": \"string\",\n          \"ethereumSignature\": {\n            \"algo\": \"string\",\n            \"value\": \"string\",\n            \"version\": 0\n          },\n          \"fromEpoch\": \"string\",\n          \"id\": \"string\",\n          \"infoUrl\": \"string\",\n          \"name\": \"string\",\n          \"submitterAddress\": \"string\",\n          \"vegaPubKey\": \"string\",\n          \"vegaPubKeyIndex\": 0,\n          \"vegaSignature\": {\n            \"algo\": \"string\",\n            \"value\": \"string\",\n            \"version\": 0\n          }\n        },\n        \"applyReferralCode\": {\n          \"id\": \"string\"\n        },\n        \"batchMarketInstructions\": {\n          \"amendments\": [\n            {\n              \"expiresAt\": \"string\",\n              \"marketId\": \"string\",\n              \"orderId\": \"string\",\n              \"peggedOffset\": \"string\",\n              \"peggedReference\": \"PEGGED_REFERENCE_UNSPECIFIED\",\n              \"price\": \"string\",\n              \"sizeDelta\": \"string\",\n              \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\"\n            }\n          ],\n          \"cancellations\": [\n            {\n              \"marketId\": \"string\",\n              \"orderId\": \"string\"\n            }\n          ],\n          \"stopOrdersCancellation\": [\n            {\n              \"marketId\": \"string\",\n              \"stopOrderId\": \"string\"\n            }\n          ],\n          \"stopOrdersSubmission\": [\n            {\n              \"fallsBelow\": {\n                \"expiresAt\": \"string\",\n                \"expiryStrategy\": \"EXPIRY_STRATEGY_UNSPECIFIED\",\n                \"orderSubmission\": {\n                  \"expiresAt\": \"string\",\n                  \"icebergOpts\": {\n                    \"minimumVisibleSize\": \"string\",\n                    \"peakSize\": \"string\"\n                  },\n                  \"marketId\": \"string\",\n                  \"peggedOrder\": {\n                    \"offset\": \"string\",\n                    \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\"\n                  },\n                  \"postOnly\": true,\n                  \"price\": \"string\",\n                  \"reduceOnly\": true,\n                  \"reference\": \"string\",\n                  \"side\": \"SIDE_UNSPECIFIED\",\n                  \"size\": \"string\",\n                  \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n                  \"type\": \"TYPE_UNSPECIFIED\"\n                },\n                \"price\": \"string\",\n                \"trailingPercentOffset\": \"string\"\n              },\n              \"risesAbove\": {\n                \"expiresAt\": \"string\",\n                \"expiryStrategy\": \"EXPIRY_STRATEGY_UNSPECIFIED\",\n                \"orderSubmission\": {\n                  \"expiresAt\": \"string\",\n                  \"icebergOpts\": {\n                    \"minimumVisibleSize\": \"string\",\n                    \"peakSize\": \"string\"\n                  },\n                  \"marketId\": \"string\",\n                  \"peggedOrder\": {\n                    \"offset\": \"string\",\n                    \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\"\n                  },\n                  \"postOnly\": true,\n                  \"price\": \"string\",\n                  \"reduceOnly\": true,\n                  \"reference\": \"string\",\n                  \"side\": \"SIDE_UNSPECIFIED\",\n                  \"size\": \"string\",\n                  \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n                  \"type\": \"TYPE_UNSPECIFIED\"\n                },\n                \"price\": \"string\",\n                \"trailingPercentOffset\": \"string\"\n              }\n            }\n          ],\n          \"submissions\": [\n            {\n              \"expiresAt\": \"string\",\n              \"icebergOpts\": {\n                \"minimumVisibleSize\": \"string\",\n                \"peakSize\": \"string\"\n              },\n              \"marketId\": \"string\",\n              \"peggedOrder\": {\n                \"offset\": \"string\",\n                \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\"\n              },\n              \"postOnly\": true,\n              \"price\": \"string\",\n              \"reduceOnly\": true,\n              \"reference\": \"string\",\n              \"side\": \"SIDE_UNSPECIFIED\",\n              \"size\": \"string\",\n              \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n              \"type\": \"TYPE_UNSPECIFIED\"\n            }\n          ]\n        },\n        \"blockHeight\": \"string\",\n        \"cancelTransfer\": {\n          \"transferId\": \"string\"\n        },\n        \"chainEvent\": {\n          \"builtin\": {\n            \"deposit\": {\n              \"amount\": \"string\",\n              \"partyId\": \"string\",\n              \"vegaAssetId\": \"string\"\n            },\n            \"withdrawal\": {\n              \"amount\": \"string\",\n              \"partyId\": \"string\",\n              \"vegaAssetId\": \"string\"\n            }\n          },\n          \"contractCall\": {\n            \"blockHeight\": \"string\",\n            \"blockTime\": \"string\",\n            \"error\": \"string\",\n            \"result\": \"string\",\n            \"specId\": \"string\"\n          },\n          \"erc20\": {\n            \"assetDelist\": {\n              \"vegaAssetId\": \"string\"\n            },\n            \"assetLimitsUpdated\": {\n              \"lifetimeLimits\": \"string\",\n              \"sourceEthereumAddress\": \"string\",\n              \"vegaAssetId\": \"string\",\n              \"withdrawThreshold\": \"string\"\n            },\n            \"assetList\": {\n              \"assetSource\": \"string\",\n              \"vegaAssetId\": \"string\"\n            },\n            \"block\": \"string\",\n            \"bridgeResumed\": true,\n            \"bridgeStopped\": true,\n            \"deposit\": {\n              \"amount\": \"string\",\n              \"sourceEthereumAddress\": \"string\",\n              \"targetPartyId\": \"string\",\n              \"vegaAssetId\": \"string\"\n            },\n            \"index\": \"string\",\n            \"withdrawal\": {\n              \"referenceNonce\": \"string\",\n              \"targetEthereumAddress\": \"string\",\n              \"vegaAssetId\": \"string\"\n            }\n          },\n          \"erc20Multisig\": {\n            \"block\": \"string\",\n            \"index\": \"string\",\n            \"signerAdded\": {\n              \"blockTime\": \"string\",\n              \"newSigner\": \"string\",\n              \"nonce\": \"string\"\n            },\n            \"signerRemoved\": {\n              \"blockTime\": \"string\",\n              \"nonce\": \"string\",\n              \"oldSigner\": \"string\"\n            },\n            \"thresholdSet\": {\n              \"blockTime\": \"string\",\n              \"newThreshold\": 0,\n              \"nonce\": \"string\"\n            }\n          },\n          \"nonce\": \"string\",\n          \"stakingEvent\": {\n            \"block\": \"string\",\n            \"index\": \"string\",\n            \"stakeDeposited\": {\n              \"amount\": \"string\",\n              \"blockTime\": \"string\",\n              \"ethereumAddress\": \"string\",\n              \"vegaPublicKey\": \"string\"\n            },\n            \"stakeRemoved\": {\n              \"amount\": \"string\",\n              \"blockTime\": \"string\",\n              \"ethereumAddress\": \"string\",\n              \"vegaPublicKey\": \"string\"\n            },\n            \"totalSupply\": {\n              \"tokenAddress\": \"string\",\n              \"totalSupply\": \"string\"\n            }\n          },\n          \"txId\": \"string\"\n        },\n        \"createReferralSet\": {\n          \"isTeam\": true,\n          \"team\": {\n            \"avatarUrl\": \"string\",\n            \"closed\": true,\n            \"name\": \"string\",\n            \"teamUrl\": \"string\"\n          }\n        },\n        \"delegateSubmission\": {\n          \"amount\": \"string\",\n          \"nodeId\": \"string\"\n        },\n        \"ethereumKeyRotateSubmission\": {\n          \"currentAddress\": \"string\",\n          \"ethereumSignature\": {\n            \"algo\": \"string\",\n            \"value\": \"string\",\n            \"version\": 0\n          },\n          \"newAddress\": \"string\",\n          \"submitterAddress\": \"string\",\n          \"targetBlock\": \"string\"\n        },\n        \"issueSignatures\": {\n          \"kind\": \"NODE_SIGNATURE_KIND_UNSPECIFIED\",\n          \"submitter\": \"string\",\n          \"validatorNodeId\": \"string\"\n        },\n        \"keyRotateSubmission\": {\n          \"currentPubKeyHash\": \"string\",\n          \"newPubKey\": \"string\",\n          \"newPubKeyIndex\": 0,\n          \"targetBlock\": \"string\"\n        },\n        \"liquidityProvisionAmendment\": {\n          \"commitmentAmount\": \"string\",\n          \"fee\": \"string\",\n          \"marketId\": \"string\",\n          \"reference\": \"string\"\n        },\n        \"liquidityProvisionCancellation\": {\n          \"marketId\": \"string\"\n        },\n        \"liquidityProvisionSubmission\": {\n          \"commitmentAmount\": \"string\",\n          \"fee\": \"string\",\n          \"marketId\": \"string\",\n          \"reference\": \"string\"\n        },\n        \"nodeSignature\": {\n          \"id\": \"string\",\n          \"kind\": \"NODE_SIGNATURE_KIND_UNSPECIFIED\",\n          \"sig\": \"string\"\n        },\n        \"nodeVote\": {\n          \"reference\": \"string\",\n          \"type\": \"TYPE_UNSPECIFIED\"\n        },\n        \"nonce\": \"string\",\n        \"oracleDataSubmission\": {\n          \"payload\": \"string\",\n          \"source\": \"ORACLE_SOURCE_UNSPECIFIED\"\n        },\n        \"orderAmendment\": {\n          \"expiresAt\": \"string\",\n          \"marketId\": \"string\",\n          \"orderId\": \"string\",\n          \"peggedOffset\": \"string\",\n          \"peggedReference\": \"PEGGED_REFERENCE_UNSPECIFIED\",\n          \"price\": \"string\",\n          \"sizeDelta\": \"string\",\n          \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\"\n        },\n        \"orderCancellation\": {\n          \"marketId\": \"string\",\n          \"orderId\": \"string\"\n        },\n        \"orderSubmission\": {\n          \"expiresAt\": \"string\",\n          \"icebergOpts\": {\n            \"minimumVisibleSize\": \"string\",\n            \"peakSize\": \"string\"\n          },\n          \"marketId\": \"string\",\n          \"peggedOrder\": {\n            \"offset\": \"string\",\n            \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\"\n          },\n          \"postOnly\": true,\n          \"price\": \"string\",\n          \"reduceOnly\": true,\n          \"reference\": \"string\",\n          \"side\": \"SIDE_UNSPECIFIED\",\n          \"size\": \"string\",\n          \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n          \"type\": \"TYPE_UNSPECIFIED\"\n        },\n        \"proposalSubmission\": {\n          \"rationale\": {\n            \"description\": \"string\",\n            \"title\": \"string\"\n          },\n          \"reference\": \"string\",\n          \"terms\": {\n            \"cancelTransfer\": {\n              \"changes\": {\n                \"transferId\": \"string\"\n              }\n            },\n            \"closingTimestamp\": \"string\",\n            \"enactmentTimestamp\": \"string\",\n            \"newAsset\": {\n              \"changes\": {\n                \"builtinAsset\": {\n                  \"maxFaucetAmountMint\": \"string\"\n                },\n                \"decimals\": \"string\",\n                \"erc20\": {\n                  \"contractAddress\": \"string\",\n                  \"lifetimeLimit\": \"string\",\n                  \"withdrawThreshold\": \"string\"\n                },\n                \"name\": \"string\",\n                \"quantum\": \"string\",\n                \"symbol\": \"string\"\n              }\n            },\n            \"newFreeform\": {},\n            \"newMarket\": {\n              \"changes\": {\n                \"decimalPlaces\": \"string\",\n                \"instrument\": {\n                  \"code\": \"string\",\n                  \"future\": {\n                    \"dataSourceSpecBinding\": {\n                      \"settlementDataProperty\": \"string\",\n                      \"tradingTerminationProperty\": \"string\"\n                    },\n                    \"dataSourceSpecForSettlementData\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"dataSourceSpecForTradingTermination\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"quoteName\": \"string\",\n                    \"settlementAsset\": \"string\"\n                  },\n                  \"name\": \"string\",\n                  \"perpetual\": {\n                    \"clampLowerBound\": \"string\",\n                    \"clampUpperBound\": \"string\",\n                    \"dataSourceSpecBinding\": {\n                      \"settlementDataProperty\": \"string\",\n                      \"settlementScheduleProperty\": \"string\"\n                    },\n                    \"dataSourceSpecForSettlementData\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"dataSourceSpecForSettlementSchedule\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"interestRate\": \"string\",\n                    \"marginFundingFactor\": \"string\",\n                    \"quoteName\": \"string\",\n                    \"settlementAsset\": \"string\"\n                  },\n                  \"spot\": {\n                    \"baseAsset\": \"string\",\n                    \"name\": \"string\",\n                    \"quoteAsset\": \"string\"\n                  }\n                },\n                \"linearSlippageFactor\": \"string\",\n                \"liquidityMonitoringParameters\": {\n                  \"auctionExtension\": \"string\",\n                  \"targetStakeParameters\": {\n                    \"scalingFactor\": 0,\n                    \"timeWindow\": \"string\"\n                  },\n                  \"triggeringRatio\": \"string\"\n                },\n                \"liquiditySlaParameters\": {\n                  \"commitmentMinTimeFraction\": \"string\",\n                  \"performanceHysteresisEpochs\": \"string\",\n                  \"priceRange\": \"string\",\n                  \"slaCompetitionFactor\": \"string\"\n                },\n                \"logNormal\": {\n                  \"params\": {\n                    \"mu\": 0,\n                    \"r\": 0,\n                    \"sigma\": 0\n                  },\n                  \"riskAversionParameter\": 0,\n                  \"tau\": 0\n                },\n                \"lpPriceRange\": \"string\",\n                \"metadata\": [\n                  \"string\"\n                ],\n                \"positionDecimalPlaces\": \"string\",\n                \"priceMonitoringParameters\": {\n                  \"triggers\": [\n                    {\n                      \"auctionExtension\": \"string\",\n                      \"horizon\": \"string\",\n                      \"probability\": \"string\"\n                    }\n                  ]\n                },\n                \"quadraticSlippageFactor\": \"string\",\n                \"simple\": {\n                  \"factorLong\": 0,\n                  \"factorShort\": 0,\n                  \"maxMoveUp\": 0,\n                  \"minMoveDown\": 0,\n                  \"probabilityOfTrading\": 0\n                },\n                \"successor\": {\n                  \"insurancePoolFraction\": \"string\",\n                  \"parentMarketId\": \"string\"\n                }\n              }\n            },\n            \"newSpotMarket\": {\n              \"changes\": {\n                \"decimalPlaces\": \"string\",\n                \"instrument\": {\n                  \"code\": \"string\",\n                  \"future\": {\n                    \"dataSourceSpecBinding\": {\n                      \"settlementDataProperty\": \"string\",\n                      \"tradingTerminationProperty\": \"string\"\n                    },\n                    \"dataSourceSpecForSettlementData\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"dataSourceSpecForTradingTermination\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"quoteName\": \"string\",\n                    \"settlementAsset\": \"string\"\n                  },\n                  \"name\": \"string\",\n                  \"perpetual\": {\n                    \"clampLowerBound\": \"string\",\n                    \"clampUpperBound\": \"string\",\n                    \"dataSourceSpecBinding\": {\n                      \"settlementDataProperty\": \"string\",\n                      \"settlementScheduleProperty\": \"string\"\n                    },\n                    \"dataSourceSpecForSettlementData\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"dataSourceSpecForSettlementSchedule\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"interestRate\": \"string\",\n                    \"marginFundingFactor\": \"string\",\n                    \"quoteName\": \"string\",\n                    \"settlementAsset\": \"string\"\n                  },\n                  \"spot\": {\n                    \"baseAsset\": \"string\",\n                    \"name\": \"string\",\n                    \"quoteAsset\": \"string\"\n                  }\n                },\n                \"logNormal\": {\n                  \"params\": {\n                    \"mu\": 0,\n                    \"r\": 0,\n                    \"sigma\": 0\n                  },\n                  \"riskAversionParameter\": 0,\n                  \"tau\": 0\n                },\n                \"metadata\": [\n                  \"string\"\n                ],\n                \"positionDecimalPlaces\": \"string\",\n                \"priceMonitoringParameters\": {\n                  \"triggers\": [\n                    {\n                      \"auctionExtension\": \"string\",\n                      \"horizon\": \"string\",\n                      \"probability\": \"string\"\n                    }\n                  ]\n                },\n                \"simple\": {\n                  \"factorLong\": 0,\n                  \"factorShort\": 0,\n                  \"maxMoveUp\": 0,\n                  \"minMoveDown\": 0,\n                  \"probabilityOfTrading\": 0\n                },\n                \"slaParams\": {\n                  \"commitmentMinTimeFraction\": \"string\",\n                  \"performanceHysteresisEpochs\": \"string\",\n                  \"priceRange\": \"string\",\n                  \"slaCompetitionFactor\": \"string\"\n                },\n                \"targetStakeParameters\": {\n                  \"scalingFactor\": 0,\n                  \"timeWindow\": \"string\"\n                }\n              }\n            },\n            \"newTransfer\": {\n              \"changes\": {\n                \"amount\": \"string\",\n                \"asset\": \"string\",\n                \"destination\": \"string\",\n                \"destinationType\": \"ACCOUNT_TYPE_UNSPECIFIED\",\n                \"fractionOfBalance\": \"string\",\n                \"oneOff\": {\n                  \"deliverOn\": \"string\"\n                },\n                \"recurring\": {\n                  \"dispatchStrategy\": {\n                    \"assetForMetric\": \"string\",\n                    \"distributionStrategy\": \"DISTRIBUTION_STRATEGY_UNSPECIFIED\",\n                    \"entityScope\": \"ENTITY_SCOPE_UNSPECIFIED\",\n                    \"individualScope\": \"INDIVIDUAL_SCOPE_UNSPECIFIED\",\n                    \"lockPeriod\": \"string\",\n                    \"markets\": [\n                      \"string\"\n                    ],\n                    \"metric\": \"DISPATCH_METRIC_UNSPECIFIED\",\n                    \"nTopPerformers\": \"string\",\n                    \"notionalTimeWeightedAveragePositionRequirement\": \"string\",\n                    \"rankTable\": [\n                      {\n                        \"shareRatio\": 0,\n                        \"startRank\": 0\n                      }\n                    ],\n                    \"stakingRequirement\": \"string\",\n                    \"teamScope\": [\n                      \"string\"\n                    ],\n                    \"windowLength\": \"string\"\n                  },\n                  \"endEpoch\": \"string\",\n                  \"startEpoch\": \"string\"\n                },\n                \"source\": \"string\",\n                \"sourceType\": \"ACCOUNT_TYPE_UNSPECIFIED\",\n                \"transferType\": \"GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED\"\n              }\n            },\n            \"updateAsset\": {\n              \"assetId\": \"string\",\n              \"changes\": {\n                \"erc20\": {\n                  \"lifetimeLimit\": \"string\",\n                  \"withdrawThreshold\": \"string\"\n                },\n                \"quantum\": \"string\"\n              }\n            },\n            \"updateMarket\": {\n              \"changes\": {\n                \"instrument\": {\n                  \"code\": \"string\",\n                  \"future\": {\n                    \"dataSourceSpecBinding\": {\n                      \"settlementDataProperty\": \"string\",\n                      \"tradingTerminationProperty\": \"string\"\n                    },\n                    \"dataSourceSpecForSettlementData\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"dataSourceSpecForTradingTermination\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"quoteName\": \"string\"\n                  },\n                  \"perpetual\": {\n                    \"clampLowerBound\": \"string\",\n                    \"clampUpperBound\": \"string\",\n                    \"dataSourceSpecBinding\": {\n                      \"settlementDataProperty\": \"string\",\n                      \"settlementScheduleProperty\": \"string\"\n                    },\n                    \"dataSourceSpecForSettlementData\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"dataSourceSpecForSettlementSchedule\": {\n                      \"external\": {\n                        \"ethOracle\": {\n                          \"abi\": \"string\",\n                          \"address\": \"string\",\n                          \"args\": [\n                            {}\n                          ],\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"method\": \"string\",\n                          \"normalisers\": [\n                            {\n                              \"expression\": \"string\",\n                              \"name\": \"string\"\n                            }\n                          ],\n                          \"requiredConfirmations\": \"string\",\n                          \"trigger\": {\n                            \"timeTrigger\": {\n                              \"every\": \"string\",\n                              \"initial\": \"string\",\n                              \"until\": \"string\"\n                            }\n                          }\n                        },\n                        \"oracle\": {\n                          \"filters\": [\n                            {\n                              \"conditions\": [\n                                {\n                                  \"operator\": \"OPERATOR_UNSPECIFIED\",\n                                  \"value\": \"string\"\n                                }\n                              ],\n                              \"key\": {\n                                \"name\": \"string\",\n                                \"numberDecimalPlaces\": \"string\",\n                                \"type\": \"TYPE_UNSPECIFIED\"\n                              }\n                            }\n                          ],\n                          \"signers\": [\n                            {\n                              \"ethAddress\": {\n                                \"address\": \"string\"\n                              },\n                              \"pubKey\": {\n                                \"key\": \"string\"\n                              }\n                            }\n                          ]\n                        }\n                      },\n                      \"internal\": {\n                        \"time\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        },\n                        \"timeTrigger\": {\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ],\n                          \"triggers\": [\n                            {\n                              \"every\": \"string\",\n                              \"initial\": \"string\"\n                            }\n                          ]\n                        }\n                      }\n                    },\n                    \"interestRate\": \"string\",\n                    \"marginFundingFactor\": \"string\",\n                    \"quoteName\": \"string\"\n                  }\n                },\n                \"linearSlippageFactor\": \"string\",\n                \"liquidityMonitoringParameters\": {\n                  \"auctionExtension\": \"string\",\n                  \"targetStakeParameters\": {\n                    \"scalingFactor\": 0,\n                    \"timeWindow\": \"string\"\n                  },\n                  \"triggeringRatio\": \"string\"\n                },\n                \"liquiditySlaParameters\": {\n                  \"commitmentMinTimeFraction\": \"string\",\n                  \"performanceHysteresisEpochs\": \"string\",\n                  \"priceRange\": \"string\",\n                  \"slaCompetitionFactor\": \"string\"\n                },\n                \"logNormal\": {\n                  \"params\": {\n                    \"mu\": 0,\n                    \"r\": 0,\n                    \"sigma\": 0\n                  },\n                  \"riskAversionParameter\": 0,\n                  \"tau\": 0\n                },\n                \"lpPriceRange\": \"string\",\n                \"metadata\": [\n                  \"string\"\n                ],\n                \"priceMonitoringParameters\": {\n                  \"triggers\": [\n                    {\n                      \"auctionExtension\": \"string\",\n                      \"horizon\": \"string\",\n                      \"probability\": \"string\"\n                    }\n                  ]\n                },\n                \"quadraticSlippageFactor\": \"string\",\n                \"simple\": {\n                  \"factorLong\": 0,\n                  \"factorShort\": 0,\n                  \"maxMoveUp\": 0,\n                  \"minMoveDown\": 0,\n                  \"probabilityOfTrading\": 0\n                }\n              },\n              \"marketId\": \"string\"\n            },\n            \"updateMarketState\": {\n              \"changes\": {\n                \"marketId\": \"string\",\n                \"price\": \"string\",\n                \"updateType\": \"MARKET_STATE_UPDATE_TYPE_UNSPECIFIED\"\n              }\n            },\n            \"updateNetworkParameter\": {\n              \"changes\": {\n                \"key\": \"string\",\n                \"value\": \"string\"\n              }\n            },\n            \"updateReferralProgram\": {\n              \"changes\": {\n                \"benefitTiers\": [\n                  {\n                    \"minimumEpochs\": \"string\",\n                    \"minimumRunningNotionalTakerVolume\": \"string\",\n                    \"referralDiscountFactor\": \"string\",\n                    \"referralRewardFactor\": \"string\"\n                  }\n                ],\n                \"endOfProgramTimestamp\": \"string\",\n                \"stakingTiers\": [\n                  {\n                    \"minimumStakedTokens\": \"string\",\n                    \"referralRewardMultiplier\": \"string\"\n                  }\n                ],\n                \"windowLength\": \"string\"\n              }\n            },\n            \"updateSpotMarket\": {\n              \"changes\": {\n                \"logNormal\": {\n                  \"params\": {\n                    \"mu\": 0,\n                    \"r\": 0,\n                    \"sigma\": 0\n                  },\n                  \"riskAversionParameter\": 0,\n                  \"tau\": 0\n                },\n                \"metadata\": [\n                  \"string\"\n                ],\n                \"priceMonitoringParameters\": {\n                  \"triggers\": [\n                    {\n                      \"auctionExtension\": \"string\",\n                      \"horizon\": \"string\",\n                      \"probability\": \"string\"\n                    }\n                  ]\n                },\n                \"simple\": {\n                  \"factorLong\": 0,\n                  \"factorShort\": 0,\n                  \"maxMoveUp\": 0,\n                  \"minMoveDown\": 0,\n                  \"probabilityOfTrading\": 0\n                },\n                \"slaParams\": {\n                  \"commitmentMinTimeFraction\": \"string\",\n                  \"performanceHysteresisEpochs\": \"string\",\n                  \"priceRange\": \"string\",\n                  \"slaCompetitionFactor\": \"string\"\n                },\n                \"targetStakeParameters\": {\n                  \"scalingFactor\": 0,\n                  \"timeWindow\": \"string\"\n                }\n              },\n              \"marketId\": \"string\"\n            },\n            \"updateVolumeDiscountProgram\": {\n              \"changes\": {\n                \"benefitTiers\": [\n                  {\n                    \"minimumRunningNotionalTakerVolume\": \"string\",\n                    \"volumeDiscountFactor\": \"string\"\n                  }\n                ],\n                \"endOfProgramTimestamp\": \"string\",\n                \"windowLength\": \"string\"\n              }\n            },\n            \"validationTimestamp\": \"string\"\n          }\n        },\n        \"protocolUpgradeProposal\": {\n          \"upgradeBlockHeight\": \"string\",\n          \"vegaReleaseTag\": \"string\"\n        },\n        \"stateVariableProposal\": {\n          \"proposal\": {\n            \"eventId\": \"string\",\n            \"kvb\": [\n              {\n                \"key\": \"string\",\n                \"tolerance\": \"string\",\n                \"value\": {\n                  \"matrixVal\": {\n                    \"value\": [\n                      {\n                        \"value\": [\n                          \"string\"\n                        ]\n                      }\n                    ]\n                  },\n                  \"scalarVal\": {\n                    \"value\": \"string\"\n                  },\n                  \"vectorVal\": {\n                    \"value\": [\n                      \"string\"\n                    ]\n                  }\n                }\n              }\n            ],\n            \"stateVarId\": \"string\"\n          }\n        },\n        \"stopOrdersCancellation\": {\n          \"marketId\": \"string\",\n          \"stopOrderId\": \"string\"\n        },\n        \"stopOrdersSubmission\": {\n          \"fallsBelow\": {\n            \"expiresAt\": \"string\",\n            \"expiryStrategy\": \"EXPIRY_STRATEGY_UNSPECIFIED\",\n            \"orderSubmission\": {\n              \"expiresAt\": \"string\",\n              \"icebergOpts\": {\n                \"minimumVisibleSize\": \"string\",\n                \"peakSize\": \"string\"\n              },\n              \"marketId\": \"string\",\n              \"peggedOrder\": {\n                \"offset\": \"string\",\n                \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\"\n              },\n              \"postOnly\": true,\n              \"price\": \"string\",\n              \"reduceOnly\": true,\n              \"reference\": \"string\",\n              \"side\": \"SIDE_UNSPECIFIED\",\n              \"size\": \"string\",\n              \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n              \"type\": \"TYPE_UNSPECIFIED\"\n            },\n            \"price\": \"string\",\n            \"trailingPercentOffset\": \"string\"\n          },\n          \"risesAbove\": {\n            \"expiresAt\": \"string\",\n            \"expiryStrategy\": \"EXPIRY_STRATEGY_UNSPECIFIED\",\n            \"orderSubmission\": {\n              \"expiresAt\": \"string\",\n              \"icebergOpts\": {\n                \"minimumVisibleSize\": \"string\",\n                \"peakSize\": \"string\"\n              },\n              \"marketId\": \"string\",\n              \"peggedOrder\": {\n                \"offset\": \"string\",\n                \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\"\n              },\n              \"postOnly\": true,\n              \"price\": \"string\",\n              \"reduceOnly\": true,\n              \"reference\": \"string\",\n              \"side\": \"SIDE_UNSPECIFIED\",\n              \"size\": \"string\",\n              \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n              \"type\": \"TYPE_UNSPECIFIED\"\n            },\n            \"price\": \"string\",\n            \"trailingPercentOffset\": \"string\"\n          }\n        },\n        \"transfer\": {\n          \"amount\": \"string\",\n          \"asset\": \"string\",\n          \"fromAccountType\": \"ACCOUNT_TYPE_UNSPECIFIED\",\n          \"oneOff\": {\n            \"deliverOn\": \"string\"\n          },\n          \"recurring\": {\n            \"dispatchStrategy\": {\n              \"assetForMetric\": \"string\",\n              \"distributionStrategy\": \"DISTRIBUTION_STRATEGY_UNSPECIFIED\",\n              \"entityScope\": \"ENTITY_SCOPE_UNSPECIFIED\",\n              \"individualScope\": \"INDIVIDUAL_SCOPE_UNSPECIFIED\",\n              \"lockPeriod\": \"string\",\n              \"markets\": [\n                \"string\"\n              ],\n              \"metric\": \"DISPATCH_METRIC_UNSPECIFIED\",\n              \"nTopPerformers\": \"string\",\n              \"notionalTimeWeightedAveragePositionRequirement\": \"string\",\n              \"rankTable\": [\n                {\n                  \"shareRatio\": 0,\n                  \"startRank\": 0\n                }\n              ],\n              \"stakingRequirement\": \"string\",\n              \"teamScope\": [\n                \"string\"\n              ],\n              \"windowLength\": \"string\"\n            },\n            \"endEpoch\": \"string\",\n            \"factor\": \"string\",\n            \"startEpoch\": \"string\"\n          },\n          \"reference\": \"string\",\n          \"to\": \"string\",\n          \"toAccountType\": \"ACCOUNT_TYPE_UNSPECIFIED\"\n        },\n        \"undelegateSubmission\": {\n          \"amount\": \"string\",\n          \"method\": \"METHOD_UNSPECIFIED\",\n          \"nodeId\": \"string\"\n        },\n        \"updateReferralSet\": {\n          \"id\": \"string\",\n          \"isTeam\": true,\n          \"team\": {\n            \"avatarUrl\": \"string\",\n            \"closed\": true,\n            \"name\": \"string\",\n            \"teamUrl\": \"string\"\n          }\n        },\n        \"validatorHeartbeat\": {\n          \"ethereumSignature\": {\n            \"algo\": \"string\",\n            \"value\": \"string\",\n            \"version\": 0\n          },\n          \"message\": \"string\",\n          \"nodeId\": \"string\",\n          \"vegaSignature\": {\n            \"algo\": \"string\",\n            \"value\": \"string\",\n            \"version\": 0\n          }\n        },\n        \"voteSubmission\": {\n          \"proposalId\": \"string\",\n          \"value\": \"VALUE_UNSPECIFIED\"\n        },\n        \"withdrawSubmission\": {\n          \"amount\": \"string\",\n          \"asset\": \"string\",\n          \"ext\": {\n            \"erc20\": {\n              \"receiverAddress\": \"string\"\n            }\n          }\n        }\n      },\n      \"createdAt\": \"string\",\n      \"cursor\": \"string\",\n      \"error\": \"string\",\n      \"hash\": \"string\",\n      \"index\": 0,\n      \"pow\": {\n        \"nonce\": \"string\",\n        \"tid\": \"string\"\n      },\n      \"signature\": {\n        \"algo\": \"string\",\n        \"value\": \"string\",\n        \"version\": 0\n      },\n      \"submitter\": \"string\",\n      \"type\": \"string\",\n      \"version\": \"TX_VERSION_UNSPECIFIED\"\n    }\n  ]\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"default"} value={"default"}><div>

An unexpected error response.

</div><div><MimeTabs schemaType={"response"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"code"} required={false} schemaName={"int32"} qualifierMessage={undefined} schema={{"format":"int32","type":"integer"}}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>details</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem","paddingBottom":".5rem"}}>Array [</div></li><SchemaItem collapsible={false} name={"@type"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem><li><div style={{"fontSize":"var(--ifm-code-font-size)","opacity":"0.6","marginLeft":"-.5rem"}}>]</div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"message"} required={false} schemaName={"string"} qualifierMessage={undefined} schema={{"type":"string"}}></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"code\": 0,\n  \"details\": [\n    {\n      \"@type\": \"string\"\n    }\n  ],\n  \"message\": \"string\"\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem></ApiTabs></div>
