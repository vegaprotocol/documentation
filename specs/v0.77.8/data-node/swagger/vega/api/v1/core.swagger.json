{
  "swagger": "2.0",
  "info": {
    "title": "Vega core APIs",
    "version": "v0.78.0-dev"
  },
  "tags": [
    {
      "name": "CoreService"
    }
  ],
  "host": "lb.testnet.vega.xyz",
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "AMMCurve": {
      "type": "object",
      "properties": {
        "virtualLiquidity": {
          "type": "string",
          "description": "Virtual liquidity for the given AMM curve."
        },
        "theoreticalPosition": {
          "type": "string",
          "description": "Maximum tradable volume on the AMM curve."
        }
      }
    },
    "AMMStatusReason": {
      "type": "string",
      "enum": [
        "STATUS_REASON_UNSPECIFIED",
        "STATUS_REASON_CANCELLED_BY_PARTY",
        "STATUS_REASON_CANNOT_FILL_COMMITMENT",
        "STATUS_REASON_PARTY_ALREADY_OWNS_AMM_FOR_MARKET",
        "STATUS_REASON_PARTY_CLOSED_OUT",
        "STATUS_REASON_MARKET_CLOSED",
        "STATUS_REASON_COMMITMENT_TOO_LOW",
        "STATUS_REASON_CANNOT_REBASE"
      ],
      "default": "STATUS_REASON_UNSPECIFIED",
      "description": " - STATUS_REASON_CANCELLED_BY_PARTY: AMM was cancelled by its owner.\n - STATUS_REASON_CANNOT_FILL_COMMITMENT: Party does not have enough funds in their general account to meet the AMM's commitment.\n - STATUS_REASON_PARTY_ALREADY_OWNS_AMM_FOR_MARKET: Party already has an AMM operating on this market and cannot create another one.\n - STATUS_REASON_PARTY_CLOSED_OUT: AMM was liquidated and stopped by the network.\n - STATUS_REASON_MARKET_CLOSED: AMM was stopped by the network because the market it operated in was closed.\n - STATUS_REASON_COMMITMENT_TOO_LOW: Commitment amount was below the network wide minimum, or its price bounds are too wide, such that the volume is spread thinly creating zero-volume price-levels.\n - STATUS_REASON_CANNOT_REBASE: AMM was unable to rebase its fair-price such that it does not cross with existing orders."
    },
    "ConditionOperator": {
      "type": "string",
      "enum": [
        "OPERATOR_UNSPECIFIED",
        "OPERATOR_EQUALS",
        "OPERATOR_GREATER_THAN",
        "OPERATOR_GREATER_THAN_OR_EQUAL",
        "OPERATOR_LESS_THAN",
        "OPERATOR_LESS_THAN_OR_EQUAL"
      ],
      "default": "OPERATOR_UNSPECIFIED",
      "description": "Operator describes the type of comparison.\n\n - OPERATOR_UNSPECIFIED: The default value\n - OPERATOR_EQUALS: Verify if the property values are strictly equal or not.\n - OPERATOR_GREATER_THAN: Verify if the data source data value is greater than the Condition value.\n - OPERATOR_GREATER_THAN_OR_EQUAL: Verify if the data source data value is greater than or equal to the Condition\nvalue.\n - OPERATOR_LESS_THAN: Verify if the data source data value is less than the Condition value.\n - OPERATOR_LESS_THAN_OR_EQUAL: Verify if the data source data value is less or equal to than the Condition\nvalue."
    },
    "FundingPeriodDataPointSource": {
      "type": "string",
      "enum": [
        "SOURCE_UNSPECIFIED",
        "SOURCE_EXTERNAL",
        "SOURCE_INTERNAL"
      ],
      "default": "SOURCE_UNSPECIFIED",
      "description": " - SOURCE_UNSPECIFIED: Default value\n - SOURCE_EXTERNAL: Data point is from an external data source, such as an oracle, and represents the spot price of the underlying asset.\n - SOURCE_INTERNAL: Data point from within Vega such as the mark price after performing mark-to-market."
    },
    "MarketTradingMode": {
      "type": "string",
      "enum": [
        "TRADING_MODE_UNSPECIFIED",
        "TRADING_MODE_CONTINUOUS",
        "TRADING_MODE_BATCH_AUCTION",
        "TRADING_MODE_OPENING_AUCTION",
        "TRADING_MODE_MONITORING_AUCTION",
        "TRADING_MODE_NO_TRADING",
        "TRADING_MODE_SUSPENDED_VIA_GOVERNANCE",
        "TRADING_MODE_LONG_BLOCK_AUCTION"
      ],
      "default": "TRADING_MODE_UNSPECIFIED",
      "description": "- TRADING_MODE_UNSPECIFIED: Default value, this is invalid\n - TRADING_MODE_CONTINUOUS: Normal trading\n - TRADING_MODE_BATCH_AUCTION: Auction trading (FBA)\n - TRADING_MODE_OPENING_AUCTION: Opening auction\n - TRADING_MODE_MONITORING_AUCTION: Auction triggered by monitoring\n - TRADING_MODE_NO_TRADING: No trading is allowed\n - TRADING_MODE_SUSPENDED_VIA_GOVERNANCE: Special auction mode triggered via governance\n - TRADING_MODE_LONG_BLOCK_AUCTION: Auction triggered globally by long block",
      "title": "Trading mode the market is currently running, also referred to as 'market state'"
    },
    "OracleDataSubmissionOracleSource": {
      "type": "string",
      "enum": [
        "ORACLE_SOURCE_UNSPECIFIED",
        "ORACLE_SOURCE_OPEN_ORACLE",
        "ORACLE_SOURCE_JSON",
        "ORACLE_SOURCE_ETHEREUM"
      ],
      "default": "ORACLE_SOURCE_UNSPECIFIED",
      "description": "- ORACLE_SOURCE_UNSPECIFIED: Default value\n - ORACLE_SOURCE_OPEN_ORACLE: Specifies that the payload will be base64 encoded JSON conforming to the Open Oracle standard.\n - ORACLE_SOURCE_JSON: Specifies that the payload will be base64 encoded JSON, but does not specify the shape of the data.\n - ORACLE_SOURCE_ETHEREUM: Specifies that the payload will be base64 encoded JSON conforming to the ETH standard.",
      "title": "Supported oracle sources"
    },
    "OrderTimeInForce": {
      "type": "string",
      "enum": [
        "TIME_IN_FORCE_UNSPECIFIED",
        "TIME_IN_FORCE_GTC",
        "TIME_IN_FORCE_GTT",
        "TIME_IN_FORCE_IOC",
        "TIME_IN_FORCE_FOK",
        "TIME_IN_FORCE_GFA",
        "TIME_IN_FORCE_GFN"
      ],
      "default": "TIME_IN_FORCE_UNSPECIFIED",
      "description": "- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible\nand remains on the book until it either trades completely or is cancelled\n - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible\nand remains on the book until it either trades completely, is cancelled, or expires at a set time\nNOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry\n - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible\nbut does not remain on the book (whether it trades or not)\n - TIME_IN_FORCE_FOK: Fill or kill, the order either trades completely i.e. remainingSize == 0 after adding,\nor not at all, and does not remain on the book if it doesn't trade\n - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period\n - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)",
      "title": "Time In Force for an order"
    },
    "StopOrderExpiryStrategy": {
      "type": "string",
      "enum": [
        "EXPIRY_STRATEGY_UNSPECIFIED",
        "EXPIRY_STRATEGY_CANCELS",
        "EXPIRY_STRATEGY_SUBMIT"
      ],
      "default": "EXPIRY_STRATEGY_UNSPECIFIED",
      "description": " - EXPIRY_STRATEGY_UNSPECIFIED: Never valid\n - EXPIRY_STRATEGY_CANCELS: Stop order should be cancelled if the expiry time is reached.\n - EXPIRY_STRATEGY_SUBMIT: Order should be submitted if the expiry time is reached."
    },
    "StopOrderRejectionReason": {
      "type": "string",
      "enum": [
        "REJECTION_REASON_UNSPECIFIED",
        "REJECTION_REASON_TRADING_NOT_ALLOWED",
        "REJECTION_REASON_EXPIRY_IN_THE_PAST",
        "REJECTION_REASON_MUST_BE_REDUCE_ONLY",
        "REJECTION_REASON_MAX_STOP_ORDERS_PER_PARTY_REACHED",
        "REJECTION_REASON_STOP_ORDER_NOT_ALLOWED_WITHOUT_A_POSITION",
        "REJECTION_REASON_STOP_ORDER_NOT_CLOSING_THE_POSITION",
        "REJECTION_REASON_STOP_ORDER_LINKED_PERCENTAGE_INVALID",
        "REJECTION_REASON_STOP_ORDER_NOT_ALLOWED_DURING_OPENING_AUCTION",
        "REJECTION_REASON_STOP_ORDER_CANNOT_MATCH_OCO_EXPIRY_TIMES",
        "REJECTION_REASON_STOP_ORDER_SIZE_OVERRIDE_UNSUPPORTED_FOR_SPOT"
      ],
      "default": "REJECTION_REASON_UNSPECIFIED",
      "title": "- REJECTION_REASON_UNSPECIFIED: Never valid\n - REJECTION_REASON_TRADING_NOT_ALLOWED: Trading is not allowed yet\n - REJECTION_REASON_EXPIRY_IN_THE_PAST: Expiry of the stop order is in the past\n - REJECTION_REASON_MUST_BE_REDUCE_ONLY: Stop orders submission must be reduce only\n - REJECTION_REASON_MAX_STOP_ORDERS_PER_PARTY_REACHED: Party has reached the maximum stop orders allowed for this market\n - REJECTION_REASON_STOP_ORDER_NOT_ALLOWED_WITHOUT_A_POSITION: Stop orders are not allowed if there is no open position\n - REJECTION_REASON_STOP_ORDER_NOT_CLOSING_THE_POSITION: This stop order does not close the position\n - REJECTION_REASON_STOP_ORDER_LINKED_PERCENTAGE_INVALID: The percentage value for the linked stop order is invalid\n - REJECTION_REASON_STOP_ORDER_NOT_ALLOWED_DURING_OPENING_AUCTION: Stop orders are not allowed during the opening auction\n - REJECTION_REASON_STOP_ORDER_CANNOT_MATCH_OCO_EXPIRY_TIMES: Stop OCO orders cannot have the same expiry timestamp\n - REJECTION_REASON_STOP_ORDER_SIZE_OVERRIDE_UNSUPPORTED_FOR_SPOT: Stop orders with a position size override are not supported for spot markets"
    },
    "StopOrderSizeOverrideSetting": {
      "type": "string",
      "enum": [
        "SIZE_OVERRIDE_SETTING_UNSPECIFIED",
        "SIZE_OVERRIDE_SETTING_NONE",
        "SIZE_OVERRIDE_SETTING_POSITION"
      ],
      "default": "SIZE_OVERRIDE_SETTING_UNSPECIFIED",
      "title": "- SIZE_OVERRIDE_SETTING_UNSPECIFIED: Never valid\n - SIZE_OVERRIDE_SETTING_NONE: No override, the size within the contained normal order submission will be used\n - SIZE_OVERRIDE_SETTING_POSITION: Use the total position of the trader"
    },
    "StopOrderSizeOverrideValue": {
      "type": "object",
      "properties": {
        "percentage": {
          "type": "string",
          "title": "Scaling percentage of the current positionâ€™s size"
        }
      }
    },
    "StopOrderTriggerDirection": {
      "type": "string",
      "enum": [
        "TRIGGER_DIRECTION_UNSPECIFIED",
        "TRIGGER_DIRECTION_RISES_ABOVE",
        "TRIGGER_DIRECTION_FALLS_BELOW"
      ],
      "default": "TRIGGER_DIRECTION_UNSPECIFIED",
      "title": "- TRIGGER_DIRECTION_UNSPECIFIED: Never valid\n - TRIGGER_DIRECTION_RISES_ABOVE: Stop order is triggered once the price rises above a certain level\n - TRIGGER_DIRECTION_FALLS_BELOW: Stop order is triggered once the price falls below a certain level"
    },
    "TransactionResultFailureDetails": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string",
          "title": "Error message explaining the reason for the transaction failing processing"
        },
        "errors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TransactionResultKeyErrors"
          },
          "description": "Map of the detailed errors, if any."
        }
      }
    },
    "TransactionResultKeyErrors": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "The key."
        },
        "errors": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The errors mapped to this key."
        }
      },
      "description": "A mapping of a key to a list of errors."
    },
    "TransactionResultSuccessDetails": {
      "type": "object"
    },
    "UpdateMarginModeMode": {
      "type": "string",
      "enum": [
        "MODE_UNSPECIFIED",
        "MODE_CROSS_MARGIN",
        "MODE_ISOLATED_MARGIN"
      ],
      "default": "MODE_UNSPECIFIED",
      "title": "- MODE_UNSPECIFIED: Never valid.\n - MODE_CROSS_MARGIN: Cross margin mode - margin is dynamically acquired and released as a position is marked to market\n - MODE_ISOLATED_MARGIN: Isolated margin mode - margin for any newly opened position volume is transferred to the margin account when the trade is executed"
    },
    "commandsv1CancelTransfer": {
      "type": "object",
      "properties": {
        "transferId": {
          "type": "string",
          "description": "Transfer ID of the transfer to cancel."
        }
      },
      "description": "Command that can be used by the party that initiated a transfer to instruct the network to stop an active recurring transaction."
    },
    "googlerpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "protobufNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\n The JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value."
    },
    "v1AMM": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "ID of the AMM."
        },
        "partyId": {
          "type": "string",
          "description": "Party ID of the owner of the AMM."
        },
        "marketId": {
          "type": "string",
          "description": "Market ID that the AMM provides liquidity for."
        },
        "ammPartyId": {
          "type": "string",
          "description": "Party ID that the AMM operates as."
        },
        "commitment": {
          "type": "string",
          "description": "Amount committed to the AMM."
        },
        "parameters": {
          "$ref": "#/definitions/v1AMMConcentratedLiquidityParameters",
          "description": "Liquidity parameters that define the size and range of the AMM's tradeable volume."
        },
        "status": {
          "$ref": "#/definitions/v1AMMStatus",
          "description": "Current status of the AMM."
        },
        "statusReason": {
          "$ref": "#/definitions/AMMStatusReason",
          "description": "Reason for the AMM's current status."
        },
        "proposedFee": {
          "type": "string",
          "description": "Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market."
        },
        "lowerCurve": {
          "$ref": "#/definitions/AMMCurve"
        },
        "upperCurve": {
          "$ref": "#/definitions/AMMCurve"
        }
      }
    },
    "v1AMMConcentratedLiquidityParameters": {
      "type": "object",
      "properties": {
        "base": {
          "type": "string",
          "description": "Base price bound configuration for the AMM."
        },
        "lowerBound": {
          "type": "string",
          "description": "Upper price bound configuration for the AMM. If unset, the AMM will never hold a short position."
        },
        "upperBound": {
          "type": "string",
          "description": "Lower price bound configuration for the AMM. If unset, the AMM will never hold a long position."
        },
        "leverageAtUpperBound": {
          "type": "string",
          "description": "Leverage at upper bounds."
        },
        "leverageAtLowerBound": {
          "type": "string",
          "description": "Leverage at lower bounds."
        }
      },
      "description": "Liquidity parameters that define the range and shape of the AMM's curve."
    },
    "v1AMMStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_ACTIVE",
        "STATUS_REJECTED",
        "STATUS_CANCELLED",
        "STATUS_STOPPED",
        "STATUS_REDUCE_ONLY"
      ],
      "default": "STATUS_UNSPECIFIED",
      "description": " - STATUS_ACTIVE: AMM is active on the market and is posting tradable volume.\n - STATUS_REJECTED: AMM submission was rejected.\n - STATUS_CANCELLED: AMM has been cancelled by the owner and is no longer trading.\n - STATUS_STOPPED: AMM has been stopped by the network and is no longer trading.\n - STATUS_REDUCE_ONLY: AMM will only trade such that it will reduce its position."
    },
    "v1AmendAMM": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market ID for the AMM to be amended."
        },
        "commitmentAmount": {
          "type": "string",
          "description": "Amount to be committed to the AMM. If not supplied the commitment will remain unchanged."
        },
        "slippageTolerance": {
          "type": "string",
          "description": "Slippage tolerance for rebasing position when updating the AMM."
        },
        "concentratedLiquidityParameters": {
          "$ref": "#/definitions/v1AmendAMMConcentratedLiquidityParameters",
          "description": "Concentrated liquidity parameters defining the shape of the AMM's volume curves. If not supplied the parameters will remain unchanged."
        },
        "proposedFee": {
          "type": "string",
          "description": "Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market. If not supplied the proposed fee will remain unchanged."
        }
      },
      "description": "Command to amend an existing automated market maker on a market."
    },
    "v1AmendAMMConcentratedLiquidityParameters": {
      "type": "object",
      "properties": {
        "upperBound": {
          "type": "string",
          "description": "Price at which the AMM will stop quoting sell volume. If not supplied the AMM will never hold a short position."
        },
        "lowerBound": {
          "type": "string",
          "description": "Price at which the AMM will stop quoting buy volume. If not supplied the AMM will never hold a long position."
        },
        "base": {
          "type": "string",
          "description": "Price that the AMM will quote as its \"fair price\" when its position is zero."
        },
        "leverageAtUpperBound": {
          "type": "string",
          "description": "Leverage at upper bound. If not set the markets risk-factors will be used to calculate leverage."
        },
        "leverageAtLowerBound": {
          "type": "string",
          "description": "Leverage at lower bound. If not set the markets risk-factors will be used to calculate leverage."
        }
      },
      "description": "Liquidity parameters that define the size and range of the AMM's tradeable volume."
    },
    "v1AnnounceNode": {
      "type": "object",
      "properties": {
        "vegaPubKey": {
          "type": "string",
          "description": "Vega public key of the node being announced."
        },
        "ethereumAddress": {
          "type": "string",
          "description": "Ethereum public key of the node being announced."
        },
        "chainPubKey": {
          "type": "string",
          "description": "Public key for the blockchain, currently the node's CometBFT key."
        },
        "infoUrl": {
          "type": "string",
          "description": "URL to the node operators homepage allowing stake holders to make an informed decision when delegating."
        },
        "country": {
          "type": "string",
          "description": "Country code (ISO 3166-1 alpha-2) for the location of the node."
        },
        "id": {
          "type": "string",
          "description": "Node ID of the validator, which is the node's public master key."
        },
        "name": {
          "type": "string",
          "description": "Human-readable name of the node."
        },
        "avatarUrl": {
          "type": "string",
          "description": "URL to the node operator's avatar."
        },
        "vegaPubKeyIndex": {
          "type": "integer",
          "format": "int64",
          "description": "Vega public key derivation index."
        },
        "fromEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch from which the node is expected to be ready to validate blocks."
        },
        "ethereumSignature": {
          "$ref": "#/definitions/v1Signature",
          "description": "Signature from the node made using the ethereum wallet."
        },
        "vegaSignature": {
          "$ref": "#/definitions/v1Signature",
          "description": "Signature from the node made using the Vega wallet."
        },
        "submitterAddress": {
          "type": "string",
          "description": "Ethereum public key to use as a submitter to allow automatic signature generation."
        }
      },
      "description": "A command that allows a new node operator to announce themselves to the network as a new validator."
    },
    "v1ApplyReferralCode": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Referral code, normally the referral set ID, for the party to join."
        }
      },
      "description": "Command that allows the submitter to join a referral set and earn a collective reduction in fees based on the activity of all members of that set.\nA party that joins a referral set is called a referee. A referee can only be a member of one referral set and cannot themselves be or become a referrer.\nTo switch to another referral set, a subsequent command can be sent and the switch will take effect at the end of the epoch."
    },
    "v1AuctionEvent": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "openingAuction": {
          "type": "boolean",
          "title": "True if the event indicates an auction opening and False otherwise"
        },
        "leave": {
          "type": "boolean",
          "title": "True if the event indicates leaving auction mode and False otherwise"
        },
        "start": {
          "type": "string",
          "format": "int64",
          "title": "Timestamp containing the start time for an auction"
        },
        "end": {
          "type": "string",
          "format": "int64",
          "title": "Timestamp containing the end time for an auction"
        },
        "trigger": {
          "$ref": "#/definitions/vegaAuctionTrigger",
          "title": "Reason this market is/was in auction"
        },
        "extensionTrigger": {
          "$ref": "#/definitions/vegaAuctionTrigger",
          "title": "If an auction was ongoing, but was extended for whatever reason, this field will\nbe set to the trigger type indicating which component extended the auction"
        }
      },
      "title": "Auction event indicating a change in auction state, for example starting or ending an auction"
    },
    "v1BatchMarketInstructions": {
      "type": "object",
      "properties": {
        "cancellations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1OrderCancellation"
          },
          "description": "List of order cancellations to be processed sequentially."
        },
        "amendments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1OrderAmendment"
          },
          "description": "List of order amendments to be processed sequentially."
        },
        "submissions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1OrderSubmission"
          },
          "description": "List of order submissions to be processed sequentially."
        },
        "stopOrdersCancellation": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1StopOrdersCancellation"
          },
          "description": "List of stop order cancellations to be processed sequentially."
        },
        "stopOrdersSubmission": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1StopOrdersSubmission"
          },
          "description": "List of stop order submissions to be processed sequentially."
        },
        "updateMarginMode": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1UpdateMarginMode"
          },
          "title": "Update margin mode instruction"
        }
      },
      "description": "A command that allows the submission of a batch market instruction which wraps up multiple market instructions into a single transaction.\nThese instructions are then processed sequentially in the following order:\n- OrderCancellation\n- OrderAmendment\n- OrderSubmission\n- StopOrderSubmission\nwhere the maximum allow of instructions in a batch is controlled by the network parameter \"spam.protection.max.batchSize\"."
    },
    "v1BatchProposalSubmission": {
      "type": "object",
      "properties": {
        "reference": {
          "type": "string",
          "description": "Arbitrary human-readable reference identifying the proposal."
        },
        "terms": {
          "$ref": "#/definitions/v1BatchProposalSubmissionTerms",
          "description": "Proposal terms containing the type and details of the proposal, as well as time spans for voting and enactment."
        },
        "rationale": {
          "$ref": "#/definitions/vegaProposalRationale",
          "description": "Rationale behind a proposal."
        }
      },
      "description": "Command that allows a token holder to submit a batch governance proposal that can be voted on by any other token holders, and eventually enacted on the Vega network.\nFor example this command can be used to propose a new market and a network parameter change with it."
    },
    "v1BatchProposalSubmissionTerms": {
      "type": "object",
      "properties": {
        "closingTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Closing timestamp in Unix time; adheres to `minClose` and `maxClose` limits."
        },
        "changes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaBatchProposalTermsChange"
          },
          "description": "List of individual changes included in the batch proposal."
        }
      },
      "title": "Terms for a batch governance proposal submission"
    },
    "v1BeginBlock": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "uint64"
        },
        "timestamp": {
          "type": "string",
          "format": "int64"
        },
        "hash": {
          "type": "string"
        }
      },
      "title": "BeginBlock"
    },
    "v1BusEvent": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "title": "Unique event ID for the message"
        },
        "block": {
          "type": "string",
          "title": "The batch or block of transactions that the events relate to"
        },
        "type": {
          "$ref": "#/definitions/v1BusEventType",
          "title": "The type of bus event. Must be one of the list below:"
        },
        "timeUpdate": {
          "$ref": "#/definitions/v1TimeUpdate",
          "title": "Time update events"
        },
        "ledgerMovements": {
          "$ref": "#/definitions/v1LedgerMovements",
          "title": "Transfer responses update events"
        },
        "positionResolution": {
          "$ref": "#/definitions/v1PositionResolution",
          "title": "Position resolution events"
        },
        "order": {
          "$ref": "#/definitions/vegaOrder",
          "title": "Order events"
        },
        "account": {
          "$ref": "#/definitions/vegaAccount",
          "title": "Account events"
        },
        "party": {
          "$ref": "#/definitions/vegaParty",
          "title": "Party events"
        },
        "trade": {
          "$ref": "#/definitions/vegaTrade",
          "title": "Trade events"
        },
        "marginLevels": {
          "$ref": "#/definitions/vegaMarginLevels",
          "title": "Margin level update events"
        },
        "proposal": {
          "$ref": "#/definitions/vegaProposal",
          "title": "Proposal events for governance"
        },
        "vote": {
          "$ref": "#/definitions/vegaVote",
          "title": "Vote events for governance"
        },
        "marketData": {
          "$ref": "#/definitions/vegaMarketData",
          "title": "Market data events"
        },
        "nodeSignature": {
          "$ref": "#/definitions/v1NodeSignature",
          "title": "Node signature events"
        },
        "lossSocialization": {
          "$ref": "#/definitions/v1LossSocialization",
          "title": "Loss socialization events"
        },
        "settlePosition": {
          "$ref": "#/definitions/v1SettlePosition",
          "title": "Position settlement events"
        },
        "settleDistressed": {
          "$ref": "#/definitions/v1SettleDistressed",
          "title": "Position distressed events"
        },
        "marketCreated": {
          "$ref": "#/definitions/vegaMarket",
          "title": "Market created events"
        },
        "asset": {
          "$ref": "#/definitions/vegaAsset",
          "title": "Asset events"
        },
        "marketTick": {
          "$ref": "#/definitions/v1MarketTick",
          "title": "Market tick events"
        },
        "withdrawal": {
          "$ref": "#/definitions/vegaWithdrawal",
          "title": "Withdrawal events"
        },
        "deposit": {
          "$ref": "#/definitions/vegaDeposit",
          "title": "Deposit events"
        },
        "auction": {
          "$ref": "#/definitions/v1AuctionEvent",
          "title": "Auction events"
        },
        "riskFactor": {
          "$ref": "#/definitions/vegaRiskFactor",
          "title": "Risk factor events"
        },
        "networkParameter": {
          "$ref": "#/definitions/vegaNetworkParameter",
          "title": "Network parameter events"
        },
        "liquidityProvision": {
          "$ref": "#/definitions/vegaLiquidityProvision",
          "title": "LiquidityProvision  events"
        },
        "marketUpdated": {
          "$ref": "#/definitions/vegaMarket",
          "title": "Market created events"
        },
        "oracleSpec": {
          "$ref": "#/definitions/vegaOracleSpec",
          "title": "OracleSpec events"
        },
        "oracleData": {
          "$ref": "#/definitions/vegaOracleData",
          "title": "OracleData events"
        },
        "delegationBalance": {
          "$ref": "#/definitions/v1DelegationBalanceEvent",
          "title": "Delegation balance events"
        },
        "validatorScore": {
          "$ref": "#/definitions/v1ValidatorScoreEvent",
          "title": "Validator score calculated"
        },
        "epochEvent": {
          "$ref": "#/definitions/v1EpochEvent",
          "title": "Epoch update events"
        },
        "validatorUpdate": {
          "$ref": "#/definitions/v1ValidatorUpdate",
          "title": "Validator update events"
        },
        "stakeLinking": {
          "$ref": "#/definitions/v1StakeLinking",
          "title": "Staking event"
        },
        "rewardPayout": {
          "$ref": "#/definitions/v1RewardPayoutEvent",
          "title": "Reward payout event"
        },
        "checkpoint": {
          "$ref": "#/definitions/v1CheckpointEvent",
          "title": "Checkpoint was created"
        },
        "keyRotation": {
          "$ref": "#/definitions/v1KeyRotation",
          "title": "Key rotation took place"
        },
        "stateVar": {
          "$ref": "#/definitions/v1StateVar",
          "title": "State variable consensus state transition update"
        },
        "networkLimits": {
          "$ref": "#/definitions/vegaNetworkLimits",
          "title": "Network limits events"
        },
        "transfer": {
          "$ref": "#/definitions/vegaeventsv1Transfer",
          "title": "Transfer event"
        },
        "rankingEvent": {
          "$ref": "#/definitions/v1ValidatorRankingEvent",
          "title": "Ranking event"
        },
        "erc20MultisigSignerEvent": {
          "$ref": "#/definitions/v1ERC20MultiSigSignerEvent",
          "title": "ERC20 multi sig signer event"
        },
        "erc20MultisigSetThresholdEvent": {
          "$ref": "#/definitions/v1ERC20MultiSigThresholdSetEvent",
          "title": "ERC20 multi sig set threshold event"
        },
        "erc20MultisigSignerAdded": {
          "$ref": "#/definitions/v1ERC20MultiSigSignerAdded",
          "title": "ERC20 multi sig signer added"
        },
        "erc20MultisigSignerRemoved": {
          "$ref": "#/definitions/v1ERC20MultiSigSignerRemoved",
          "title": "ERC20 multi sig signer removed"
        },
        "positionStateEvent": {
          "$ref": "#/definitions/v1PositionStateEvent",
          "title": "Position status for a party in a market"
        },
        "ethereumKeyRotation": {
          "$ref": "#/definitions/v1EthereumKeyRotation",
          "title": "Ethereum key rotation took place"
        },
        "protocolUpgradeEvent": {
          "$ref": "#/definitions/v1ProtocolUpgradeEvent",
          "title": "Protocol upgrade proposal updates"
        },
        "beginBlock": {
          "$ref": "#/definitions/v1BeginBlock",
          "title": "Core is starting to process a new block"
        },
        "endBlock": {
          "$ref": "#/definitions/v1EndBlock",
          "title": "Core finished processing a block"
        },
        "protocolUpgradeStarted": {
          "$ref": "#/definitions/v1ProtocolUpgradeStarted",
          "title": "Core is starting a protocol upgrade"
        },
        "settleMarket": {
          "$ref": "#/definitions/v1SettleMarket",
          "title": "Settle market event for data-node to update positions for settled markets"
        },
        "transactionResult": {
          "$ref": "#/definitions/v1TransactionResult",
          "title": "Result of a transaction processed by the network"
        },
        "coreSnapshotEvent": {
          "$ref": "#/definitions/v1CoreSnapshotData",
          "title": "Core snapshot has been taken at the end of the block"
        },
        "protocolUpgradeDataNodeReady": {
          "$ref": "#/definitions/v1ProtocolUpgradeDataNodeReady",
          "title": "Core snapshot has been taken at the end of the block"
        },
        "distressedOrders": {
          "$ref": "#/definitions/v1DistressedOrders",
          "title": "Parties that had their orders closed because they were distressed"
        },
        "expiredOrders": {
          "$ref": "#/definitions/v1ExpiredOrders",
          "title": "Orders that expired for a given market"
        },
        "distressedPositions": {
          "$ref": "#/definitions/v1DistressedPositions",
          "title": "Open positions on the market that are/were distressed"
        },
        "stopOrder": {
          "$ref": "#/definitions/v1StopOrderEvent",
          "title": "A stop order event"
        },
        "fundingPeriod": {
          "$ref": "#/definitions/v1FundingPeriod",
          "description": "Start or end of a funding period."
        },
        "fundingPeriodDataPoint": {
          "$ref": "#/definitions/v1FundingPeriodDataPoint",
          "description": "Data point within a funding period."
        },
        "teamCreated": {
          "$ref": "#/definitions/v1TeamCreated",
          "title": "Event notifying of the creation of a team.m"
        },
        "teamUpdated": {
          "$ref": "#/definitions/v1TeamUpdated",
          "description": "Event notifying of an update to a team."
        },
        "refereeSwitchedTeam": {
          "$ref": "#/definitions/v1RefereeSwitchedTeam",
          "description": "Event notifying that a referee switched teams."
        },
        "refereeJoinedTeam": {
          "$ref": "#/definitions/v1RefereeJoinedTeam",
          "description": "Event notifying that a referee joined a team."
        },
        "referralProgramStarted": {
          "$ref": "#/definitions/v1ReferralProgramStarted",
          "description": "Event notifying that a referral program has started."
        },
        "referralProgramUpdated": {
          "$ref": "#/definitions/v1ReferralProgramUpdated",
          "description": "Event notifying that a referral program has been updated."
        },
        "referralProgramEnded": {
          "$ref": "#/definitions/v1ReferralProgramEnded",
          "description": "Event notifying that a referral program has ended."
        },
        "referralSetCreated": {
          "$ref": "#/definitions/v1ReferralSetCreated",
          "description": "Event notifying a referral set has been created."
        },
        "refereeJoinedReferralSet": {
          "$ref": "#/definitions/v1RefereeJoinedReferralSet",
          "description": "Event notifying a referee has joined a referral set."
        },
        "partyActivityStreak": {
          "$ref": "#/definitions/v1PartyActivityStreak",
          "title": "Event notifying of an update to a party's activity streak"
        },
        "volumeDiscountProgramStarted": {
          "$ref": "#/definitions/v1VolumeDiscountProgramStarted",
          "description": "Event notifying that a volume discount program has started."
        },
        "volumeDiscountProgramUpdated": {
          "$ref": "#/definitions/v1VolumeDiscountProgramUpdated",
          "description": "Event notifying that a volume discount program has been updated."
        },
        "volumeDiscountProgramEnded": {
          "$ref": "#/definitions/v1VolumeDiscountProgramEnded",
          "description": "Event notifying that a volume discount program has ended."
        },
        "referralSetStatsUpdated": {
          "$ref": "#/definitions/v1ReferralSetStatsUpdated",
          "description": "Event notifying of an update to a referral set's statistics."
        },
        "vestingStatsUpdated": {
          "$ref": "#/definitions/v1VestingStatsUpdated",
          "description": "Event notifying of an update to the vesting statistics."
        },
        "volumeDiscountStatsUpdated": {
          "$ref": "#/definitions/v1VolumeDiscountStatsUpdated",
          "description": "Event notifying of an update to the volume discount statistics."
        },
        "feesStats": {
          "$ref": "#/definitions/v1FeesStats",
          "description": "Event notifying of an update the fees stats for a market."
        },
        "fundingPayments": {
          "$ref": "#/definitions/v1FundingPayments",
          "description": "Event notifying of funding payments at the end of a funding period."
        },
        "paidLiquidityFeesStats": {
          "$ref": "#/definitions/v1PaidLiquidityFeesStats",
          "description": "Event notifying of an update to the liqudity fees stats for a market."
        },
        "vestingBalancesSummary": {
          "$ref": "#/definitions/v1VestingBalancesSummary",
          "description": "Event notifying of an update to the vesting and locked balances."
        },
        "transferFees": {
          "$ref": "#/definitions/v1TransferFees",
          "description": "Event notifying of fees related to a transfer being paid."
        },
        "transferFeesDiscount": {
          "$ref": "#/definitions/v1TransferFeesDiscount",
          "description": "Event notifying of a party's available discounts for transfer fees, per asset."
        },
        "partyMarginModeUpdated": {
          "$ref": "#/definitions/v1PartyMarginModeUpdated",
          "description": "Event notifying of a party's margin mode update on a market."
        },
        "partyProfileUpdated": {
          "$ref": "#/definitions/v1PartyProfileUpdated",
          "description": "Event notifying of a party's profile update."
        },
        "teamsStatsUpdated": {
          "$ref": "#/definitions/v1TeamsStatsUpdated",
          "description": "Event notifying of an update of teams' statistics."
        },
        "timeWeightedNotionalPositionUpdated": {
          "$ref": "#/definitions/v1TimeWeightedNotionalPositionUpdated",
          "title": "Event notifying an update of the time weighted notional position for a party in an asset"
        },
        "cancelledOrders": {
          "$ref": "#/definitions/v1CancelledOrders",
          "description": "Event notifying of multiple orders being cancelled for a given party, on a given market."
        },
        "gameScores": {
          "$ref": "#/definitions/v1GameScores",
          "description": "Event notifying on near realtime game scores for parties and teams."
        },
        "amm": {
          "$ref": "#/definitions/v1AMM",
          "description": "Event notifying of AMM updates."
        },
        "volumeRebateProgramStarted": {
          "$ref": "#/definitions/v1VolumeRebateProgramStarted",
          "description": "Event notifying that a volume rebate program has started."
        },
        "volumeRebateProgramUpdated": {
          "$ref": "#/definitions/v1VolumeRebateProgramUpdated",
          "description": "Event notifying that a volume rebate program has been updated."
        },
        "volumeRebateProgramEnded": {
          "$ref": "#/definitions/v1VolumeRebateProgramEnded",
          "description": "Event notifying that a volume rebate program has ended."
        },
        "volumeRebateStatsUpdated": {
          "$ref": "#/definitions/v1VolumeRebateStatsUpdated",
          "description": "Event notifying of an update to the volume rebate statistics."
        },
        "market": {
          "$ref": "#/definitions/v1MarketEvent",
          "title": "Market tick events"
        },
        "txErrEvent": {
          "$ref": "#/definitions/v1TxErrorEvent",
          "title": "Transaction error events, not included in the ALL event type"
        },
        "version": {
          "type": "integer",
          "format": "int64",
          "title": "Version of bus event"
        },
        "chainId": {
          "type": "string"
        },
        "txHash": {
          "type": "string"
        }
      },
      "title": "Bus event is a container for event bus events emitted by Vega"
    },
    "v1BusEventType": {
      "type": "string",
      "enum": [
        "BUS_EVENT_TYPE_UNSPECIFIED",
        "BUS_EVENT_TYPE_ALL",
        "BUS_EVENT_TYPE_TIME_UPDATE",
        "BUS_EVENT_TYPE_LEDGER_MOVEMENTS",
        "BUS_EVENT_TYPE_POSITION_RESOLUTION",
        "BUS_EVENT_TYPE_ORDER",
        "BUS_EVENT_TYPE_ACCOUNT",
        "BUS_EVENT_TYPE_PARTY",
        "BUS_EVENT_TYPE_TRADE",
        "BUS_EVENT_TYPE_MARGIN_LEVELS",
        "BUS_EVENT_TYPE_PROPOSAL",
        "BUS_EVENT_TYPE_VOTE",
        "BUS_EVENT_TYPE_MARKET_DATA",
        "BUS_EVENT_TYPE_NODE_SIGNATURE",
        "BUS_EVENT_TYPE_LOSS_SOCIALIZATION",
        "BUS_EVENT_TYPE_SETTLE_POSITION",
        "BUS_EVENT_TYPE_SETTLE_DISTRESSED",
        "BUS_EVENT_TYPE_MARKET_CREATED",
        "BUS_EVENT_TYPE_ASSET",
        "BUS_EVENT_TYPE_MARKET_TICK",
        "BUS_EVENT_TYPE_WITHDRAWAL",
        "BUS_EVENT_TYPE_DEPOSIT",
        "BUS_EVENT_TYPE_AUCTION",
        "BUS_EVENT_TYPE_RISK_FACTOR",
        "BUS_EVENT_TYPE_NETWORK_PARAMETER",
        "BUS_EVENT_TYPE_LIQUIDITY_PROVISION",
        "BUS_EVENT_TYPE_MARKET_UPDATED",
        "BUS_EVENT_TYPE_ORACLE_SPEC",
        "BUS_EVENT_TYPE_ORACLE_DATA",
        "BUS_EVENT_TYPE_DELEGATION_BALANCE",
        "BUS_EVENT_TYPE_VALIDATOR_SCORE",
        "BUS_EVENT_TYPE_EPOCH_UPDATE",
        "BUS_EVENT_TYPE_VALIDATOR_UPDATE",
        "BUS_EVENT_TYPE_STAKE_LINKING",
        "BUS_EVENT_TYPE_REWARD_PAYOUT_EVENT",
        "BUS_EVENT_TYPE_CHECKPOINT",
        "BUS_EVENT_TYPE_STREAM_START",
        "BUS_EVENT_TYPE_KEY_ROTATION",
        "BUS_EVENT_TYPE_STATE_VAR",
        "BUS_EVENT_TYPE_NETWORK_LIMITS",
        "BUS_EVENT_TYPE_TRANSFER",
        "BUS_EVENT_TYPE_VALIDATOR_RANKING",
        "BUS_EVENT_TYPE_ERC20_MULTI_SIG_SIGNER_EVENT",
        "BUS_EVENT_TYPE_ERC20_MULTI_SIG_SET_THRESHOLD",
        "BUS_EVENT_TYPE_ERC20_MULTI_SIG_SIGNER_ADDED",
        "BUS_EVENT_TYPE_ERC20_MULTI_SIG_SIGNER_REMOVED",
        "BUS_EVENT_TYPE_POSITION_STATE",
        "BUS_EVENT_TYPE_ETHEREUM_KEY_ROTATION",
        "BUS_EVENT_TYPE_PROTOCOL_UPGRADE_PROPOSAL",
        "BUS_EVENT_TYPE_BEGIN_BLOCK",
        "BUS_EVENT_TYPE_END_BLOCK",
        "BUS_EVENT_TYPE_PROTOCOL_UPGRADE_STARTED",
        "BUS_EVENT_TYPE_SETTLE_MARKET",
        "BUS_EVENT_TYPE_TRANSACTION_RESULT",
        "BUS_EVENT_TYPE_SNAPSHOT_TAKEN",
        "BUS_EVENT_TYPE_PROTOCOL_UPGRADE_DATA_NODE_READY",
        "BUS_EVENT_TYPE_DISTRESSED_ORDERS_CLOSED",
        "BUS_EVENT_TYPE_EXPIRED_ORDERS",
        "BUS_EVENT_TYPE_DISTRESSED_POSITIONS",
        "BUS_EVENT_TYPE_SPOT_LIQUIDITY_PROVISION",
        "BUS_EVENT_TYPE_STOP_ORDER",
        "BUS_EVENT_TYPE_FUNDING_PERIOD",
        "BUS_EVENT_TYPE_FUNDING_PERIOD_DATA_POINT",
        "BUS_EVENT_TYPE_TEAM_CREATED",
        "BUS_EVENT_TYPE_TEAM_UPDATED",
        "BUS_EVENT_TYPE_REFEREE_SWITCHED_TEAM",
        "BUS_EVENT_TYPE_REFEREE_JOINED_TEAM",
        "BUS_EVENT_TYPE_REFERRAL_PROGRAM_STARTED",
        "BUS_EVENT_TYPE_REFERRAL_PROGRAM_UPDATED",
        "BUS_EVENT_TYPE_REFERRAL_PROGRAM_ENDED",
        "BUS_EVENT_TYPE_REFERRAL_SET_CREATED",
        "BUS_EVENT_TYPE_REFEREE_JOINED_REFERRAL_SET",
        "BUS_EVENT_TYPE_PARTY_ACTIVITY_STREAK",
        "BUS_EVENT_TYPE_VOLUME_DISCOUNT_PROGRAM_STARTED",
        "BUS_EVENT_TYPE_VOLUME_DISCOUNT_PROGRAM_UPDATED",
        "BUS_EVENT_TYPE_VOLUME_DISCOUNT_PROGRAM_ENDED",
        "BUS_EVENT_TYPE_REFERRAL_SET_STATS_UPDATED",
        "BUS_EVENT_TYPE_VESTING_STATS_UPDATED",
        "BUS_EVENT_TYPE_VOLUME_DISCOUNT_STATS_UPDATED",
        "BUS_EVENT_TYPE_FEES_STATS_UPDATED",
        "BUS_EVENT_TYPE_FUNDING_PAYMENTS",
        "BUS_EVENT_TYPE_PAID_LIQUIDITY_FEES_STATS_UPDATED",
        "BUS_EVENT_TYPE_VESTING_SUMMARY",
        "BUS_EVENT_TYPE_TRANSFER_FEES_PAID",
        "BUS_EVENT_TYPE_TRANSFER_FEES_DISCOUNT_UPDATED",
        "BUS_EVENT_TYPE_PARTY_MARGIN_MODE_UPDATED",
        "BUS_EVENT_TYPE_PARTY_PROFILE_UPDATED",
        "BUS_EVENT_TYPE_TEAMS_STATS_UPDATED",
        "BUS_EVENT_TYPE_TIME_WEIGHTED_NOTIONAL_POSITION_UPDATED",
        "BUS_EVENT_TYPE_CANCELLED_ORDERS",
        "BUS_EVENT_TYPE_GAME_SCORES",
        "BUS_EVENT_TYPE_AMM",
        "BUS_EVENT_TYPE_VOLUME_REBATE_PROGRAM_STARTED",
        "BUS_EVENT_TYPE_VOLUME_REBATE_PROGRAM_UPDATED",
        "BUS_EVENT_TYPE_VOLUME_REBATE_PROGRAM_ENDED",
        "BUS_EVENT_TYPE_VOLUME_REBATE_STATS_UPDATED",
        "BUS_EVENT_TYPE_MARKET",
        "BUS_EVENT_TYPE_TX_ERROR"
      ],
      "default": "BUS_EVENT_TYPE_UNSPECIFIED",
      "description": "- BUS_EVENT_TYPE_UNSPECIFIED: Default value, always invalid\n - BUS_EVENT_TYPE_ALL: Events of ALL event types, used when filtering stream from event bus\n - BUS_EVENT_TYPE_TIME_UPDATE: Event for blockchain time updates\n - BUS_EVENT_TYPE_LEDGER_MOVEMENTS: Event for when a transfer happens internally, contains the transfer information\n - BUS_EVENT_TYPE_POSITION_RESOLUTION: Event indicating position resolution has occurred\n - BUS_EVENT_TYPE_ORDER: Event for order updates, both new and existing orders\n - BUS_EVENT_TYPE_ACCOUNT: Event for account updates\n - BUS_EVENT_TYPE_PARTY: Event for party updates\n - BUS_EVENT_TYPE_TRADE: Event indicating a new trade has occurred\n - BUS_EVENT_TYPE_MARGIN_LEVELS: Event indicating margin levels have changed for a party\n - BUS_EVENT_TYPE_PROPOSAL: Event for proposal updates (for governance)\n - BUS_EVENT_TYPE_VOTE: Event indicating a new vote has occurred (for governance)\n - BUS_EVENT_TYPE_MARKET_DATA: Event for market data updates\n - BUS_EVENT_TYPE_NODE_SIGNATURE: Event for a new signature for a Vega node\n - BUS_EVENT_TYPE_LOSS_SOCIALIZATION: Event indicating loss socialisation occurred for a party\n - BUS_EVENT_TYPE_SETTLE_POSITION: Event for when a position is being settled\n - BUS_EVENT_TYPE_SETTLE_DISTRESSED: Event for when a position is distressed\n - BUS_EVENT_TYPE_MARKET_CREATED: Event indicating a new market was created\n - BUS_EVENT_TYPE_ASSET: Event for when an asset is added to Vega\n - BUS_EVENT_TYPE_MARKET_TICK: Event indicating a market tick event\n - BUS_EVENT_TYPE_WITHDRAWAL: Event for when a withdrawal occurs\n - BUS_EVENT_TYPE_DEPOSIT: Event for when a deposit occurs\n - BUS_EVENT_TYPE_AUCTION: Event indicating a change in auction state, for example starting or ending an auction\n - BUS_EVENT_TYPE_RISK_FACTOR: Event indicating a risk factor has been updated\n - BUS_EVENT_TYPE_NETWORK_PARAMETER: Event indicating a network parameter has been added or updated\n - BUS_EVENT_TYPE_LIQUIDITY_PROVISION: Event indicating a liquidity provision has been created or updated\n - BUS_EVENT_TYPE_MARKET_UPDATED: Event indicating a new market was created\n - BUS_EVENT_TYPE_ORACLE_SPEC: Event indicating an oracle spec has been created or updated\n - BUS_EVENT_TYPE_ORACLE_DATA: Event indicating that an oracle data has been broadcast\n - BUS_EVENT_TYPE_DELEGATION_BALANCE: Event indicating that an delegation balance of a party to a node for current epoch has changed\n - BUS_EVENT_TYPE_VALIDATOR_SCORE: Event indicating the validator score for the given epoch\n - BUS_EVENT_TYPE_EPOCH_UPDATE: Event indicating the start or end of an epoch\n - BUS_EVENT_TYPE_VALIDATOR_UPDATE: Event indicating that validator node has been updated\n - BUS_EVENT_TYPE_STAKE_LINKING: Event indicating a new staking event have been processed by the network\n - BUS_EVENT_TYPE_REWARD_PAYOUT_EVENT: Event indicating the payout of a reward has been initiated\n - BUS_EVENT_TYPE_CHECKPOINT: Event indicating a new checkpoint was created\n - BUS_EVENT_TYPE_STREAM_START: Event indicating stream is starting\n - BUS_EVENT_TYPE_KEY_ROTATION: Event indicating key rotation took place\n - BUS_EVENT_TYPE_STATE_VAR: Event indicating state transitions in state variable consensus\n - BUS_EVENT_TYPE_NETWORK_LIMITS: Event indicating network limits set or updated\n - BUS_EVENT_TYPE_TRANSFER: Event indicating a update for a transfer\n - BUS_EVENT_TYPE_VALIDATOR_RANKING: Event indicating the ranking of validator and their status in Vega\n - BUS_EVENT_TYPE_ERC20_MULTI_SIG_SIGNER_EVENT: Event indicating a new multi sig signer event have been processed\n - BUS_EVENT_TYPE_ERC20_MULTI_SIG_SET_THRESHOLD: Event indicating the erc20 multi sig threshold have been updated\n - BUS_EVENT_TYPE_ERC20_MULTI_SIG_SIGNER_ADDED: Event indicating a new signer has been added to the ERC-20 multisig\n - BUS_EVENT_TYPE_ERC20_MULTI_SIG_SIGNER_REMOVED: Event indicating a signer has been removed from the ERC-20 multisig\n - BUS_EVENT_TYPE_POSITION_STATE: Event indicating that a party's position has changed\n - BUS_EVENT_TYPE_ETHEREUM_KEY_ROTATION: Event indicating Ethereum key rotation took place\n - BUS_EVENT_TYPE_PROTOCOL_UPGRADE_PROPOSAL: Event indicating protocol upgrade proposal updates\n - BUS_EVENT_TYPE_BEGIN_BLOCK: Event indicating the core is starting to process a new block\n - BUS_EVENT_TYPE_END_BLOCK: Event indicating the core finished to process a block\n - BUS_EVENT_TYPE_PROTOCOL_UPGRADE_STARTED: Event indicating the core is starting a protocol upgrade\n - BUS_EVENT_TYPE_SETTLE_MARKET: Event indicating the market has stopped and settled\n - BUS_EVENT_TYPE_TRANSACTION_RESULT: Event indicating the result of a transaction processed by the network\n - BUS_EVENT_TYPE_SNAPSHOT_TAKEN: Event indicating a snapshot was taken at this block height\n - BUS_EVENT_TYPE_PROTOCOL_UPGRADE_DATA_NODE_READY: Event data node uses to notify that it is ready to upgrade\n - BUS_EVENT_TYPE_DISTRESSED_ORDERS_CLOSED: Event indicating parties had orders closed because they were distressed, but were not closed out.\n - BUS_EVENT_TYPE_EXPIRED_ORDERS: Event indicating parties had orders closed because they were distressed, but were not closed out.\n - BUS_EVENT_TYPE_DISTRESSED_POSITIONS: Event indicating parties have become, or were, distressed but still have an active position.\n - BUS_EVENT_TYPE_SPOT_LIQUIDITY_PROVISION: Event indicating a spot liquidity provision has been created or updated.\n - BUS_EVENT_TYPE_STOP_ORDER: Event indicating a stop order has been submitted or updated.\n - BUS_EVENT_TYPE_FUNDING_PERIOD: Event indicating the start or end of a funding period.\n - BUS_EVENT_TYPE_FUNDING_PERIOD_DATA_POINT: Event indicating a data point for a funding period has been received.\n - BUS_EVENT_TYPE_TEAM_CREATED: Event indicating a team has been created.\n - BUS_EVENT_TYPE_TEAM_UPDATED: Event indicating a team has been updated.\n - BUS_EVENT_TYPE_REFEREE_SWITCHED_TEAM: Event indicating a referee switched team.\n - BUS_EVENT_TYPE_REFEREE_JOINED_TEAM: Event indicating a referee joined a team.\n - BUS_EVENT_TYPE_REFERRAL_PROGRAM_STARTED: Event indicating a referral program started.\n - BUS_EVENT_TYPE_REFERRAL_PROGRAM_UPDATED: Event indicating a referral program has been updated.\n - BUS_EVENT_TYPE_REFERRAL_PROGRAM_ENDED: Event indicating a referral program ended.\n - BUS_EVENT_TYPE_REFERRAL_SET_CREATED: Event indicating a set has been created.\n - BUS_EVENT_TYPE_REFEREE_JOINED_REFERRAL_SET: Event indicating a referee joined a set.\n - BUS_EVENT_TYPE_PARTY_ACTIVITY_STREAK: Event indicating the updated activity streak for a party\n - BUS_EVENT_TYPE_VOLUME_DISCOUNT_PROGRAM_STARTED: Event indicating a volume discount program started.\n - BUS_EVENT_TYPE_VOLUME_DISCOUNT_PROGRAM_UPDATED: Event indicating a volume discount program has been updated.\n - BUS_EVENT_TYPE_VOLUME_DISCOUNT_PROGRAM_ENDED: Event indicating a volume discount program ended.\n - BUS_EVENT_TYPE_REFERRAL_SET_STATS_UPDATED: Event indicating the updated statistics for a referral set.\n - BUS_EVENT_TYPE_VESTING_STATS_UPDATED: Event indicating the updated statistics for the vesting program.\n - BUS_EVENT_TYPE_VOLUME_DISCOUNT_STATS_UPDATED: Event indicating the updated statistics for the volume discount.\n - BUS_EVENT_TYPE_FEES_STATS_UPDATED: Event indicating the fees statistics per market at end of epoch\n - BUS_EVENT_TYPE_FUNDING_PAYMENTS: Event indicating a funding period has ended and resulted in funding payment transfers.\n - BUS_EVENT_TYPE_PAID_LIQUIDITY_FEES_STATS_UPDATED: Event used to report the updated paid liquidity fee statistics for the market at the end of the epoch\n - BUS_EVENT_TYPE_VESTING_SUMMARY: Event used to report the summary of vesting and locked balances at the end of the epoch\n - BUS_EVENT_TYPE_TRANSFER_FEES_PAID: Event used to link ledger entries to the transfer that triggered the fees being collected.\n - BUS_EVENT_TYPE_TRANSFER_FEES_DISCOUNT_UPDATED: Event indicating that a party's available transfer fee discount has changed, per asset.\n - BUS_EVENT_TYPE_PARTY_MARGIN_MODE_UPDATED: Event indicating that a party updated their margin mode on a market.\n - BUS_EVENT_TYPE_PARTY_PROFILE_UPDATED: Event indicating that a party updated their profile.\n - BUS_EVENT_TYPE_TEAMS_STATS_UPDATED: Event indicating that teams' statistics have been updated.\n - BUS_EVENT_TYPE_TIME_WEIGHTED_NOTIONAL_POSITION_UPDATED: Event indicating time weighted notional position has been updated.\n - BUS_EVENT_TYPE_CANCELLED_ORDERS: Event containing the IDs of orders cancelled by a party on a market.\n - BUS_EVENT_TYPE_GAME_SCORES: Event containing the near realtime game scores for parties and teams.\n - BUS_EVENT_TYPE_AMM: Event use to notify for an AMM update.\n - BUS_EVENT_TYPE_VOLUME_REBATE_PROGRAM_STARTED: Event indicating a volume rebate program started.\n - BUS_EVENT_TYPE_VOLUME_REBATE_PROGRAM_UPDATED: Event indicating a volume rebate program has been updated.\n - BUS_EVENT_TYPE_VOLUME_REBATE_PROGRAM_ENDED: Event indicating a volume rebate program ended.\n - BUS_EVENT_TYPE_VOLUME_REBATE_STATS_UPDATED: Event indicating the updated statistics for the volume rebate.\n - BUS_EVENT_TYPE_MARKET: Event indicating a market related event, for example when a market opens\n - BUS_EVENT_TYPE_TX_ERROR: Event used to report failed transactions back to a user, this is excluded from the ALL type",
      "title": "Bus event type is used to specify a type of event\nIt has 2 styles of event:\nSingle values (e.g. BUS_EVENT_TYPE_ORDER) where they represent one data item\nGroup values (e.g. BUS_EVENT_TYPE_AUCTION) where they represent a group of data items"
    },
    "v1CancelAMM": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market ID to cancel an AMM for."
        },
        "method": {
          "$ref": "#/definitions/v1CancelAMMMethod",
          "description": "Method to use to cancel the AMM."
        }
      },
      "description": "Command to cancel an automated market maker for a given market."
    },
    "v1CancelAMMMethod": {
      "type": "string",
      "enum": [
        "METHOD_UNSPECIFIED",
        "METHOD_IMMEDIATE",
        "METHOD_REDUCE_ONLY"
      ],
      "default": "METHOD_UNSPECIFIED",
      "description": " - METHOD_IMMEDIATE: Cancellation will be immediate and any open positions will be transferred to the network for liquidation.\n - METHOD_REDUCE_ONLY: AMM will only trade to reduce its position, and will be cancelled once its position reaches zero."
    },
    "v1CancelledOrders": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market ID for the event."
        },
        "partyId": {
          "type": "string",
          "description": "The ID of the party which cancelled the orders."
        },
        "orderIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The order IDs that were cancelled."
        }
      }
    },
    "v1CheckRawTransactionResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether or not the transaction passed the submission checks."
        },
        "code": {
          "type": "integer",
          "format": "int64",
          "description": "Error code to indicate the category of failure if the transaction was not successfully submitted."
        },
        "gasWanted": {
          "type": "string",
          "format": "int64",
          "description": "Amount of space in a block that the transaction will fill. This does not relate to any monetary cost for submitting the transaction."
        },
        "gasUsed": {
          "type": "string",
          "format": "int64",
          "description": "Unused."
        },
        "data": {
          "type": "string",
          "description": "Further details for why the transaction was not successfully checked."
        },
        "log": {
          "type": "string",
          "description": "Further details for the underlying consensus layer of the result of the transaction."
        },
        "info": {
          "type": "string",
          "title": "Unused"
        }
      },
      "title": "Response for checking a version agnostic transaction on Vega"
    },
    "v1CheckTransactionResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether or not the transaction passed the submission checks."
        },
        "code": {
          "type": "integer",
          "format": "int64",
          "description": "Error code to indicate the category of failure if the transaction was not successfully checked."
        },
        "gasWanted": {
          "type": "string",
          "format": "int64",
          "description": "Amount of space in a block that the transaction will fill. This does not relate to any monetary cost for submitting the transaction."
        },
        "gasUsed": {
          "type": "string",
          "format": "int64",
          "description": "Unused."
        },
        "data": {
          "type": "string",
          "description": "Further details for why the transaction was not successfully submitted."
        },
        "log": {
          "type": "string",
          "description": "Further details for the underlying consensus layer of the result of the transaction."
        },
        "info": {
          "type": "string",
          "description": "Unused."
        }
      }
    },
    "v1CheckpointEvent": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string"
        },
        "blockHash": {
          "type": "string"
        },
        "blockHeight": {
          "type": "string",
          "format": "uint64"
        }
      }
    },
    "v1Condition": {
      "type": "object",
      "properties": {
        "operator": {
          "$ref": "#/definitions/ConditionOperator",
          "description": "Type of comparison to make on the value."
        },
        "value": {
          "type": "string",
          "description": "Value to be compared with by the operator."
        }
      },
      "title": "Condition describes the condition that must be validated by the network"
    },
    "v1CoreSnapshotData": {
      "type": "object",
      "properties": {
        "blockHeight": {
          "type": "string",
          "format": "uint64",
          "title": "Block height at which snapshot was taken"
        },
        "blockHash": {
          "type": "string",
          "title": "Hash of the snapshot block"
        },
        "coreVersion": {
          "type": "string",
          "description": "Semver version number of the core."
        },
        "protocolUpgradeBlock": {
          "type": "boolean",
          "title": "Indicates if the snapshot is taken as part of protocol upgrade"
        }
      },
      "description": "CoreSnapshotData represents the core snapshot data."
    },
    "v1CreateReferralSet": {
      "type": "object",
      "properties": {
        "isTeam": {
          "type": "boolean",
          "description": "Whether or not the referral set should be considered a team that can participate in team games on the network."
        },
        "team": {
          "$ref": "#/definitions/v1CreateReferralSetTeam",
          "description": "Team details, if the referral set is to be considered a team."
        }
      },
      "description": "Command that a party can use to instruct the network to create a new referral set on the network.\nThe submitter of this command will become the referrer of the new set and cannot be the referrer or a referee of another set.\nA referrer can use the referral set ID as a referral code to attract others to the Vega network and have fees reduced for the referral set."
    },
    "v1CreateReferralSetTeam": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the team."
        },
        "teamUrl": {
          "type": "string",
          "description": "External link to the team's homepage."
        },
        "avatarUrl": {
          "type": "string",
          "description": "External link to an avatar for the team."
        },
        "closed": {
          "type": "boolean",
          "description": "Whether or not the team is closed to new party members."
        },
        "allowList": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of public keys that are allowed to join the team.\nOnly applicable to closed teams. Removing a party from the allow list does not remove\nthe party from the team."
        }
      }
    },
    "v1Data": {
      "type": "object",
      "properties": {
        "signers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Signer"
          }
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Property"
          },
          "title": "Data holds all the properties of the data"
        },
        "matchedSpecIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "`matched_specs_ids` lists all the specs that matched this data.\nWhen the array is empty, it means no spec matched this data."
        },
        "broadcastAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds for when the data was broadcast to the markets\nwith a matching spec. It has no value when the data did not match any spec."
        },
        "metaData": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Property"
          },
          "title": "Holds all metadata properties"
        },
        "error": {
          "type": "string",
          "description": "Error message if the data could not be sourced."
        }
      },
      "description": "Data describes valid source data that has been received by the node.\nIt represents both matched and unmatched data."
    },
    "v1DelegateSubmission": {
      "type": "object",
      "properties": {
        "nodeId": {
          "type": "string",
          "description": "Node ID to delegate stake to."
        },
        "amount": {
          "type": "string",
          "description": "Amount of stake to delegate, as an unsigned integer scaled to the governance asset's decimal places."
        }
      },
      "description": "Command to allow a token holder to delegate their tokens to a validator to help secure the network.\nA token holder delegating to a validator will earn rewards based on the amount they have delegated, and the performance of the chosen validator."
    },
    "v1DelegationBalanceEvent": {
      "type": "object",
      "properties": {
        "party": {
          "type": "string"
        },
        "nodeId": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        },
        "epochSeq": {
          "type": "string"
        }
      },
      "title": "DelegationBalanceEvent - updates on the delegation balance of a party to a node in the current epoch in effect"
    },
    "v1DistressedOrders": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "parties": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Slice of Party IDs i.e. each party's public key for the event"
        }
      },
      "title": "Distressed order contains the party IDs for all parties that were distressed and had their orders closed,\nbut did not need to be closed out after cancelling their orders"
    },
    "v1DistressedPositions": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "distressedParties": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Slice of party IDs i.e. each party's public key, that are distressed but still have open volume"
        },
        "safeParties": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Slice of party IDs i.e. each party's public key, who were distressed but now can safely maintain their position"
        }
      },
      "description": "Distressed positions event contains the party IDs for all parties that were distressed, had their orders closed but because of insufficient volume on the book\ncould not be fully closed out. These parties are distressed, but still hold an active position on the book as a result. Once enough volume is on the book to close\nthem out, a SettleDistressed event will be sent. In case they manage to reduce their position, or meet the margin requirements, this status will be updated.\nParties that are no longer distressed but active will be listed in the safe_parties field."
    },
    "v1ERC20MultiSigSignerAdded": {
      "type": "object",
      "properties": {
        "signatureId": {
          "type": "string",
          "title": "ID of the signature bundle"
        },
        "validatorId": {
          "type": "string",
          "title": "Node ID of the Vega node to be added"
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "title": "Time at which this happened"
        },
        "newSigner": {
          "type": "string",
          "title": "Ethereum address of the new signer"
        },
        "submitter": {
          "type": "string",
          "title": "Address of the submitter of the transaction"
        },
        "nonce": {
          "type": "string",
          "description": "Nonce used."
        },
        "epochSeq": {
          "type": "string",
          "title": "Epoch that the node was added for"
        },
        "chainId": {
          "type": "string",
          "description": "EVM chain ID that the multisig control contract lives on."
        }
      }
    },
    "v1ERC20MultiSigSignerEvent": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/v1ERC20MultiSigSignerEventType"
        },
        "signer": {
          "type": "string"
        },
        "nonce": {
          "type": "string"
        },
        "blockTime": {
          "type": "string",
          "format": "int64"
        },
        "txHash": {
          "type": "string"
        },
        "logIndex": {
          "type": "string",
          "format": "uint64"
        },
        "blockNumber": {
          "type": "string",
          "format": "uint64"
        },
        "chainId": {
          "type": "string"
        }
      }
    },
    "v1ERC20MultiSigSignerEventType": {
      "type": "string",
      "enum": [
        "TYPE_UNSPECIFIED",
        "TYPE_ADDED",
        "TYPE_REMOVED"
      ],
      "default": "TYPE_UNSPECIFIED"
    },
    "v1ERC20MultiSigSignerRemoved": {
      "type": "object",
      "properties": {
        "signatureSubmitters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ERC20MultiSigSignerRemovedSubmitter"
          },
          "title": "List containing all the IDs of bundle generated\nThere should be one bundle generated for every validators\nin the validator set"
        },
        "validatorId": {
          "type": "string",
          "title": "Node ID of the Vega node which is to be removed"
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "title": "Time at which this happened"
        },
        "oldSigner": {
          "type": "string",
          "title": "Ethereum address of the signer to be removed"
        },
        "nonce": {
          "type": "string",
          "description": "Nonce used."
        },
        "epochSeq": {
          "type": "string",
          "title": "Epoch that the node was removed for"
        },
        "chainId": {
          "type": "string",
          "description": "EVM chain ID that the multisig control contract lives on."
        }
      }
    },
    "v1ERC20MultiSigSignerRemovedSubmitter": {
      "type": "object",
      "properties": {
        "signatureId": {
          "type": "string",
          "description": "Signature ID of the signer removed."
        },
        "submitter": {
          "type": "string",
          "title": "Address of the submitter of the transaction"
        }
      }
    },
    "v1ERC20MultiSigThresholdSetEvent": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "newThreshold": {
          "type": "integer",
          "format": "int64"
        },
        "nonce": {
          "type": "string"
        },
        "blockTime": {
          "type": "string",
          "format": "int64"
        },
        "txHash": {
          "type": "string"
        },
        "logIndex": {
          "type": "string",
          "format": "uint64"
        },
        "blockNumber": {
          "type": "string",
          "format": "uint64"
        },
        "chainId": {
          "type": "string"
        }
      }
    },
    "v1ETHAddress": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        }
      }
    },
    "v1EndBlock": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "uint64"
        }
      },
      "title": "EndBlock"
    },
    "v1EpochEvent": {
      "type": "object",
      "properties": {
        "seq": {
          "type": "string",
          "format": "uint64",
          "title": "Sequence number that increases by one each epoch"
        },
        "action": {
          "$ref": "#/definitions/vegaEpochAction",
          "title": "Action tells us what action is taking place"
        },
        "startTime": {
          "type": "string",
          "format": "int64",
          "title": "Vega time at which this epoch started"
        },
        "expireTime": {
          "type": "string",
          "format": "int64",
          "title": "Vega time at which this epoch should end"
        },
        "endTime": {
          "type": "string",
          "format": "int64",
          "title": "Vega time at which this epoch actually ended"
        }
      },
      "title": "Epoch details"
    },
    "v1EthereumKeyRotateSubmission": {
      "type": "object",
      "properties": {
        "targetBlock": {
          "type": "string",
          "format": "uint64",
          "description": "Block height at which the key rotation will take effect."
        },
        "newAddress": {
          "type": "string",
          "description": "Ethereum address that is being rotated to."
        },
        "currentAddress": {
          "type": "string",
          "description": "Ethereum address of the node's current Ethereum keys."
        },
        "submitterAddress": {
          "type": "string",
          "description": "Ethereum public key to use as a submitter to allow automatic signature generation."
        },
        "ethereumSignature": {
          "$ref": "#/definitions/v1Signature",
          "description": "Signature signed by the new Ethereum key that can be verified to prove ownership."
        }
      },
      "description": "A validator command sent manually that allows a node operator to indicate to the network that their node's Ethereum key will be rotated."
    },
    "v1EthereumKeyRotation": {
      "type": "object",
      "properties": {
        "nodeId": {
          "type": "string",
          "title": "Node ID of the node that rotated their Ethereum key"
        },
        "oldAddress": {
          "type": "string",
          "title": "Ethereum address that was previously associated with the node"
        },
        "newAddress": {
          "type": "string",
          "title": "Ethereum address that is newly associated with the node"
        },
        "blockHeight": {
          "type": "string",
          "format": "uint64",
          "title": "Block height when the key rotation took effect"
        }
      },
      "title": "Event that contains information about an Ethereum key rotation"
    },
    "v1ExpiredOrders": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "orderIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Slice of expired order IDs"
        }
      }
    },
    "v1ExternalData": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1Data"
        }
      }
    },
    "v1FeesStats": {
      "type": "object",
      "properties": {
        "market": {
          "type": "string",
          "title": "Market the fees were paid in"
        },
        "asset": {
          "type": "string",
          "description": "Settlement asset of the market."
        },
        "epochSeq": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch for which these stats where valid."
        },
        "totalRewardsReceived": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyAmount"
          },
          "description": "Total referral rewards received by the referrer of the referral set."
        },
        "referrerRewardsGenerated": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ReferrerRewardsGenerated"
          },
          "description": "Referral rewards generated by all referee taker fees."
        },
        "refereesDiscountApplied": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyAmount"
          },
          "description": "Total referral discounts applied to all referee taker fees."
        },
        "volumeDiscountApplied": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyAmount"
          },
          "description": "Total volume discounts applied to all referee taker fees."
        },
        "totalMakerFeesReceived": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyAmount"
          },
          "description": "Total maker fees received by the maker side."
        },
        "makerFeesGenerated": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1MakerFeesGenerated"
          },
          "description": "Maker fees paid by all trade aggressors, and which makers the fees were paid to."
        },
        "totalFeesPaidAndReceived": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyAmount"
          },
          "description": "Total trading fees received and paid by the party."
        }
      },
      "title": "Fees rewards and discounts paid / received per parties during an epoch"
    },
    "v1Filter": {
      "type": "object",
      "properties": {
        "key": {
          "$ref": "#/definitions/v1PropertyKey",
          "description": "Data source's data property key targeted by the filter."
        },
        "conditions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Condition"
          },
          "description": "Conditions that should be matched by the data to be\nconsidered of interest."
        }
      },
      "description": "Filter describes the conditions under which a data source data is considered of\ninterest or not."
    },
    "v1FundingPayment": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "description": "ID of the party."
        },
        "amount": {
          "type": "string",
          "description": "The amount paid, this can be negative for parties who lost at the end of the funding period."
        }
      },
      "description": "The amount gained or lost by a party as a result of a funding payment."
    },
    "v1FundingPayments": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "ID of the market."
        },
        "seq": {
          "type": "string",
          "format": "uint64",
          "description": "Sequence number of the funding period associated with these payments."
        },
        "payments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1FundingPayment"
          },
          "description": "List of parties and the payment amounts, this can be negative for parties who lost at the end of the funding period."
        }
      },
      "description": "Event notifying of funding payments at the end of a funding period."
    },
    "v1FundingPeriod": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "ID of the market for which this funding period relates to."
        },
        "seq": {
          "type": "string",
          "format": "uint64",
          "description": "Sequence number of the funding period."
        },
        "start": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the funding period started."
        },
        "end": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the funding period ended."
        },
        "fundingPayment": {
          "type": "string",
          "description": "Funding payment for this period as the difference between the time-weighted average price of the external and internal data point."
        },
        "fundingRate": {
          "type": "string",
          "description": "Percentage difference between the time-weighted average price of the external and internal data point."
        },
        "internalTwap": {
          "type": "string",
          "description": "TWAP for this period based on the internal data-points."
        },
        "externalTwap": {
          "type": "string",
          "description": "TWAP for this period based on the external data-points."
        }
      },
      "description": "Event notifying on the details of a funding interval for a perpetuals market."
    },
    "v1FundingPeriodDataPoint": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market ID which the data point relates to."
        },
        "seq": {
          "type": "string",
          "format": "uint64",
          "description": "Sequence number of the funding period this data point belongs to."
        },
        "dataPointType": {
          "$ref": "#/definitions/FundingPeriodDataPointSource",
          "description": "Origin of the data point."
        },
        "price": {
          "type": "string",
          "description": "Price of the asset as seen by this data point."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds of when the data point was received."
        },
        "twap": {
          "type": "string",
          "description": "The TWAP for this source with this data-point added."
        }
      },
      "description": "Event notifying a data point for a funding period."
    },
    "v1GamePartyScore": {
      "type": "object",
      "properties": {
        "gameId": {
          "type": "string",
          "description": "Game ID."
        },
        "party": {
          "type": "string",
          "description": "The party ID."
        },
        "teamId": {
          "type": "string",
          "description": "Team the party belongs to. Unset if the party is not part of a team."
        },
        "epoch": {
          "type": "string",
          "format": "int64",
          "description": "Epoch when these scores were generated."
        },
        "time": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds when these scores were generated."
        },
        "score": {
          "type": "string",
          "description": "Party's current score in the game."
        },
        "stakingBalance": {
          "type": "string",
          "description": "Party's current staking balance. Only populated if the game has a requirement for it."
        },
        "openVolume": {
          "type": "string",
          "description": "Party's current open volume. Only populated if the game has a requirement for it."
        },
        "totalFeesPaid": {
          "type": "string",
          "description": "Total fees paid by the party during the relevant period."
        },
        "isEligible": {
          "type": "boolean",
          "description": "If the party is eligible for a reward for this game based on the current information."
        },
        "rank": {
          "type": "string",
          "format": "uint64",
          "description": "If the party is a member of a team, this is their relative position in the sorting order of the team.\nEmpty if not a team, or if the party is not eligible."
        }
      },
      "description": "Scores per party per game with eligibility context."
    },
    "v1GameScores": {
      "type": "object",
      "properties": {
        "teamScores": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1GameTeamScore"
          }
        },
        "partyScores": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1GamePartyScore"
          }
        }
      }
    },
    "v1GameTeamScore": {
      "type": "object",
      "properties": {
        "gameId": {
          "type": "string",
          "description": "Game ID."
        },
        "teamId": {
          "type": "string",
          "title": "Team ID"
        },
        "epoch": {
          "type": "string",
          "format": "int64",
          "description": "Epoch when these scores were generated."
        },
        "time": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds when these scores were generated."
        },
        "score": {
          "type": "string",
          "description": "Team's current collective score in the game."
        }
      }
    },
    "v1GetSpamStatisticsResponse": {
      "type": "object",
      "properties": {
        "chainId": {
          "type": "string",
          "description": "Chain ID for which the statistics are captured."
        },
        "statistics": {
          "$ref": "#/definitions/v1SpamStatistics",
          "title": "Spam statistics for the party"
        }
      },
      "title": "Response containing all the spam statistics of a party for the current epoch"
    },
    "v1GetVegaTimeResponse": {
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "int64",
          "title": "Timestamp representation of current VegaTime as represented in\nUnix nanoseconds, for example `1580473859111222333` corresponds to `2020-01-31T12:30:59.111222333Z`"
        }
      },
      "title": "Response for the current consensus coordinated time on the Vega network, referred to as \"VegaTime\""
    },
    "v1IcebergOpts": {
      "type": "object",
      "properties": {
        "peakSize": {
          "type": "string",
          "format": "uint64",
          "description": "Size of the order that is made visible and can be traded with during the execution of a single order."
        },
        "minimumVisibleSize": {
          "type": "string",
          "format": "uint64",
          "description": "Minimum allowed remaining size of the order before it is replenished back to its peak size."
        }
      },
      "title": "Iceberg order options"
    },
    "v1InternalTimeTrigger": {
      "type": "object",
      "properties": {
        "initial": {
          "type": "string",
          "format": "int64",
          "description": "Trigger when the vega time is greater or equal to this time, in Unix seconds."
        },
        "every": {
          "type": "string",
          "format": "int64",
          "description": "Repeat the trigger every n seconds after the initial. If no time for\ninitial was specified, begin repeating immediately."
        }
      },
      "description": "Trigger for an internal time data source."
    },
    "v1IssueSignatures": {
      "type": "object",
      "properties": {
        "submitter": {
          "type": "string",
          "description": "Ethereum address which will submit the signatures to the smart contract."
        },
        "kind": {
          "$ref": "#/definitions/v1NodeSignatureKind",
          "description": "What kind of signatures to generate, namely for whether a signer is being added or removed."
        },
        "validatorNodeId": {
          "type": "string",
          "description": "Node ID of the validator node that will be signed in or out of the smart contract."
        },
        "chainId": {
          "type": "string",
          "description": "Chain ID of the bridge to generate signatures for."
        }
      },
      "description": "Command that can be used by a validator to instruct the network to generate signatures to add or remove validators from the multisig-control contract.\nSignatures can only be generated for validator nodes that have been promoted or demoted from the consensus validator set, and any attempt to generate signatures for another node will be rejected.\nThe generated signatures can only be submitted to the contract by the Ethereum addresses included in the command."
    },
    "v1JoinTeam": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "ID of the team to join, this is the same as the referral code used to generate the team."
        }
      },
      "description": "Command that allows the submitter to join a team or change teams if they are already a member of a team."
    },
    "v1KeyRotateSubmission": {
      "type": "object",
      "properties": {
        "newPubKeyIndex": {
          "type": "integer",
          "format": "int64",
          "description": "New Vega public key derivation index."
        },
        "targetBlock": {
          "type": "string",
          "format": "uint64",
          "description": "Block height at which the key rotation will take effect."
        },
        "newPubKey": {
          "type": "string",
          "description": "Vega public key that would be rotated to."
        },
        "currentPubKeyHash": {
          "type": "string",
          "description": "Hash of the node's current Vega public key."
        }
      },
      "description": "A validator command sent manually that allows a node operator to indicate to the network that their node's Vega key will be rotated."
    },
    "v1KeyRotation": {
      "type": "object",
      "properties": {
        "nodeId": {
          "type": "string",
          "title": "Node ID of the node that rotated their Vega key"
        },
        "oldPubKey": {
          "type": "string",
          "title": "Vega public key that was previously associated with the node"
        },
        "newPubKey": {
          "type": "string",
          "title": "Vega public key that is newly associated with the node"
        },
        "blockHeight": {
          "type": "string",
          "format": "uint64",
          "title": "Block height when the key rotation took effect"
        }
      },
      "title": "Event that contains information about a Vega key rotation"
    },
    "v1LastBlockHeightResponse": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "uint64",
          "title": "Last block height"
        },
        "hash": {
          "type": "string",
          "title": "Last block hash"
        },
        "spamPowHashFunction": {
          "type": "string",
          "title": "Supported proof of work hash function"
        },
        "spamPowDifficulty": {
          "type": "integer",
          "format": "int64",
          "title": "Difficulty of the proof of work, i.e. the target number of zeros"
        },
        "spamPowNumberOfPastBlocks": {
          "type": "integer",
          "format": "int64",
          "title": "Supported proof of work number of blocks behind current height allowed"
        },
        "spamPowNumberOfTxPerBlock": {
          "type": "integer",
          "format": "int64",
          "title": "Allowed number of transactions per block"
        },
        "spamPowIncreasingDifficulty": {
          "type": "boolean",
          "title": "Boolean indicating whether increasing difficulty is allowed for using the\nsame height for more than `spam_pow_number_of_past_blocks` transactions"
        },
        "chainId": {
          "type": "string",
          "title": "Network chain id from which the block comes from"
        }
      },
      "title": "Response with the height of the last block processed by\ntendermint"
    },
    "v1LedgerMovements": {
      "type": "object",
      "properties": {
        "ledgerMovements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaLedgerMovement"
          },
          "title": "One or more entries containing internal transfer information"
        }
      },
      "title": "Transfer responses event contains a collection of transfer information"
    },
    "v1LiquidityProvisionAmendment": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market that the submitter wants to amend the liquidity commitment for."
        },
        "commitmentAmount": {
          "type": "string",
          "description": "New commitment amount."
        },
        "fee": {
          "type": "string",
          "description": "New nominated liquidity fee factor."
        },
        "reference": {
          "type": "string",
          "description": "New arbitrary reference to be added to every order created out of this liquidity provision submission."
        }
      },
      "description": "Command that allows a liquidity provider to update the details of their existing liquidity commitment.\nAny field that is left unset or as a default value indicates that this field on the original submission will be left unchanged."
    },
    "v1LiquidityProvisionCancellation": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market that the submitter will stop providing liquidity for."
        }
      },
      "description": "Command that allows a liquidity provider to inform the network that they will stop providing liquidity for a market."
    },
    "v1LiquidityProvisionSubmission": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market that the submitter wishes to provide liquidity for."
        },
        "commitmentAmount": {
          "type": "string",
          "description": "Amount that the submitter will commit as liquidity to the market, specified as a unitless number in the settlement asset of the market.\nThis field is an unsigned integer scaled using the asset's decimal places."
        },
        "fee": {
          "type": "string",
          "description": "Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers."
        },
        "reference": {
          "type": "string",
          "description": "Arbitrary reference to be added to every order created out of this liquidity provision submission."
        }
      },
      "description": "A command that indicates to the network the party's intention to supply liquidity to the given market and become a liquidity provider.\nAn active liquidity provider for a market will earn fees based on the trades that occur in the market."
    },
    "v1LossSocialization": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "partyId": {
          "type": "string",
          "title": "Party ID (public key) for the event"
        },
        "amount": {
          "type": "string",
          "title": "Amount distributed"
        }
      },
      "title": "Loss socialization event contains details on the amount of wins unable to be distributed"
    },
    "v1MakerFeesGenerated": {
      "type": "object",
      "properties": {
        "taker": {
          "type": "string",
          "description": "Party that paid the fees."
        },
        "makerFeesPaid": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyAmount"
          },
          "description": "Amount of maker fees paid by the taker to the maker."
        }
      },
      "title": "Maker fees generated by the trade aggressor"
    },
    "v1MarketEvent": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "payload": {
          "type": "string",
          "title": "Payload is a unique information string"
        }
      },
      "title": "MarketEvent - the common denominator for all market events\ninterface has a method to return a string for logging"
    },
    "v1MarketTick": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "time": {
          "type": "string",
          "format": "int64",
          "title": "Timestamp containing latest update from Vega blockchain aka Vega-time"
        }
      },
      "title": "Market tick event contains the time value for when a particular market was last processed on Vega"
    },
    "v1NodeSignature": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "ID of the resource that the signature relates to."
        },
        "sig": {
          "type": "string",
          "format": "byte",
          "description": "Signature generated by the node."
        },
        "kind": {
          "$ref": "#/definitions/v1NodeSignatureKind",
          "description": "Kind of resource being signed."
        }
      },
      "description": "A validator command sent automatically containing a signature that can be used on a foreign chain to process an action."
    },
    "v1NodeSignatureKind": {
      "type": "string",
      "enum": [
        "NODE_SIGNATURE_KIND_UNSPECIFIED",
        "NODE_SIGNATURE_KIND_ASSET_NEW",
        "NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL",
        "NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED",
        "NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED",
        "NODE_SIGNATURE_KIND_ASSET_UPDATE"
      ],
      "default": "NODE_SIGNATURE_KIND_UNSPECIFIED",
      "description": "- NODE_SIGNATURE_KIND_UNSPECIFIED: Represents an unspecified or missing value from the input.\n - NODE_SIGNATURE_KIND_ASSET_NEW: Represents a signature for a new asset allow-listing.\n - NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL: Represents a signature for an asset withdrawal.\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED: Represents a signature for a new signer added to the erc20 multisig contract.\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED: Represents a signature for a signer removed from the erc20 multisig contract.\n - NODE_SIGNATURE_KIND_ASSET_UPDATE: Represents a signature for an asset update allow-listing.",
      "title": "Kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc"
    },
    "v1ObserveEventBusResponse": {
      "type": "object",
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1BusEvent"
          },
          "description": "One or more events that match the subscription request criteria."
        }
      },
      "title": "Response to a subscribed stream of events from the Vega event bus"
    },
    "v1OneOffGovernanceTransfer": {
      "type": "object",
      "properties": {
        "deliverOn": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1OracleDataSubmission": {
      "type": "object",
      "properties": {
        "source": {
          "$ref": "#/definitions/OracleDataSubmissionOracleSource",
          "description": "Source from which the data is coming from."
        },
        "payload": {
          "type": "string",
          "format": "byte",
          "description": "Data provided by the data source."
        }
      },
      "title": "Command to submit new oracle data from third party providers"
    },
    "v1OrderAmendment": {
      "type": "object",
      "properties": {
        "orderId": {
          "type": "string",
          "description": "ID of the order to amend."
        },
        "marketId": {
          "type": "string",
          "description": "Market ID that the order was originally submitted to."
        },
        "price": {
          "type": "string",
          "description": "New price for the order. This field is an unsigned integer scaled to the market's decimal places."
        },
        "sizeDelta": {
          "type": "string",
          "format": "int64",
          "description": "Amend the size for the order by the delta specified:\n- To reduce the size from the current value set a negative integer value\n- To increase the size from the current value, set a positive integer value\n- To leave the size unchanged set a value of zero\nThis field needs to be scaled using the market's position decimal places.\nIf specified, size must not be set."
        },
        "expiresAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp, in Unix nanoseconds, for the new expiry time for the order."
        },
        "timeInForce": {
          "$ref": "#/definitions/OrderTimeInForce",
          "description": "New time in force for the order."
        },
        "peggedOffset": {
          "type": "string",
          "description": "New pegged offset for the order.\nThis field is an unsigned integer scaled to the market's decimal places."
        },
        "peggedReference": {
          "$ref": "#/definitions/vegaPeggedReference",
          "description": "New pegged reference for the order."
        },
        "size": {
          "type": "string",
          "format": "uint64",
          "description": "New size for the order.\nAmending the size causes the size and remaining part of the order to be changed by the difference between the original and amended size.\n- Specifying a size smaller than the current size leaves the order at its current order book position.\n- Specifying a size larger than the current size removes and reinserts the order at the back of the price level.\n- Specifying a size that results in the remaining part of the order being reduced to zero cancels the order.\nThis field is an unsigned integer scaled to the market's decimal places.\nIf specified, size_delta must be set to 0."
        }
      },
      "description": "A command that allows a party to update the details of an existing order.\nAny field that is left unset or as a default value indicates that this field on the original order will be left unchanged.\nIt is not possible to change an order's type through this command."
    },
    "v1OrderCancellation": {
      "type": "object",
      "properties": {
        "orderId": {
          "type": "string",
          "description": "Restrict cancellations to an order with the given ID. If set, then a market ID must also be provided."
        },
        "marketId": {
          "type": "string",
          "description": "Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled."
        }
      },
      "description": "A command that instructs the network to cancel orders, active or partially filled, that were previously submitted by the sender of this transaction.\nIt is not possible to cancel another party's order with this command."
    },
    "v1OrderSubmission": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market ID to submit the order to."
        },
        "price": {
          "type": "string",
          "description": "Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\nrequired field for limit orders, however it is not required for market orders.\nThis field is an unsigned integer scaled to the market's decimal places."
        },
        "size": {
          "type": "string",
          "format": "uint64",
          "description": "Size for the order, for example, in a futures market the size equals the number of units."
        },
        "side": {
          "$ref": "#/definitions/vegaSide",
          "description": "Which side of the order book the order is for, e.g. buy or sell."
        },
        "timeInForce": {
          "$ref": "#/definitions/OrderTimeInForce",
          "description": "Time in force indicates how long an order will remain active before it is executed or expires.."
        },
        "expiresAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT."
        },
        "type": {
          "$ref": "#/definitions/vegaOrderType",
          "description": "Type of the order."
        },
        "reference": {
          "type": "string",
          "description": "Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order."
        },
        "peggedOrder": {
          "$ref": "#/definitions/vegaPeggedOrder",
          "description": "Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times."
        },
        "postOnly": {
          "type": "boolean",
          "description": "If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders."
        },
        "reduceOnly": {
          "type": "boolean",
          "description": "If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.\nOnly valid for non-persistent orders."
        },
        "icebergOpts": {
          "$ref": "#/definitions/v1IcebergOpts",
          "description": "Iceberg order details. If set, the order will exist on the order book in chunks."
        }
      },
      "description": "A command that submits an order to the Vega network for a given market."
    },
    "v1PaidLiquidityFeesStats": {
      "type": "object",
      "properties": {
        "market": {
          "type": "string",
          "description": "Market the fees were paid in."
        },
        "asset": {
          "type": "string",
          "description": "Settlement asset of the market."
        },
        "epochSeq": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch for which these stats where valid."
        },
        "totalFeesPaid": {
          "type": "string",
          "description": "Total fees paid across all parties."
        },
        "feesPaidPerParty": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyAmount"
          },
          "description": "Fees paid per party."
        }
      }
    },
    "v1PartyActivityStreak": {
      "type": "object",
      "properties": {
        "party": {
          "type": "string",
          "description": "The party."
        },
        "activeFor": {
          "type": "string",
          "format": "uint64",
          "description": "How many epoch this party has been active for."
        },
        "inactiveFor": {
          "type": "string",
          "format": "uint64",
          "description": "how many epoch this party has been inactive for."
        },
        "isActive": {
          "type": "boolean",
          "description": "Is this party considered active or not."
        },
        "rewardDistributionActivityMultiplier": {
          "type": "string",
          "description": "The current rewards distribution multiplier for this party."
        },
        "rewardVestingActivityMultiplier": {
          "type": "string",
          "description": "The vesting multiplier for this party."
        },
        "epoch": {
          "type": "string",
          "format": "uint64",
          "description": "The epoch this information is relevant to."
        },
        "tradedVolume": {
          "type": "string",
          "title": "Party's traded volume at the end of the given epoch"
        },
        "openVolume": {
          "type": "string",
          "title": "Party's open interest volume at the end of the given epoch"
        }
      },
      "title": "The updated activity streak of a party at end of epoch"
    },
    "v1PartyAmount": {
      "type": "object",
      "properties": {
        "party": {
          "type": "string",
          "description": "Receiving party ID."
        },
        "amount": {
          "type": "string",
          "description": "Amount received."
        },
        "quantumAmount": {
          "type": "string",
          "description": "Amount value in quantum."
        }
      },
      "title": "A pair of a party and amount"
    },
    "v1PartyLockedBalance": {
      "type": "object",
      "properties": {
        "asset": {
          "type": "string",
          "description": "Asset ID."
        },
        "untilEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch in which the balance will be released."
        },
        "balance": {
          "type": "string",
          "description": "Locked balance."
        }
      },
      "description": "A party's locked balance for a given asset."
    },
    "v1PartyMarginModeUpdated": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Unique ID of the market in which the update happened."
        },
        "partyId": {
          "type": "string",
          "description": "Unique ID of the party that updated their margin mode."
        },
        "marginMode": {
          "$ref": "#/definitions/vegaMarginMode",
          "description": "Updated margin mode."
        },
        "marginFactor": {
          "type": "string",
          "description": "Margin factor for the market. Isolated mode only."
        },
        "minTheoreticalMarginFactor": {
          "type": "string",
          "description": "Minimum theoretical margin factor for the market. Isolated mode only."
        },
        "maxTheoreticalLeverage": {
          "type": "string",
          "description": "Maximum theoretical leverage for the market. Isolated mode only."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the update happened."
        }
      }
    },
    "v1PartyProfileUpdated": {
      "type": "object",
      "properties": {
        "updatedProfile": {
          "$ref": "#/definitions/vegaPartyProfile",
          "description": "Party's profile updated."
        }
      }
    },
    "v1PartyVestingBalance": {
      "type": "object",
      "properties": {
        "asset": {
          "type": "string",
          "description": "Asset ID."
        },
        "balance": {
          "type": "string",
          "description": "Balance that is vested."
        }
      },
      "description": "Balance that is being vested for the party."
    },
    "v1PartyVestingStats": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "description": "The party."
        },
        "rewardBonusMultiplier": {
          "type": "string",
          "description": "The bonus multiplier applied on the reward."
        },
        "quantumBalance": {
          "type": "string",
          "description": "The balance of the party, in quantum."
        },
        "summedRewardBonusMultiplier": {
          "type": "string",
          "description": "Bonus multiplier applied on the reward, summed across all derived accounts."
        },
        "summedQuantumBalance": {
          "type": "string",
          "description": "The balance of the party and derived keys, in quantum."
        }
      },
      "description": "The vesting stats for a given party."
    },
    "v1PartyVestingSummary": {
      "type": "object",
      "properties": {
        "party": {
          "type": "string",
          "description": "Party ID."
        },
        "partyLockedBalances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyLockedBalance"
          },
          "description": "List of locked balances."
        },
        "partyVestingBalances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyVestingBalance"
          },
          "description": "List of vesting balances."
        }
      },
      "title": "Summary of a party's vesting balances"
    },
    "v1PartyVolumeDiscountStats": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "description": "Party ID."
        },
        "discountFactor": {
          "type": "string",
          "description": "deprecated."
        },
        "runningVolume": {
          "type": "string",
          "description": "The party's running volume."
        },
        "discountFactors": {
          "$ref": "#/definitions/vegaDiscountFactors",
          "description": "Discount factors applied to fees."
        }
      },
      "description": "Volume discount stats for a given party."
    },
    "v1PartyVolumeRebateStats": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "description": "Party ID."
        },
        "additionalRebate": {
          "type": "string",
          "description": "Rebate factor applied to fees."
        },
        "makerVolumeFraction": {
          "type": "string",
          "description": "The party's maker volume fraction."
        },
        "makerFeesReceived": {
          "type": "string",
          "description": "The party's maker fee received over the window across all markets and assets, expressed in quantum."
        }
      },
      "description": "Volume rebate stats for a given party."
    },
    "v1PoWBlockState": {
      "type": "object",
      "properties": {
        "blockHeight": {
          "type": "string",
          "format": "uint64",
          "title": "Block height for the current Proof of Work state statistics"
        },
        "blockHash": {
          "type": "string",
          "title": "Hash of the current block"
        },
        "transactionsSeen": {
          "type": "string",
          "format": "uint64",
          "title": "Total number of transactions seen in the block"
        },
        "expectedDifficulty": {
          "type": "string",
          "format": "uint64",
          "description": "This is the minimum required difficulty for the next transaction submitted on this block\nif it is possible to submit more transactions on this block, otherwise nil."
        },
        "hashFunction": {
          "type": "string",
          "title": "Hashing function used to calculate the block hash"
        },
        "difficulty": {
          "type": "string",
          "format": "uint64",
          "title": "Base difficulty for this block for when transactions seen \u003c tx_per_block"
        },
        "txPerBlock": {
          "type": "string",
          "format": "uint64",
          "title": "Number of transactions that can have their proof-of-work calculated with this block hash before\neither the difficulty increases, or no more transactions can use this block hash"
        },
        "increasingDifficulty": {
          "type": "boolean",
          "title": "Whether or not this block allows for increasing proof-of-work difficulty if the\ntx-per-block-hash limit has been reached"
        }
      },
      "title": "Proof of Work state for a given block"
    },
    "v1PoWStatistic": {
      "type": "object",
      "properties": {
        "blockStates": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PoWBlockState"
          },
          "title": "Block state for each block in scope for PoW calculation"
        },
        "bannedUntil": {
          "type": "string",
          "title": "PoW banned until timestamp as RFC3339Nano"
        },
        "numberOfPastBlocks": {
          "type": "string",
          "format": "uint64",
          "title": "Number of block behind the current block whose hash can be used for proof-of-work calculations"
        }
      },
      "title": "Proof of work statistics for a party"
    },
    "v1PositionResolution": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "distressed": {
          "type": "string",
          "format": "int64",
          "title": "Number of distressed traders"
        },
        "closed": {
          "type": "string",
          "format": "int64",
          "title": "Number of close outs"
        },
        "markPrice": {
          "type": "string",
          "title": "Mark price as a string representing a scaled price"
        }
      },
      "title": "Position resolution event contains information on distressed trades"
    },
    "v1PositionStateEvent": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "title": "Party ID for this position update"
        },
        "marketId": {
          "type": "string",
          "title": "Market ID for this position update"
        },
        "size": {
          "type": "string",
          "format": "int64",
          "title": "Current position"
        },
        "potentialBuys": {
          "type": "string",
          "format": "int64",
          "title": "Potential orders"
        },
        "potentialSells": {
          "type": "string",
          "format": "int64"
        },
        "vwBuyPrice": {
          "type": "string",
          "title": "Volume weighted prices"
        },
        "vwSellPrice": {
          "type": "string"
        }
      },
      "title": "Position state event contains the current position state for a single party in a single market"
    },
    "v1ProofOfWork": {
      "type": "object",
      "properties": {
        "tid": {
          "type": "string",
          "description": "Unique transaction identifier used to seed the proof-of-work hash."
        },
        "nonce": {
          "type": "string",
          "format": "uint64",
          "description": "Number which, combined with the transaction identifier, will produce a hash with the required number of leading zeros to be accepted by the network."
        }
      },
      "description": "Components needed for the network to verify proof-of-work."
    },
    "v1PropagateChainEventResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "title": "Success will be true if the event was accepted by the node,\n**Important** - success does not mean that the event is confirmed by consensus"
        }
      },
      "title": "Response for a new event sent by the blockchain queue to be propagated on Vega"
    },
    "v1Property": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the property."
        },
        "value": {
          "type": "string",
          "description": "Value of the property."
        }
      },
      "description": "Property describes one property of data spec with a key with its value."
    },
    "v1PropertyKey": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the property."
        },
        "type": {
          "$ref": "#/definitions/v1PropertyKeyType",
          "description": "Data type of the property."
        },
        "numberDecimalPlaces": {
          "type": "string",
          "format": "uint64",
          "title": "Optional decimal place to be be applied on the provided value\nvalid only for PropertyType of type DECIMAL and INTEGER"
        }
      },
      "description": "PropertyKey describes the property key contained in data source data."
    },
    "v1PropertyKeyType": {
      "type": "string",
      "enum": [
        "TYPE_UNSPECIFIED",
        "TYPE_EMPTY",
        "TYPE_INTEGER",
        "TYPE_STRING",
        "TYPE_BOOLEAN",
        "TYPE_DECIMAL",
        "TYPE_TIMESTAMP"
      ],
      "default": "TYPE_UNSPECIFIED",
      "description": "Type describes the data type of properties that are supported by the data source\nengine.\n\n - TYPE_UNSPECIFIED: The default value.\n - TYPE_EMPTY: Any type.\n - TYPE_INTEGER: Integer type.\n - TYPE_STRING: String type.\n - TYPE_BOOLEAN: Boolean type.\n - TYPE_DECIMAL: Any floating point decimal type.\n - TYPE_TIMESTAMP: Timestamp date type."
    },
    "v1ProposalSubmission": {
      "type": "object",
      "properties": {
        "reference": {
          "type": "string",
          "description": "Arbitrary human-readable reference identifying the proposal."
        },
        "terms": {
          "$ref": "#/definitions/vegaProposalTerms",
          "description": "Proposal terms containing the type and details of the proposal, as well as time spans for voting and enactment."
        },
        "rationale": {
          "$ref": "#/definitions/vegaProposalRationale",
          "description": "Rationale behind a proposal."
        }
      },
      "description": "Command that allows a token holder to submit a governance proposal that can be voted on by any other token holders, and eventually enacted on the Vega network.\nFor example this command can be used to propose a new market."
    },
    "v1ProtocolUpgradeDataNodeReady": {
      "type": "object",
      "properties": {
        "lastBlockHeight": {
          "type": "string",
          "format": "uint64"
        }
      },
      "title": "Event indicating the data node is ready for protocol upgrade"
    },
    "v1ProtocolUpgradeEvent": {
      "type": "object",
      "properties": {
        "upgradeBlockHeight": {
          "type": "string",
          "format": "uint64",
          "title": "Block height at which to perform the upgrade"
        },
        "vegaReleaseTag": {
          "type": "string",
          "title": "Release tag for the vega binary"
        },
        "approvers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Tendermint validators that have agreed to the upgrade"
        },
        "status": {
          "$ref": "#/definitions/v1ProtocolUpgradeProposalStatus",
          "title": "Status of the proposal"
        }
      }
    },
    "v1ProtocolUpgradeProposal": {
      "type": "object",
      "properties": {
        "upgradeBlockHeight": {
          "type": "string",
          "format": "uint64",
          "description": "Block height at which to perform the upgrade."
        },
        "vegaReleaseTag": {
          "type": "string",
          "description": "Release tag for the Vega binary."
        }
      },
      "description": "A validator command sent manually by a node operator to propose a protocol upgrade."
    },
    "v1ProtocolUpgradeProposalStatus": {
      "type": "string",
      "enum": [
        "PROTOCOL_UPGRADE_PROPOSAL_STATUS_UNSPECIFIED",
        "PROTOCOL_UPGRADE_PROPOSAL_STATUS_PENDING",
        "PROTOCOL_UPGRADE_PROPOSAL_STATUS_APPROVED",
        "PROTOCOL_UPGRADE_PROPOSAL_STATUS_REJECTED"
      ],
      "default": "PROTOCOL_UPGRADE_PROPOSAL_STATUS_UNSPECIFIED",
      "title": "- PROTOCOL_UPGRADE_PROPOSAL_STATUS_PENDING: The proposal is pending\n - PROTOCOL_UPGRADE_PROPOSAL_STATUS_APPROVED: The proposal is approved\n - PROTOCOL_UPGRADE_PROPOSAL_STATUS_REJECTED: The proposal is rejected"
    },
    "v1ProtocolUpgradeStarted": {
      "type": "object",
      "properties": {
        "lastBlockHeight": {
          "type": "string",
          "format": "uint64"
        }
      },
      "title": "Event indicating the core is starting a protocol upgrade"
    },
    "v1PubKey": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        }
      },
      "description": "PubKey is the public key that signed this data.\nDifferent public keys coming from different sources will be further separated."
    },
    "v1RecurringGovernanceTransfer": {
      "type": "object",
      "properties": {
        "startEpoch": {
          "type": "string",
          "format": "uint64"
        },
        "endEpoch": {
          "type": "string",
          "format": "uint64"
        },
        "dispatchStrategy": {
          "$ref": "#/definitions/vegaDispatchStrategy"
        },
        "factor": {
          "type": "string"
        }
      }
    },
    "v1RefereeJoinedReferralSet": {
      "type": "object",
      "properties": {
        "setId": {
          "type": "string",
          "description": "Unique ID of the referral set the referee joined."
        },
        "referee": {
          "type": "string",
          "description": "Party that joined the set."
        },
        "joinedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the party joined the set."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the party joined the set."
        }
      }
    },
    "v1RefereeJoinedTeam": {
      "type": "object",
      "properties": {
        "teamId": {
          "type": "string",
          "description": "The unique identifier of the team the referee joined."
        },
        "referee": {
          "type": "string",
          "description": "The party that joined the team."
        },
        "joinedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the party joined a team."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the party joined the team."
        }
      }
    },
    "v1RefereeStats": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "description": "Unique ID of the party."
        },
        "discountFactor": {
          "type": "string",
          "description": "deprecated."
        },
        "epochNotionalTakerVolume": {
          "type": "string",
          "title": "Current referee notional taker volume"
        },
        "discountFactors": {
          "$ref": "#/definitions/vegaDiscountFactors",
          "description": "Discount factors applied to the party."
        }
      }
    },
    "v1RefereeSwitchedTeam": {
      "type": "object",
      "properties": {
        "fromTeamId": {
          "type": "string",
          "description": "The unique identifier of the team the referee left."
        },
        "toTeamId": {
          "type": "string",
          "description": "The unique identifier of the team joined."
        },
        "referee": {
          "type": "string",
          "description": "The party that switched team."
        },
        "switchedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the party switched team. This time acts as\nthe joining time."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the party switched the team."
        }
      }
    },
    "v1ReferralProgramEnded": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "uint64",
          "description": "Program update version."
        },
        "id": {
          "type": "string",
          "description": "Unique ID of the referral program."
        },
        "endedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the referral program ended."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the referral program ended."
        }
      }
    },
    "v1ReferralProgramStarted": {
      "type": "object",
      "properties": {
        "program": {
          "$ref": "#/definitions/vegaReferralProgram",
          "description": "Referral program that has started."
        },
        "startedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the referral program started."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the referral program started."
        }
      }
    },
    "v1ReferralProgramUpdated": {
      "type": "object",
      "properties": {
        "program": {
          "$ref": "#/definitions/vegaReferralProgram",
          "description": "The updated referral program."
        },
        "updatedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the referral program was updated."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the referral program was updated."
        }
      }
    },
    "v1ReferralSetCreated": {
      "type": "object",
      "properties": {
        "setId": {
          "type": "string",
          "description": "Unique ID of the created set."
        },
        "referrer": {
          "type": "string",
          "description": "Party that created the set."
        },
        "createdAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the set was created."
        },
        "updatedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the set was updated."
        }
      }
    },
    "v1ReferralSetStatsUpdated": {
      "type": "object",
      "properties": {
        "setId": {
          "type": "string",
          "description": "Unique ID of the set."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the set's statistics are updated."
        },
        "referralSetRunningNotionalTakerVolume": {
          "type": "string",
          "description": "Running volume for the set based on the window length of the current\nreferral program."
        },
        "refereesStats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1RefereeStats"
          },
          "description": "Referees' statistics for that epoch."
        },
        "rewardFactor": {
          "type": "string",
          "title": "deprecated"
        },
        "rewardsMultiplier": {
          "type": "string",
          "description": "Rewards multiplier applied to the trades."
        },
        "rewardsFactorMultiplier": {
          "type": "string",
          "title": "deprecated"
        },
        "wasEligible": {
          "type": "boolean",
          "description": "Indicates if the referral set was eligible to be part of the referral program."
        },
        "referrerTakerVolume": {
          "type": "string",
          "title": "Taker volume of the referrer"
        },
        "rewardFactors": {
          "$ref": "#/definitions/vegaRewardFactors",
          "description": "Reward factor applied to the trades."
        },
        "rewardFactorsMultiplier": {
          "$ref": "#/definitions/vegaRewardFactors",
          "description": "Reward factors multiplier for the trades."
        }
      }
    },
    "v1ReferrerRewardsGenerated": {
      "type": "object",
      "properties": {
        "referrer": {
          "type": "string",
          "description": "Referrer party."
        },
        "generatedReward": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyAmount"
          },
          "description": "Amount of rewards generated per party."
        }
      },
      "title": "Rewards generated for referrers by each of their referees"
    },
    "v1RewardPayoutEvent": {
      "type": "object",
      "properties": {
        "party": {
          "type": "string"
        },
        "epochSeq": {
          "type": "string"
        },
        "asset": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        },
        "percentOfTotalReward": {
          "type": "string"
        },
        "timestamp": {
          "type": "string",
          "format": "int64"
        },
        "rewardType": {
          "type": "string"
        },
        "lockedUntilEpoch": {
          "type": "string"
        },
        "quantumAmount": {
          "type": "string"
        },
        "gameId": {
          "type": "string"
        }
      }
    },
    "v1SettleDistressed": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "partyId": {
          "type": "string",
          "title": "Party ID i.e. a party's public key for the event"
        },
        "margin": {
          "type": "string",
          "title": "Margin value as an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places"
        },
        "price": {
          "type": "string",
          "title": "Price as an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places"
        }
      },
      "title": "Settle distressed event contains information on distressed trading parties who are closed out"
    },
    "v1SettleMarket": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "price": {
          "type": "string",
          "title": "Price of settlement as a string"
        },
        "positionFactor": {
          "type": "string",
          "title": "Position factor - 10 ^ number of position decimal places"
        }
      },
      "title": "Settle market event to notify data node that a market has been settled\nso positions and PL can be updated accordingly"
    },
    "v1SettlePosition": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "Market ID for the event"
        },
        "partyId": {
          "type": "string",
          "title": "Party ID (public key) for the event"
        },
        "price": {
          "type": "string",
          "title": "Price of settlement as a string"
        },
        "tradeSettlements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1TradeSettlement"
          },
          "title": "A collection of 1 or more trade settlements"
        },
        "positionFactor": {
          "type": "string",
          "title": "Position factor - 10 ^ number of position decimal places"
        }
      },
      "title": "Settle position event contains position settlement information for a party"
    },
    "v1Signature": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "description": "Hex encoded bytes of the signature."
        },
        "algo": {
          "type": "string",
          "description": "Algorithm used to create the signature."
        },
        "version": {
          "type": "integer",
          "format": "int64",
          "description": "Version of the algorithm used to create the signature."
        }
      },
      "description": "Signature definition that allows the network to authenticate external data."
    },
    "v1Signer": {
      "type": "object",
      "properties": {
        "pubKey": {
          "$ref": "#/definitions/v1PubKey",
          "description": "List of authorized public keys that signed the data for this\nsource. All the public keys in the data should be contained in these\npublic keys."
        },
        "ethAddress": {
          "$ref": "#/definitions/v1ETHAddress",
          "description": "In case of an open oracle - Ethereum address will be submitted."
        }
      }
    },
    "v1SpamStatistic": {
      "type": "object",
      "properties": {
        "countForEpoch": {
          "type": "string",
          "format": "uint64",
          "title": "Current transaction count received from the party during this epoch for this policy"
        },
        "maxForEpoch": {
          "type": "string",
          "format": "uint64",
          "title": "Maximum number of transactions allowed for this policy in an epoch"
        },
        "bannedUntil": {
          "type": "string",
          "title": "If blocked the timestamp when the party will be unblocked as RFC3339Nano"
        },
        "minTokensRequired": {
          "type": "string",
          "title": "Effective minimum number of tokens required to submit a transaction of this type"
        }
      },
      "title": "Statistics for a given spam policy"
    },
    "v1SpamStatistics": {
      "type": "object",
      "properties": {
        "proposals": {
          "$ref": "#/definitions/v1SpamStatistic",
          "description": "Statistics for proposal transactions made by the party."
        },
        "delegations": {
          "$ref": "#/definitions/v1SpamStatistic",
          "description": "Statistics for delegation transactions made by the party."
        },
        "transfers": {
          "$ref": "#/definitions/v1SpamStatistic",
          "description": "Statistics for transfer transactions made by the party."
        },
        "nodeAnnouncements": {
          "$ref": "#/definitions/v1SpamStatistic",
          "description": "Statistics for node announcement transactions made by the party."
        },
        "votes": {
          "$ref": "#/definitions/v1VoteSpamStatistics",
          "description": "Statistics for proposal votes made by the party."
        },
        "pow": {
          "$ref": "#/definitions/v1PoWStatistic",
          "description": "Statistics for proof of work difficulty observed per block for the party."
        },
        "issueSignatures": {
          "$ref": "#/definitions/v1SpamStatistic",
          "description": "Statistics for multisig signatures issued for the party."
        },
        "epochSeq": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch in which these statistics apply to."
        },
        "createReferralSet": {
          "$ref": "#/definitions/v1SpamStatistic",
          "description": "Statistics for transactions made by the party to create referral sets."
        },
        "updateReferralSet": {
          "$ref": "#/definitions/v1SpamStatistic",
          "description": "Statistics for transactions made by the party to update referral sets."
        },
        "applyReferralCode": {
          "$ref": "#/definitions/v1SpamStatistic",
          "description": "Statistics for transactions made by the party to apply referral codes."
        }
      },
      "title": "Complete spam statistics captured for a given party"
    },
    "v1StakeLinking": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "title": "Internal ID for this staking event"
        },
        "type": {
          "$ref": "#/definitions/v1StakeLinkingType",
          "description": "Stake linking event type."
        },
        "ts": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds of when the event was emitted by Ethereum."
        },
        "party": {
          "type": "string",
          "description": "Party to whom the event is directed at."
        },
        "amount": {
          "type": "string",
          "description": "Amount of stake deposited or removed."
        },
        "status": {
          "$ref": "#/definitions/v1StakeLinkingStatus",
          "description": "Status of the event."
        },
        "finalizedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time at which the Vega network finalised the state of the event."
        },
        "txHash": {
          "type": "string",
          "description": "Hash of the transaction in which the event happened."
        },
        "blockHeight": {
          "type": "string",
          "format": "uint64",
          "description": "Block when the event happened."
        },
        "blockTime": {
          "type": "string",
          "format": "int64",
          "description": "Block time."
        },
        "logIndex": {
          "type": "string",
          "format": "uint64",
          "description": "Log index."
        },
        "ethereumAddress": {
          "type": "string",
          "description": "Ethereum address from which the stake link was initiated."
        }
      },
      "title": "StakeLinking - an event notifying of stake being deposited or removed for a given party\nThese events are emitted for every Staking deposit or removed accepted by the network"
    },
    "v1StakeLinkingStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_PENDING",
        "STATUS_ACCEPTED",
        "STATUS_REJECTED"
      ],
      "default": "STATUS_UNSPECIFIED",
      "title": "- STATUS_UNSPECIFIED: Default value\n - STATUS_PENDING: Indicates an event waiting for confirmation from the Vega network\n - STATUS_ACCEPTED: Indicates an event accepted by the Vega network\n - STATUS_REJECTED: Indicates an event rejected by the Vega network"
    },
    "v1StakeLinkingType": {
      "type": "string",
      "enum": [
        "TYPE_UNSPECIFIED",
        "TYPE_LINK",
        "TYPE_UNLINK"
      ],
      "default": "TYPE_UNSPECIFIED",
      "title": "- TYPE_UNSPECIFIED: Default value\n - TYPE_LINK: Indicate of a stake deposit instruction\n - TYPE_UNLINK: Indicate of a stake remove instruction"
    },
    "v1StateVar": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "eventId": {
          "type": "string"
        },
        "state": {
          "type": "string"
        }
      },
      "title": "StateVar event updates on state changes in state variable consensus"
    },
    "v1Statistics": {
      "type": "object",
      "properties": {
        "blockHeight": {
          "type": "string",
          "format": "uint64",
          "title": "Current block height as reported by the Vega blockchain"
        },
        "backlogLength": {
          "type": "string",
          "format": "uint64",
          "title": "Current backlog length i.e., number of transactions, that are waiting to be included in a block"
        },
        "totalPeers": {
          "type": "string",
          "format": "uint64",
          "title": "Total number of connected peers to this node"
        },
        "genesisTime": {
          "type": "string",
          "title": "Genesis block date and time formatted in ISO-8601 datetime format with nanosecond precision"
        },
        "currentTime": {
          "type": "string",
          "title": "Current system date and time formatted in ISO-8601 datetime format with nanosecond precision"
        },
        "vegaTime": {
          "type": "string",
          "title": "Current Vega date and time formatted in ISO-8601 datetime format with nanosecond precision"
        },
        "status": {
          "$ref": "#/definitions/vegaChainStatus",
          "title": "Status of the connection to the Vega blockchain"
        },
        "txPerBlock": {
          "type": "string",
          "format": "uint64",
          "title": "Transactions per block"
        },
        "averageTxBytes": {
          "type": "string",
          "format": "uint64",
          "title": "Average transaction size in bytes"
        },
        "averageOrdersPerBlock": {
          "type": "string",
          "format": "uint64",
          "title": "Average orders per block"
        },
        "tradesPerSecond": {
          "type": "string",
          "format": "uint64",
          "title": "Trades emitted per second"
        },
        "ordersPerSecond": {
          "type": "string",
          "format": "uint64",
          "title": "Orders processed per second"
        },
        "totalMarkets": {
          "type": "string",
          "format": "uint64",
          "title": "Total markets on this Vega network"
        },
        "totalAmendOrder": {
          "type": "string",
          "format": "uint64",
          "title": "Total number of order amendments since genesis across all markets"
        },
        "totalCancelOrder": {
          "type": "string",
          "format": "uint64",
          "title": "Total number of order cancellations since genesis across all markets"
        },
        "totalCreateOrder": {
          "type": "string",
          "format": "uint64",
          "title": "Total number of order submissions since genesis across all markets"
        },
        "totalOrders": {
          "type": "string",
          "format": "uint64",
          "title": "Total number of orders processed since genesis across all markets"
        },
        "totalTrades": {
          "type": "string",
          "format": "uint64",
          "title": "Total number of trades emitted since genesis across all markets"
        },
        "orderSubscriptions": {
          "type": "integer",
          "format": "int64",
          "title": "Current number of stream subscribers to order data"
        },
        "tradeSubscriptions": {
          "type": "integer",
          "format": "int64",
          "title": "Current number of stream subscribers to trade data"
        },
        "candleSubscriptions": {
          "type": "integer",
          "format": "int64",
          "title": "Current number of stream subscribers to candlestick data"
        },
        "marketDepthSubscriptions": {
          "type": "integer",
          "format": "int64",
          "title": "Current number of stream subscribers to market depth data"
        },
        "positionsSubscriptions": {
          "type": "integer",
          "format": "int64",
          "title": "Current number of stream subscribers to positions data"
        },
        "accountSubscriptions": {
          "type": "integer",
          "format": "int64",
          "title": "Current number of stream subscribers to account data"
        },
        "marketDataSubscriptions": {
          "type": "integer",
          "format": "int64",
          "title": "Current number of stream subscribers to market data"
        },
        "appVersionHash": {
          "type": "string",
          "title": "Version hash of the Vega node software"
        },
        "appVersion": {
          "type": "string",
          "title": "Version of the Vega node software"
        },
        "chainVersion": {
          "type": "string",
          "title": "Version of the underlying Vega blockchain"
        },
        "blockDuration": {
          "type": "string",
          "format": "uint64",
          "title": "Current block duration, in nanoseconds"
        },
        "uptime": {
          "type": "string",
          "title": "Total uptime for this node formatted in ISO-8601 datetime format with nanosecond precision"
        },
        "chainId": {
          "type": "string",
          "title": "Unique ID for the underlying Vega blockchain"
        },
        "marketDepthUpdatesSubscriptions": {
          "type": "integer",
          "format": "int64",
          "title": "Current number of stream subscribers to market depth update data"
        },
        "blockHash": {
          "type": "string",
          "title": "Current block hash"
        },
        "epochSeq": {
          "type": "string",
          "format": "uint64",
          "title": "Current epoch"
        },
        "epochStartTime": {
          "type": "string",
          "title": "Epoch start time"
        },
        "epochExpiryTime": {
          "type": "string",
          "title": "Epoch expected end time"
        },
        "eventCount": {
          "type": "string",
          "format": "uint64",
          "title": "Number of events in the last block"
        },
        "eventsPerSecond": {
          "type": "string",
          "format": "uint64",
          "title": "Rate of events per second in the last block"
        }
      },
      "title": "Vega domain specific statistics as reported by the node the caller is connected to"
    },
    "v1StatisticsResponse": {
      "type": "object",
      "properties": {
        "statistics": {
          "$ref": "#/definitions/v1Statistics"
        }
      },
      "title": "Response containing statistics about the Vega network"
    },
    "v1StopOrderEvent": {
      "type": "object",
      "properties": {
        "submission": {
          "$ref": "#/definitions/v1OrderSubmission"
        },
        "stopOrder": {
          "$ref": "#/definitions/vegaStopOrder"
        }
      }
    },
    "v1StopOrderSetup": {
      "type": "object",
      "properties": {
        "orderSubmission": {
          "$ref": "#/definitions/v1OrderSubmission",
          "description": "Order to be submitted once the trigger is breached."
        },
        "expiresAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire."
        },
        "expiryStrategy": {
          "$ref": "#/definitions/StopOrderExpiryStrategy",
          "description": "Strategy to adopt if the expiry time is reached."
        },
        "sizeOverrideSetting": {
          "$ref": "#/definitions/StopOrderSizeOverrideSetting",
          "title": "Indicates if this order is linked to an order or position to derive the order size"
        },
        "sizeOverrideValue": {
          "$ref": "#/definitions/StopOrderSizeOverrideValue",
          "title": "If this order is linked to a position, provide an optional scaling factor"
        },
        "price": {
          "type": "string",
          "description": "Order will be submitted if the last traded price on the market breaches the given price."
        },
        "trailingPercentOffset": {
          "type": "string",
          "description": "Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted."
        }
      },
      "description": "Price and expiry configuration for a stop order."
    },
    "v1StopOrdersCancellation": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled."
        },
        "stopOrderId": {
          "type": "string",
          "description": "Restrict cancellations to a stop order with the given ID. If set, then a market ID must also be provided."
        }
      },
      "description": "A command that instructs the network to cancel untriggered stop orders that were submitted by the sender of this transaction.\nIf any cancelled stop order is part of an OCO, both stop orders will be cancelled.\nIt is not possible to cancel another party's stop orders with this command."
    },
    "v1StopOrdersSubmission": {
      "type": "object",
      "properties": {
        "risesAbove": {
          "$ref": "#/definitions/v1StopOrderSetup",
          "description": "Stop order that will be triggered if the price rises above a given trigger price."
        },
        "fallsBelow": {
          "$ref": "#/definitions/v1StopOrderSetup",
          "description": "Stop order that will be triggered if the price falls below a given trigger price."
        }
      },
      "description": "A command that allows a party to submit a stop order for a given market.\nA stop order is a normal order that remains off the order book and is only submitted if a given trigger is breached from a particular direction.\nIf both rises-above and falls-below are configured, then if one is triggered the other will be cancelled (OCO)."
    },
    "v1SubmitAMM": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market ID for which to create an AMM."
        },
        "commitmentAmount": {
          "type": "string",
          "description": "Amount to be committed to the AMM."
        },
        "slippageTolerance": {
          "type": "string",
          "title": "Slippage tolerance used for rebasing the AMM if its base price crosses with existing order"
        },
        "concentratedLiquidityParameters": {
          "$ref": "#/definitions/v1SubmitAMMConcentratedLiquidityParameters",
          "description": "Concentrated liquidity parameters defining the shape of the AMM's volume curves."
        },
        "proposedFee": {
          "type": "string",
          "description": "Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market."
        }
      },
      "description": "Command to create an automated market maker for a given market."
    },
    "v1SubmitAMMConcentratedLiquidityParameters": {
      "type": "object",
      "properties": {
        "upperBound": {
          "type": "string",
          "description": "Price at which the AMM will stop quoting sell volume. If not supplied the AMM will never hold a short position."
        },
        "lowerBound": {
          "type": "string",
          "description": "Price at which the AMM will stop quoting buy volume. If not supplied the AMM will never hold a long position."
        },
        "base": {
          "type": "string",
          "description": "Price that the AMM will quote as its \"fair price\" when its position is zero."
        },
        "leverageAtUpperBound": {
          "type": "string",
          "description": "Leverage at upper bound. If not set the markets risk-factors will be used to calculate leverage."
        },
        "leverageAtLowerBound": {
          "type": "string",
          "description": "Leverage at lower bound. If not set the markets risk-factors will be used to calculate leverage."
        }
      },
      "description": "Liquidity parameters that define the size and range of the AMM's tradeable volume."
    },
    "v1SubmitRawTransactionRequestType": {
      "type": "string",
      "enum": [
        "TYPE_UNSPECIFIED",
        "TYPE_ASYNC",
        "TYPE_SYNC",
        "TYPE_COMMIT"
      ],
      "default": "TYPE_UNSPECIFIED",
      "description": "- TYPE_ASYNC: Transaction will be submitted without waiting for response\n - TYPE_SYNC: Transaction will be submitted, and blocking until the\ntendermint mempool returns a response\n - TYPE_COMMIT: Transaction will be submitted, and blocking until the tendermint\nnetwork has committed it into a block. Used only for debugging,\nnot for submitting transactions",
      "title": "Blockchain transaction type"
    },
    "v1SubmitRawTransactionResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether or not the transaction was validated and submitted to the chain's mempool."
        },
        "txHash": {
          "type": "string",
          "description": "Hash of the transaction, which can be used to identify the transaction in a node's event stream."
        },
        "code": {
          "type": "integer",
          "format": "int64",
          "description": "Error code to indicate the category of failure if the transaction was not successfully submitted."
        },
        "data": {
          "type": "string",
          "description": "Further details for why the transaction was not successfully submitted."
        },
        "log": {
          "type": "string",
          "description": "Further details for the underlying consensus layer of the result of the transaction."
        },
        "height": {
          "type": "string",
          "format": "int64",
          "description": "Unused."
        }
      },
      "title": "Response for submitting a version agnostic transaction on Vega"
    },
    "v1SubmitTransactionRequestType": {
      "type": "string",
      "enum": [
        "TYPE_UNSPECIFIED",
        "TYPE_ASYNC",
        "TYPE_SYNC",
        "TYPE_COMMIT"
      ],
      "default": "TYPE_UNSPECIFIED",
      "description": "Blockchain transaction type.\n\n - TYPE_ASYNC: Transaction will be submitted without waiting for a response.\n - TYPE_SYNC: Transaction will be submitted, and blocking until the mempool returns a response.\n - TYPE_COMMIT: Transaction will be submitted, and blocking until the network has committed it into a block.\nUsed only for debugging local network, not for submitting transactions."
    },
    "v1SubmitTransactionResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether or not the transaction was validated and submitted to the chain's mempool."
        },
        "txHash": {
          "type": "string",
          "description": "Hash of the transaction, which can be used to identify the transaction in a node's event stream."
        },
        "code": {
          "type": "integer",
          "format": "int64",
          "description": "Error code to indicate the category of failure if the transaction was not successfully submitted."
        },
        "data": {
          "type": "string",
          "description": "Further details for why the transaction was not successfully submitted."
        },
        "log": {
          "type": "string",
          "description": "Further details for the underlying consensus layer of the result of the transaction."
        },
        "height": {
          "type": "string",
          "format": "int64",
          "description": "Unused."
        }
      },
      "description": "Response for submitting a transaction on the network."
    },
    "v1TeamCreated": {
      "type": "object",
      "properties": {
        "teamId": {
          "type": "string",
          "description": "The unique identifier of the created team."
        },
        "referrer": {
          "type": "string",
          "description": "The party that created the team."
        },
        "name": {
          "type": "string",
          "description": "Name of the team."
        },
        "teamUrl": {
          "type": "string",
          "description": "Link to the team's homepage."
        },
        "avatarUrl": {
          "type": "string",
          "description": "Link to an image of the team's avatar."
        },
        "createdAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the team is created."
        },
        "closed": {
          "type": "boolean",
          "description": "Tells if a party can join the team or not."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the team was created."
        },
        "allowList": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of public keys that are allowed to join the team."
        }
      }
    },
    "v1TeamMemberStats": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "description": "The party ID of the team member."
        },
        "notionalVolume": {
          "type": "string",
          "description": "Team members' notional volume for the epoch."
        }
      }
    },
    "v1TeamStats": {
      "type": "object",
      "properties": {
        "teamId": {
          "type": "string",
          "description": "The unique identifier of the team."
        },
        "membersStats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1TeamMemberStats"
          },
          "description": "Statistics for each team member."
        }
      }
    },
    "v1TeamUpdated": {
      "type": "object",
      "properties": {
        "teamId": {
          "type": "string",
          "description": "The unique identifier for the updated team."
        },
        "name": {
          "type": "string",
          "description": "Name of the team."
        },
        "teamUrl": {
          "type": "string",
          "description": "Link to the team's homepage."
        },
        "avatarUrl": {
          "type": "string",
          "description": "Link to an image of the team's avatar."
        },
        "closed": {
          "type": "boolean",
          "description": "Tells if a party can join the team or not."
        },
        "allowList": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of public keys that are allowed to join the team."
        }
      }
    },
    "v1TeamsStatsUpdated": {
      "type": "object",
      "properties": {
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the statistics are updated."
        },
        "stats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1TeamStats"
          },
          "description": "All teams' stats."
        }
      },
      "description": "Stats for all teams."
    },
    "v1TimeUpdate": {
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "int64",
          "title": "Timestamp containing latest update from Vega blockchain aka Vega-time"
        }
      },
      "title": "Time update event contains the latest time update from Vega blockchain and indicates the start of a new block"
    },
    "v1TimeWeightedNotionalPositionUpdated": {
      "type": "object",
      "properties": {
        "epochSeq": {
          "type": "string",
          "format": "uint64",
          "title": "Epoch the time weighted notional position is relevant for"
        },
        "asset": {
          "type": "string",
          "description": "Asset ID for the position's settlement asset."
        },
        "party": {
          "type": "string",
          "title": "Party holding the position"
        },
        "gameId": {
          "type": "string",
          "description": "Game ID the time weighted notional position is calculated for."
        },
        "timeWeightedNotionalPosition": {
          "type": "string",
          "description": "Time weighted notional position from the end of the most recently completed epoch."
        }
      },
      "description": "Time weighted notional position update for the current epoch.\nThe time weighted notional position is used to determine whether\na party is eligible for receiving rewards at the end of an epoch.\nThese updates are provided to facilitate knowing whether or not a party\nis on track to qualify."
    },
    "v1TradeSettlement": {
      "type": "object",
      "properties": {
        "size": {
          "type": "string",
          "format": "int64",
          "title": "Size of trade settlement"
        },
        "price": {
          "type": "string",
          "title": "Price of settlement as string (in asset decimals)"
        },
        "marketPrice": {
          "type": "string",
          "title": "Price of settlement as a string (in market decimals)"
        }
      },
      "title": "Trade settlement is part of the settle position event"
    },
    "v1Transaction": {
      "type": "object",
      "properties": {
        "inputData": {
          "type": "string",
          "format": "byte",
          "description": "Protobuf message of type `InputData` marshalled into bytes. If the transaction version is V3 or higher then this bytes\nstring must be prepended with `chain_id_as_byes + \\0`."
        },
        "signature": {
          "$ref": "#/definitions/v1Signature",
          "description": "Signature of the input data field, signed by the sender of this transaction."
        },
        "address": {
          "type": "string",
          "description": "Hex-encoded address of the sender. Not supported yet."
        },
        "pubKey": {
          "type": "string",
          "description": "Hex-encoded public key of the sender."
        },
        "version": {
          "$ref": "#/definitions/v1TxVersion",
          "description": "Version of the transaction."
        },
        "pow": {
          "$ref": "#/definitions/v1ProofOfWork",
          "description": "Proof-of-work containing the random transaction ID used by the client and the nonce."
        }
      },
      "description": "Transaction containing a command that can be sent to instruct the network to execute an action.\nA transaction contains a byte string representation of the input data which must then be signed, with the signature added to the transaction."
    },
    "v1TransactionResult": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "title": "Unique party ID for the related party"
        },
        "status": {
          "type": "boolean",
          "description": "Status of the transaction, if it succeeded or an error was raised."
        },
        "hash": {
          "type": "string",
          "title": "Hash of the transaction"
        },
        "statusDetail": {
          "$ref": "#/definitions/v1TransactionResultStatus",
          "description": "Status of the transaction.\nBackward compatible with previous events,\nas this field will default to UNSPECIFIED."
        },
        "orderSubmission": {
          "$ref": "#/definitions/v1OrderSubmission"
        },
        "orderAmendment": {
          "$ref": "#/definitions/v1OrderAmendment"
        },
        "orderCancellation": {
          "$ref": "#/definitions/v1OrderCancellation"
        },
        "proposal": {
          "$ref": "#/definitions/v1ProposalSubmission"
        },
        "voteSubmission": {
          "$ref": "#/definitions/v1VoteSubmission"
        },
        "liquidityProvisionSubmission": {
          "$ref": "#/definitions/v1LiquidityProvisionSubmission"
        },
        "withdrawSubmission": {
          "$ref": "#/definitions/v1WithdrawSubmission"
        },
        "delegateSubmission": {
          "$ref": "#/definitions/v1DelegateSubmission"
        },
        "undelegateSubmission": {
          "$ref": "#/definitions/v1UndelegateSubmission"
        },
        "liquidityProvisionCancellation": {
          "$ref": "#/definitions/v1LiquidityProvisionCancellation"
        },
        "liquidityProvisionAmendment": {
          "$ref": "#/definitions/v1LiquidityProvisionAmendment"
        },
        "transfer": {
          "$ref": "#/definitions/vegacommandsv1Transfer"
        },
        "cancelTransfer": {
          "$ref": "#/definitions/commandsv1CancelTransfer"
        },
        "announceNode": {
          "$ref": "#/definitions/v1AnnounceNode"
        },
        "oracleDataSubmission": {
          "$ref": "#/definitions/v1OracleDataSubmission"
        },
        "protocolUpgradeProposal": {
          "$ref": "#/definitions/v1ProtocolUpgradeProposal"
        },
        "issueSignatures": {
          "$ref": "#/definitions/v1IssueSignatures"
        },
        "batchMarketInstructions": {
          "$ref": "#/definitions/v1BatchMarketInstructions"
        },
        "keyRotateSubmission": {
          "$ref": "#/definitions/v1KeyRotateSubmission"
        },
        "ethereumKeyRotateSubmission": {
          "$ref": "#/definitions/v1EthereumKeyRotateSubmission"
        },
        "stopOrdersSubmission": {
          "$ref": "#/definitions/v1StopOrdersSubmission"
        },
        "stopOrdersCancellation": {
          "$ref": "#/definitions/v1StopOrdersCancellation"
        },
        "createReferralSet": {
          "$ref": "#/definitions/v1CreateReferralSet"
        },
        "updateReferralSet": {
          "$ref": "#/definitions/v1UpdateReferralSet"
        },
        "applyReferralCode": {
          "$ref": "#/definitions/v1ApplyReferralCode"
        },
        "updateMarginMode": {
          "$ref": "#/definitions/v1UpdateMarginMode"
        },
        "joinTeam": {
          "$ref": "#/definitions/v1JoinTeam"
        },
        "batchProposal": {
          "$ref": "#/definitions/v1BatchProposalSubmission"
        },
        "updatePartyProfile": {
          "$ref": "#/definitions/v1UpdatePartyProfile"
        },
        "submitAmm": {
          "$ref": "#/definitions/v1SubmitAMM"
        },
        "amendAmm": {
          "$ref": "#/definitions/v1AmendAMM"
        },
        "cancelAmm": {
          "$ref": "#/definitions/v1CancelAMM"
        },
        "success": {
          "$ref": "#/definitions/TransactionResultSuccessDetails"
        },
        "failure": {
          "$ref": "#/definitions/TransactionResultFailureDetails"
        }
      }
    },
    "v1TransactionResultStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_SUCCESS",
        "STATUS_PARTIAL_SUCCESS",
        "STATUS_FAILURE"
      ],
      "default": "STATUS_UNSPECIFIED",
      "description": " - STATUS_UNSPECIFIED: Default value, always invalid\n - STATUS_SUCCESS: The transaction succeeded.\n - STATUS_PARTIAL_SUCCESS: The transaction partially succeeded.\n - STATUS_FAILURE: The transaction's final state is failure."
    },
    "v1TransferFees": {
      "type": "object",
      "properties": {
        "transferId": {
          "type": "string",
          "description": "Transfer that triggered the collection of fees."
        },
        "amount": {
          "type": "string",
          "description": "Amount of fees paid."
        },
        "epoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch when the transfer was dispatched, and fees were paid."
        },
        "discountApplied": {
          "type": "string",
          "description": "Amount that was subtracted from the transfer fee based on available discounts."
        }
      }
    },
    "v1TransferFeesDiscount": {
      "type": "object",
      "properties": {
        "party": {
          "type": "string",
          "description": "Party that the transfer fee discount applies to."
        },
        "asset": {
          "type": "string",
          "description": "Asset that the transfer fee discount is relevant to."
        },
        "amount": {
          "type": "string",
          "description": "Amount that the transfer fee was discounted by."
        },
        "epoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch in which the discount was first available."
        }
      }
    },
    "v1TransferStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_PENDING",
        "STATUS_DONE",
        "STATUS_REJECTED",
        "STATUS_STOPPED",
        "STATUS_CANCELLED"
      ],
      "default": "STATUS_UNSPECIFIED",
      "title": "- STATUS_UNSPECIFIED: Default value\n - STATUS_PENDING: Indicates a transfer still being processed\n - STATUS_DONE: Indicates a transfer accepted by the Vega network\n - STATUS_REJECTED: Indicates a transfer rejected by the Vega network\n - STATUS_STOPPED: Indicates a transfer stopped by the Vega network\ne.g: no funds left to cover the transfer\n - STATUS_CANCELLED: Indicates a transfer cancelled by the user"
    },
    "v1TxErrorEvent": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "title": "Unique party ID for the related party"
        },
        "errMsg": {
          "type": "string",
          "title": "Error message describing what went wrong"
        },
        "orderSubmission": {
          "$ref": "#/definitions/v1OrderSubmission"
        },
        "orderAmendment": {
          "$ref": "#/definitions/v1OrderAmendment"
        },
        "orderCancellation": {
          "$ref": "#/definitions/v1OrderCancellation"
        },
        "proposal": {
          "$ref": "#/definitions/v1ProposalSubmission"
        },
        "voteSubmission": {
          "$ref": "#/definitions/v1VoteSubmission"
        },
        "liquidityProvisionSubmission": {
          "$ref": "#/definitions/v1LiquidityProvisionSubmission"
        },
        "withdrawSubmission": {
          "$ref": "#/definitions/v1WithdrawSubmission"
        },
        "delegateSubmission": {
          "$ref": "#/definitions/v1DelegateSubmission"
        },
        "undelegateSubmission": {
          "$ref": "#/definitions/v1UndelegateSubmission"
        },
        "liquidityProvisionCancellation": {
          "$ref": "#/definitions/v1LiquidityProvisionCancellation"
        },
        "liquidityProvisionAmendment": {
          "$ref": "#/definitions/v1LiquidityProvisionAmendment"
        },
        "transfer": {
          "$ref": "#/definitions/vegacommandsv1Transfer"
        },
        "cancelTransfer": {
          "$ref": "#/definitions/commandsv1CancelTransfer"
        },
        "announceNode": {
          "$ref": "#/definitions/v1AnnounceNode"
        },
        "oracleDataSubmission": {
          "$ref": "#/definitions/v1OracleDataSubmission"
        },
        "protocolUpgradeProposal": {
          "$ref": "#/definitions/v1ProtocolUpgradeProposal"
        },
        "issueSignatures": {
          "$ref": "#/definitions/v1IssueSignatures"
        },
        "batchMarketInstructions": {
          "$ref": "#/definitions/v1BatchMarketInstructions"
        }
      }
    },
    "v1TxVersion": {
      "type": "string",
      "enum": [
        "TX_VERSION_UNSPECIFIED",
        "TX_VERSION_V2",
        "TX_VERSION_V3"
      ],
      "default": "TX_VERSION_UNSPECIFIED",
      "description": "Transaction versions to maintain backwards compatibility of transaction formats.\n\n - TX_VERSION_UNSPECIFIED: Transaction version is unspecified.\n - TX_VERSION_V2: Transaction requires the addition of a proof-of-work calculation.\n - TX_VERSION_V3: Transaction input data contains a prepended chain ID to prevent use of a single transaction across multiple networks."
    },
    "v1UndelegateSubmission": {
      "type": "object",
      "properties": {
        "nodeId": {
          "type": "string",
          "description": "Node ID to undelegate stake from."
        },
        "amount": {
          "type": "string",
          "description": "Amount to undelegate, as an unsigned integer scaled to the governance asset's decimal places.\nIf not set, then all delegations to the given validator node will be removed."
        },
        "method": {
          "$ref": "#/definitions/v1UndelegateSubmissionMethod",
          "description": "Method of delegation."
        }
      },
      "description": "Command to allow a token holder to instruct the network to remove their delegated stake from a given validator node."
    },
    "v1UndelegateSubmissionMethod": {
      "type": "string",
      "enum": [
        "METHOD_UNSPECIFIED",
        "METHOD_NOW",
        "METHOD_AT_END_OF_EPOCH"
      ],
      "default": "METHOD_UNSPECIFIED",
      "description": " - METHOD_NOW: Undelegate straight away, losing all rewards for the current epoch.\n - METHOD_AT_END_OF_EPOCH: Undelegate at the end of an epoch, retaining all rewards for the current epoch."
    },
    "v1UpdateMarginMode": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market to change margin mode for."
        },
        "mode": {
          "$ref": "#/definitions/UpdateMarginModeMode",
          "description": "Margin mode to use."
        },
        "marginFactor": {
          "type": "string",
          "title": "Margin factor to use for margin in isolated mode. It is a multiplier that defines how much margin needs to be set aside"
        }
      }
    },
    "v1UpdatePartyProfile": {
      "type": "object",
      "properties": {
        "alias": {
          "type": "string",
          "description": "Alias given to the party. It must be unique network-wide."
        },
        "metadata": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaMetadata"
          },
          "description": "Freeform data to associate to the party.\nSupport a maximum of 10 entries."
        }
      },
      "description": "Command to associate metadata to a public key, known as a party ID.\nPartial update is not supported, meaning previous values must be included in\nthe update, otherwise they are removed."
    },
    "v1UpdateReferralSet": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "ID of the referral set to update."
        },
        "isTeam": {
          "type": "boolean",
          "description": "Whether or not the referral set should be considered a team that can participate in team games on the network."
        },
        "team": {
          "$ref": "#/definitions/v1UpdateReferralSetTeam",
          "description": "Team details, if the referral set is to be considered a team."
        }
      },
      "description": "A command that allows the referrer of a referral set to update team details for a referral set.\nAny field that is left unset or has a default value indicates that this field on the original referral set will be left unchanged."
    },
    "v1UpdateReferralSetTeam": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "New name of the team."
        },
        "teamUrl": {
          "type": "string",
          "description": "New link to the team's homepage."
        },
        "avatarUrl": {
          "type": "string",
          "description": "New link to an avatar for the team."
        },
        "closed": {
          "type": "boolean",
          "description": "Whether or not the team is closed to new party members. When closed, only parties specified in the allow list can\njoin the team."
        },
        "allowList": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of public keys that are allowed to join the team.\nOnly applicable to closed teams. Removing a party from the allow list does not remove\nthe party from the team."
        }
      }
    },
    "v1ValidatorRankingEvent": {
      "type": "object",
      "properties": {
        "nodeId": {
          "type": "string"
        },
        "stakeScore": {
          "type": "string",
          "title": "Stake based score - no anti-whaling"
        },
        "performanceScore": {
          "type": "string",
          "title": "Performance base score"
        },
        "rankingScore": {
          "type": "string",
          "title": "Final score"
        },
        "previousStatus": {
          "type": "string",
          "title": "Status of the validator in the previous epoch"
        },
        "nextStatus": {
          "type": "string",
          "title": "Status of the validator in the next epoch"
        },
        "epochSeq": {
          "type": "string",
          "title": "Epoch seq for which the status is valid"
        },
        "tmVotingPower": {
          "type": "integer",
          "format": "int64",
          "title": "Tendermint voting power of the validator"
        }
      },
      "title": "Event that explains the status of the validator for the coming epoch"
    },
    "v1ValidatorScoreEvent": {
      "type": "object",
      "properties": {
        "nodeId": {
          "type": "string"
        },
        "epochSeq": {
          "type": "string"
        },
        "validatorScore": {
          "type": "string"
        },
        "normalisedScore": {
          "type": "string"
        },
        "validatorPerformance": {
          "type": "string"
        },
        "rawValidatorScore": {
          "type": "string"
        },
        "validatorStatus": {
          "type": "string"
        },
        "multisigScore": {
          "type": "string"
        }
      },
      "title": "ValidatorScoreEvent is the score a validator gets for a given epoch"
    },
    "v1ValidatorUpdate": {
      "type": "object",
      "properties": {
        "nodeId": {
          "type": "string",
          "title": "Node ID of the validator node"
        },
        "vegaPubKey": {
          "type": "string",
          "title": "Vega public key of validator node"
        },
        "ethereumAddress": {
          "type": "string",
          "title": "Ethereum public key of validator node"
        },
        "tmPubKey": {
          "type": "string",
          "title": "Public key of Tendermint"
        },
        "infoUrl": {
          "type": "string",
          "title": "URL with more info on the node"
        },
        "country": {
          "type": "string",
          "title": "Country code (ISO 3166-1 alpha-2) for the location of the node"
        },
        "name": {
          "type": "string",
          "title": "Name of the validator"
        },
        "avatarUrl": {
          "type": "string",
          "title": "AvatarURL of the validator"
        },
        "vegaPubKeyIndex": {
          "type": "integer",
          "format": "int64",
          "title": "Vega public key derivation index"
        },
        "added": {
          "type": "boolean",
          "title": "Flag indicating if the validator has been added to or removed from vega"
        },
        "fromEpoch": {
          "type": "string",
          "format": "uint64",
          "title": "Epoch in which the announced pending node will start participating in the network"
        },
        "submitterAddress": {
          "type": "string",
          "title": "Ethereum public key being used as the submitter to allow automatic signature generation"
        },
        "epochSeq": {
          "type": "string",
          "format": "uint64",
          "title": "Epoch in which the node was announced or removed from the network"
        }
      },
      "title": "Validator update event contains information about validator node"
    },
    "v1VestingBalancesSummary": {
      "type": "object",
      "properties": {
        "epochSeq": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch for which these balances are valid."
        },
        "partiesVestingSummary": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyVestingSummary"
          },
          "description": "Parties' summaries."
        }
      },
      "title": "Summary of the vesting and locked balances for an epoch"
    },
    "v1VestingStatsUpdated": {
      "type": "object",
      "properties": {
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the vesting statistics are updated."
        },
        "stats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyVestingStats"
          },
          "description": "All parties stats."
        }
      },
      "description": "Stats of all parties invested in the vesting program."
    },
    "v1VolumeDiscountProgramEnded": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "uint64",
          "description": "Program update version."
        },
        "id": {
          "type": "string",
          "description": "Unique ID of the volume discount program."
        },
        "endedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the referral program ended."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the referral program ended."
        }
      }
    },
    "v1VolumeDiscountProgramStarted": {
      "type": "object",
      "properties": {
        "program": {
          "$ref": "#/definitions/vegaVolumeDiscountProgram",
          "description": "Volume discount program that has started."
        },
        "startedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the volume discount program started."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the volume discount program started."
        }
      }
    },
    "v1VolumeDiscountProgramUpdated": {
      "type": "object",
      "properties": {
        "program": {
          "$ref": "#/definitions/vegaVolumeDiscountProgram",
          "description": "The updated volume discount program."
        },
        "updatedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the volume discount program was updated."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the volume discount program was updated."
        }
      }
    },
    "v1VolumeDiscountStatsUpdated": {
      "type": "object",
      "properties": {
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the volume discount statistics are updated."
        },
        "stats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyVolumeDiscountStats"
          },
          "description": "All parties' stats."
        }
      },
      "description": "Stats of all parties eligible for volume discount."
    },
    "v1VolumeRebateProgramEnded": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "uint64",
          "description": "Program update version."
        },
        "id": {
          "type": "string",
          "description": "Unique ID of the volume discount program."
        },
        "endedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the referral program ended."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the referral program ended."
        }
      }
    },
    "v1VolumeRebateProgramStarted": {
      "type": "object",
      "properties": {
        "program": {
          "$ref": "#/definitions/vegaVolumeRebateProgram",
          "description": "Volume rebate program that has started."
        },
        "startedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the volume discount program started."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the volume discount program started."
        }
      }
    },
    "v1VolumeRebateProgramUpdated": {
      "type": "object",
      "properties": {
        "program": {
          "$ref": "#/definitions/vegaVolumeRebateProgram",
          "description": "The updated volume rebate program."
        },
        "updatedAt": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the volume discount program was updated."
        },
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the volume discount program was updated."
        }
      }
    },
    "v1VolumeRebateStatsUpdated": {
      "type": "object",
      "properties": {
        "atEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Epoch at which the volume rebate statistics are updated."
        },
        "stats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PartyVolumeRebateStats"
          },
          "description": "All parties' stats."
        }
      },
      "description": "Stats of all parties eligible for volume rebate."
    },
    "v1VoteSpamStatistic": {
      "type": "object",
      "properties": {
        "proposal": {
          "type": "string",
          "description": "Unique ID of the proposal being voted on by the party."
        },
        "countForEpoch": {
          "type": "string",
          "format": "uint64",
          "title": "Current vote count received from the party for the given proposal during this epoch"
        },
        "minTokensRequired": {
          "type": "string",
          "title": "Effective minimum number of tokens required to vote on the proposal"
        }
      },
      "description": "Vote statistics for the voting spam policies\nwhich are calculated as a ratio of the total votes\nthat have been rejected."
    },
    "v1VoteSpamStatistics": {
      "type": "object",
      "properties": {
        "statistics": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1VoteSpamStatistic"
          },
          "title": "List of statistics for proposals voted on by the party"
        },
        "maxForEpoch": {
          "type": "string",
          "format": "uint64",
          "title": "Maximum number of votes per proposal allowed in an epoch"
        },
        "bannedUntil": {
          "type": "string",
          "title": "If blocked the timestamp when the party will be unblocked as RFC3339Nano"
        }
      },
      "title": "Voting statistics by proposal for a given party for the current epoch"
    },
    "v1VoteSubmission": {
      "type": "object",
      "properties": {
        "proposalId": {
          "type": "string",
          "description": "Submit vote for the specified proposal ID."
        },
        "value": {
          "$ref": "#/definitions/vegaVoteValue",
          "description": "Actual value of the vote."
        }
      },
      "description": "Command that allows a token holder to vote for or against an active governance proposal."
    },
    "v1WithdrawSubmission": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "string",
          "description": "Amount to be withdrawn, as an unsigned integer scaled to the asset's decimal places."
        },
        "asset": {
          "type": "string",
          "description": "Asset to be withdrawn."
        },
        "ext": {
          "$ref": "#/definitions/vegaWithdrawExt",
          "description": "Details specific to the foreign chain, such as the receiver address."
        }
      },
      "description": "Command to instruct the network to process an asset withdrawal from the Vega network.\nThe process is specific to the destination foreign chain, for example, a withdrawal to Ethereum will generate signatures\nthat allow funds to be taken across the bridge."
    },
    "vegaAccount": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique account ID, used internally by Vega."
        },
        "owner": {
          "type": "string",
          "description": "Party that the account belongs to, special values include `network`, which represents the Vega network and is\nmost commonly seen during liquidation of distressed trading positions."
        },
        "balance": {
          "type": "string",
          "description": "Balance of the asset, the balance is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places\nand importantly balances cannot be negative."
        },
        "asset": {
          "type": "string",
          "description": "Asset ID for the account."
        },
        "marketId": {
          "type": "string",
          "description": "Market ID for the account, if `AccountType.ACCOUNT_TYPE_GENERAL` this will be empty."
        },
        "type": {
          "$ref": "#/definitions/vegaAccountType",
          "description": "Account type related to this account."
        }
      },
      "title": "Represents an account for an asset on Vega for a particular owner or party"
    },
    "vegaAccountDetails": {
      "type": "object",
      "properties": {
        "assetId": {
          "type": "string",
          "description": "Asset ID of the asset for this account."
        },
        "type": {
          "$ref": "#/definitions/vegaAccountType",
          "description": "Type of the account."
        },
        "owner": {
          "type": "string",
          "description": "Not specified if network account."
        },
        "marketId": {
          "type": "string",
          "description": "Not specified if account is not related to a market."
        }
      }
    },
    "vegaAccountType": {
      "type": "string",
      "enum": [
        "ACCOUNT_TYPE_UNSPECIFIED",
        "ACCOUNT_TYPE_INSURANCE",
        "ACCOUNT_TYPE_SETTLEMENT",
        "ACCOUNT_TYPE_MARGIN",
        "ACCOUNT_TYPE_GENERAL",
        "ACCOUNT_TYPE_FEES_INFRASTRUCTURE",
        "ACCOUNT_TYPE_FEES_LIQUIDITY",
        "ACCOUNT_TYPE_FEES_MAKER",
        "ACCOUNT_TYPE_BOND",
        "ACCOUNT_TYPE_EXTERNAL",
        "ACCOUNT_TYPE_GLOBAL_INSURANCE",
        "ACCOUNT_TYPE_GLOBAL_REWARD",
        "ACCOUNT_TYPE_PENDING_TRANSFERS",
        "ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES",
        "ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES",
        "ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES",
        "ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS",
        "ACCOUNT_TYPE_HOLDING",
        "ACCOUNT_TYPE_LP_LIQUIDITY_FEES",
        "ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION",
        "ACCOUNT_TYPE_NETWORK_TREASURY",
        "ACCOUNT_TYPE_VESTING_REWARDS",
        "ACCOUNT_TYPE_VESTED_REWARDS",
        "ACCOUNT_TYPE_REWARD_RELATIVE_RETURN",
        "ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY",
        "ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING",
        "ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD",
        "ACCOUNT_TYPE_ORDER_MARGIN",
        "ACCOUNT_TYPE_REWARD_REALISED_RETURN",
        "ACCOUNT_TYPE_BUY_BACK_FEES",
        "ACCOUNT_TYPE_REWARD_AVERAGE_NOTIONAL",
        "ACCOUNT_TYPE_REWARD_ELIGIBLE_ENTITIES"
      ],
      "default": "ACCOUNT_TYPE_UNSPECIFIED",
      "description": "- ACCOUNT_TYPE_UNSPECIFIED: Default value\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.\nEach party will have a margin account for each market they have traded in.\nRequired initial margin is allocated to each market from user's general account.\nCollateral in the margin account can't be withdrawn or used as margin on another market until\nit is released back to the general account.\nVega protocol uses an internal accounting system to segregate funds held as\nmargin from other funds to ensure they are never lost or 'double spent'\n\nMargin account funds will vary as margin requirements on positions change\n - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will\nhave multiple general accounts, one for each asset they want\nto trade with\n\nGeneral accounts are where funds are initially deposited or withdrawn from,\nit is also the account where funds are taken to fulfil fees and initial margin requirements\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade - These fees reward parties\nwho provide the best priced liquidity that actually allows trading to take place\n - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments\n - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)\n - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset\n - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset\n - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)\n - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers\n - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers\n - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers\n - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold\n - ACCOUNT_TYPE_HOLDING: Per asset account for holding in-flight unfilled orders' funds\n - ACCOUNT_TYPE_LP_LIQUIDITY_FEES: Network controlled liquidity provider's account, per market, to hold accrued liquidity fees.\n - ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION: Network controlled liquidity fees bonus distribution account, per market.\n - ACCOUNT_TYPE_NETWORK_TREASURY: Network controlled treasury\n - ACCOUNT_TYPE_VESTING_REWARDS: Account holding user's rewards for the vesting period\n - ACCOUNT_TYPE_VESTED_REWARDS: Account holding user's rewards after the vesting period\n - ACCOUNT_TYPE_REWARD_RELATIVE_RETURN: Per asset market reward account given for relative return\n - ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY: Per asset market reward account given for return volatility\n - ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING: Per asset market reward account given to validators by their ranking\n - ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD: Per asset account for pending fee referral reward payouts\n - ACCOUNT_TYPE_ORDER_MARGIN: Per asset market account for party in isolated margin mode\n - ACCOUNT_TYPE_REWARD_REALISED_RETURN: Per asset market reward account for realised return\n - ACCOUNT_TYPE_BUY_BACK_FEES: Per asset account for paid buy-back fees\n - ACCOUNT_TYPE_REWARD_AVERAGE_NOTIONAL: Per asset market reward account given for average notional\n - ACCOUNT_TYPE_REWARD_ELIGIBLE_ENTITIES: Reward account for the eligible entities metric.",
      "title": "Various collateral/account types as used by Vega"
    },
    "vegaAsset": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Internal identifier of the asset."
        },
        "details": {
          "$ref": "#/definitions/vegaAssetDetails",
          "description": "Definition of the external source for this asset."
        },
        "status": {
          "$ref": "#/definitions/vegaAssetStatus",
          "description": "Status of the asset."
        }
      },
      "title": "Vega representation of an external asset"
    },
    "vegaAssetDetails": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the asset (e.g: Great British Pound)."
        },
        "symbol": {
          "type": "string",
          "description": "Symbol of the asset (e.g: GBP)."
        },
        "decimals": {
          "type": "string",
          "format": "uint64",
          "description": "Number of decimal / precision handled by this asset."
        },
        "quantum": {
          "type": "string",
          "description": "Minimum economically meaningful amount in the asset."
        },
        "builtinAsset": {
          "$ref": "#/definitions/vegaBuiltinAsset",
          "description": "Vega built-in asset."
        },
        "erc20": {
          "$ref": "#/definitions/vegaERC20",
          "description": "Ethereum ERC20 asset."
        }
      },
      "title": "Vega representation of an external asset"
    },
    "vegaAssetDetailsUpdate": {
      "type": "object",
      "properties": {
        "quantum": {
          "type": "string",
          "description": "Minimum economically meaningful amount in the asset."
        },
        "erc20": {
          "$ref": "#/definitions/vegaERC20Update",
          "description": "Ethereum ERC20 asset update."
        }
      },
      "description": "Changes to apply on an existing asset."
    },
    "vegaAssetStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_PROPOSED",
        "STATUS_REJECTED",
        "STATUS_PENDING_LISTING",
        "STATUS_ENABLED"
      ],
      "default": "STATUS_UNSPECIFIED",
      "title": "- STATUS_UNSPECIFIED: Default value, always invalid\n - STATUS_PROPOSED: Asset is proposed and under vote\n - STATUS_REJECTED: Asset has been rejected from governance\n - STATUS_PENDING_LISTING: Asset is pending listing from the bridge\n - STATUS_ENABLED: Asset is fully usable in the network"
    },
    "vegaAuctionDuration": {
      "type": "object",
      "properties": {
        "duration": {
          "type": "string",
          "format": "int64",
          "description": "Duration of the auction in seconds."
        },
        "volume": {
          "type": "string",
          "format": "uint64",
          "description": "Target uncrossing trading volume."
        }
      },
      "title": "Auction duration is used to configure 3 auction periods:\n1. `duration \u003e 0`, `volume == 0`:\n  The auction will last for at least N seconds\n2. `duration == 0`, `volume \u003e 0`:\n  The auction will end once the given volume will match at uncrossing\n3. `duration \u003e 0`, `volume \u003e 0`:\n  The auction will take at least N seconds, but can end sooner if the market can trade a certain volume"
    },
    "vegaAuctionTrigger": {
      "type": "string",
      "enum": [
        "AUCTION_TRIGGER_UNSPECIFIED",
        "AUCTION_TRIGGER_BATCH",
        "AUCTION_TRIGGER_OPENING",
        "AUCTION_TRIGGER_PRICE",
        "AUCTION_TRIGGER_LIQUIDITY",
        "AUCTION_TRIGGER_LIQUIDITY_TARGET_NOT_MET",
        "AUCTION_TRIGGER_UNABLE_TO_DEPLOY_LP_ORDERS",
        "AUCTION_TRIGGER_GOVERNANCE_SUSPENSION",
        "AUCTION_TRIGGER_LONG_BLOCK"
      ],
      "default": "AUCTION_TRIGGER_UNSPECIFIED",
      "description": "- AUCTION_TRIGGER_UNSPECIFIED: Default value for AuctionTrigger, no auction triggered\n - AUCTION_TRIGGER_BATCH: Batch auction\n - AUCTION_TRIGGER_OPENING: Opening auction\n - AUCTION_TRIGGER_PRICE: Price monitoring trigger\n - AUCTION_TRIGGER_LIQUIDITY: Deprecated\n - AUCTION_TRIGGER_LIQUIDITY_TARGET_NOT_MET: Liquidity auction due to not enough committed liquidity\n - AUCTION_TRIGGER_UNABLE_TO_DEPLOY_LP_ORDERS: Deprecated\n - AUCTION_TRIGGER_GOVERNANCE_SUSPENSION: Market is suspended and put into auction via governance\n - AUCTION_TRIGGER_LONG_BLOCK: Market is suspended in response to a long block",
      "title": "Auction triggers indicate what condition triggered an auction (if market is in auction mode)"
    },
    "vegaBatchProposalTerms": {
      "type": "object",
      "properties": {
        "closingTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Closing timestamp in Unix time; adheres to `minClose` and `maxClose` limits."
        },
        "proposalParams": {
          "$ref": "#/definitions/vegaProposalParameters",
          "description": "Specific parameters defining the proposal's characteristics used for validation."
        },
        "changes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaBatchProposalTermsChange"
          },
          "description": "List of individual changes included in the batch proposal."
        }
      },
      "title": "Terms for a batch governance proposal on Vega"
    },
    "vegaBatchProposalTermsChange": {
      "type": "object",
      "properties": {
        "enactmentTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp as Unix time in seconds when proposal terms gets enacted if proposal passed the vote,\nconstrained by `minEnact` and `maxEnact` network parameters."
        },
        "validationTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Validation timestamp as Unix time in seconds."
        },
        "updateMarket": {
          "$ref": "#/definitions/vegaUpdateMarket",
          "description": "Proposal change for modifying an existing futures market."
        },
        "newMarket": {
          "$ref": "#/definitions/vegaNewMarket",
          "description": "Proposal change for creating new futures market."
        },
        "updateNetworkParameter": {
          "$ref": "#/definitions/vegaUpdateNetworkParameter",
          "description": "Proposal change for updating Vega network parameters."
        },
        "newFreeform": {
          "$ref": "#/definitions/vegaNewFreeform",
          "description": "Proposal change for a freeform request, which can be voted on but does not change the behaviour of the system,\nand can be used to gauge community sentiment."
        },
        "updateAsset": {
          "$ref": "#/definitions/vegaUpdateAsset",
          "description": "Proposal change for updating an asset."
        },
        "newSpotMarket": {
          "$ref": "#/definitions/vegaNewSpotMarket",
          "description": "Proposal change for creating new spot market."
        },
        "updateSpotMarket": {
          "$ref": "#/definitions/vegaUpdateSpotMarket",
          "description": "Proposal change for modifying an existing spot market."
        },
        "newTransfer": {
          "$ref": "#/definitions/vegaNewTransfer",
          "description": "Proposal change for a governance initiated transfer."
        },
        "cancelTransfer": {
          "$ref": "#/definitions/vegaCancelTransfer",
          "description": "Proposal change to cancel a governance initiated transfe."
        },
        "updateMarketState": {
          "$ref": "#/definitions/vegaUpdateMarketState",
          "description": "Proposal change for updating the state of a market."
        },
        "updateReferralProgram": {
          "$ref": "#/definitions/vegaUpdateReferralProgram",
          "description": "Proposal change for updating the referral program."
        },
        "updateVolumeDiscountProgram": {
          "$ref": "#/definitions/vegaUpdateVolumeDiscountProgram",
          "description": "Proposal change for updating the volume discount program."
        },
        "newAsset": {
          "$ref": "#/definitions/vegaNewAsset",
          "description": "Proposal change for adding a new asset."
        },
        "updateVolumeRebateProgram": {
          "$ref": "#/definitions/vegaUpdateVolumeRebateProgram",
          "description": "Proposal change for updating the volume rebate program."
        }
      },
      "title": "Terms change for a batch governance proposal"
    },
    "vegaBenefitTier": {
      "type": "object",
      "properties": {
        "minimumRunningNotionalTakerVolume": {
          "type": "string",
          "description": "Required running notional taker volume in quantum units for parties\nto access this tier."
        },
        "minimumEpochs": {
          "type": "string",
          "description": "Required number of epochs a party must have been in a referral set to\naccess this tier."
        },
        "referralRewardFactor": {
          "type": "string",
          "title": "deprecated"
        },
        "referralDiscountFactor": {
          "type": "string",
          "title": "deprecated"
        },
        "referralRewardFactors": {
          "$ref": "#/definitions/vegaRewardFactors",
          "description": "Proportion of the referee's fees to be rewarded to the referrer."
        },
        "referralDiscountFactors": {
          "$ref": "#/definitions/vegaDiscountFactors",
          "description": "Referral discount factors for the various fees."
        }
      }
    },
    "vegaBuiltinAsset": {
      "type": "object",
      "properties": {
        "maxFaucetAmountMint": {
          "type": "string",
          "description": "Maximum amount that can be requested by a party through the built-in asset faucet at a time."
        }
      },
      "title": "Vega internal asset"
    },
    "vegaCancelTransfer": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaCancelTransferConfiguration",
          "title": "Configuration for cancellation of a governance-initiated transfer"
        }
      }
    },
    "vegaCancelTransferConfiguration": {
      "type": "object",
      "properties": {
        "transferId": {
          "type": "string",
          "description": "ID of the governance transfer proposal."
        }
      }
    },
    "vegaChainStatus": {
      "type": "string",
      "enum": [
        "CHAIN_STATUS_UNSPECIFIED",
        "CHAIN_STATUS_DISCONNECTED",
        "CHAIN_STATUS_REPLAYING",
        "CHAIN_STATUS_CONNECTED"
      ],
      "default": "CHAIN_STATUS_UNSPECIFIED",
      "description": "- CHAIN_STATUS_UNSPECIFIED: Default value, always invalid\n - CHAIN_STATUS_DISCONNECTED: Blockchain is disconnected\n - CHAIN_STATUS_REPLAYING: Blockchain is replaying historic transactions\n - CHAIN_STATUS_CONNECTED: Blockchain is connected and receiving transactions",
      "title": "Vega blockchain status as reported by the node the caller is connected to"
    },
    "vegaCompositePriceConfiguration": {
      "type": "object",
      "properties": {
        "decayWeight": {
          "type": "string",
          "description": "Decay weight used for calculation of mark price."
        },
        "decayPower": {
          "type": "string",
          "format": "uint64",
          "description": "Decay power used for the calculation of mark price."
        },
        "cashAmount": {
          "type": "string",
          "description": "Cash amount, in asset decimals, used for the calculation of the mark price from the order book."
        },
        "sourceWeights": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Weights for each composite price data source."
        },
        "sourceStalenessTolerance": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "For how long a price source is considered valid. One entry for each data source\nsuch that the first is for the trade based mark price, the second is for the book based price\nthe third is for the first oracle, followed by more oracle data source staleness tolerance."
        },
        "compositePriceType": {
          "$ref": "#/definitions/vegaCompositePriceType",
          "description": "Which method is used for the calculation of the composite price for the market."
        },
        "dataSourcesSpec": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaDataSourceDefinition"
          },
          "description": "Additional price sources to be used for internal composite price calculation."
        },
        "dataSourcesSpecBinding": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaSpecBindingForCompositePrice"
          },
          "title": "List of each price source and its corresponding binding"
        }
      },
      "description": "Mark price configuration parameters."
    },
    "vegaCompositePriceSource": {
      "type": "object",
      "properties": {
        "priceSource": {
          "type": "string",
          "description": "Source of the price."
        },
        "price": {
          "type": "string",
          "description": "Current value of the composite source price."
        },
        "lastUpdated": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds when the price source was last updated."
        }
      }
    },
    "vegaCompositePriceState": {
      "type": "object",
      "properties": {
        "priceSources": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaCompositePriceSource"
          }
        }
      },
      "description": "Underlying state of the composite price.."
    },
    "vegaCompositePriceType": {
      "type": "string",
      "enum": [
        "COMPOSITE_PRICE_TYPE_UNSPECIFIED",
        "COMPOSITE_PRICE_TYPE_WEIGHTED",
        "COMPOSITE_PRICE_TYPE_MEDIAN",
        "COMPOSITE_PRICE_TYPE_LAST_TRADE"
      ],
      "default": "COMPOSITE_PRICE_TYPE_UNSPECIFIED",
      "description": " - COMPOSITE_PRICE_TYPE_WEIGHTED: Composite price is calculated as a weighted average of the underlying mark prices.\n - COMPOSITE_PRICE_TYPE_MEDIAN: Composite price is calculated as a median of the underlying mark prices.\n - COMPOSITE_PRICE_TYPE_LAST_TRADE: Composite price is calculated as the last trade price."
    },
    "vegaDataSourceDefinition": {
      "type": "object",
      "properties": {
        "internal": {
          "$ref": "#/definitions/vegaDataSourceDefinitionInternal"
        },
        "external": {
          "$ref": "#/definitions/vegaDataSourceDefinitionExternal"
        }
      },
      "description": "Represents the top level object that handles data sources.\nData source definition can be external or internal, with whatever\nnumber of data sources are defined for each type in the child objects below."
    },
    "vegaDataSourceDefinitionExternal": {
      "type": "object",
      "properties": {
        "oracle": {
          "$ref": "#/definitions/vegaDataSourceSpecConfiguration"
        },
        "ethOracle": {
          "$ref": "#/definitions/vegaEthCallSpec",
          "description": "Contains the data specification that is received from Ethereum sources."
        }
      },
      "description": "DataSourceDefinitionExternal is the top level object used for all external\ndata sources. It contains one of any of the defined `SourceType` variants."
    },
    "vegaDataSourceDefinitionInternal": {
      "type": "object",
      "properties": {
        "time": {
          "$ref": "#/definitions/vegaDataSourceSpecConfigurationTime"
        },
        "timeTrigger": {
          "$ref": "#/definitions/vegaDataSourceSpecConfigurationTimeTrigger"
        }
      },
      "description": "Top level object used for all internal data sources.\nIt contains one of any of the defined source type variants."
    },
    "vegaDataSourceSpec": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Hash generated from the DataSpec data."
        },
        "createdAt": {
          "type": "string",
          "format": "int64",
          "title": "Creation date and time"
        },
        "updatedAt": {
          "type": "string",
          "format": "int64",
          "title": "Last Updated timestamp"
        },
        "data": {
          "$ref": "#/definitions/vegaDataSourceDefinition"
        },
        "status": {
          "$ref": "#/definitions/vegaDataSourceSpecStatus",
          "title": "Status describes the status of the data source spec"
        }
      },
      "description": "Data source spec describes the data source base that a product or a risk\nmodel wants to get from the data source engine. This message contains\nadditional information used by the API."
    },
    "vegaDataSourceSpecConfiguration": {
      "type": "object",
      "properties": {
        "signers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Signer"
          },
          "description": "Signers is the list of authorized signatures that signed the data for this\nsource. All the signatures in the data source data should be contained in\nthis external source. All the signatures in the data should be contained in\nthis list."
        },
        "filters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Filter"
          },
          "description": "Filters describes which source data are considered of interest or not for\nthe product (or the risk model)."
        }
      },
      "description": "All types of external data sources use the same configuration set for meeting\nrequirements in order for the data to be useful for Vega - valid signatures\nand matching filters."
    },
    "vegaDataSourceSpecConfigurationTime": {
      "type": "object",
      "properties": {
        "conditions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Condition"
          },
          "description": "Conditions that the timestamps should meet in order to be considered."
        }
      },
      "description": "Internal data source used for emitting timestamps."
    },
    "vegaDataSourceSpecConfigurationTimeTrigger": {
      "type": "object",
      "properties": {
        "conditions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Condition"
          },
          "description": "Conditions that the timestamps need to meet in order to be considered."
        },
        "triggers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1InternalTimeTrigger"
          },
          "title": "An internal time trigger"
        }
      },
      "description": "Internal data source used for emitting timestamps automatically using predefined intervals and conditions."
    },
    "vegaDataSourceSpecStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_ACTIVE",
        "STATUS_DEACTIVATED"
      ],
      "default": "STATUS_UNSPECIFIED",
      "description": "- STATUS_UNSPECIFIED: Default value.\n - STATUS_ACTIVE: STATUS_ACTIVE describes an active data source spec.\n - STATUS_DEACTIVATED: STATUS_DEACTIVATED describes a data source spec that is not listening to\ndata anymore.",
      "title": "Status describe the status of the data source spec"
    },
    "vegaDataSourceSpecToFutureBinding": {
      "type": "object",
      "properties": {
        "settlementDataProperty": {
          "type": "string",
          "description": "Name of the property in the source data that should be used as settlement data.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement data."
        },
        "tradingTerminationProperty": {
          "type": "string",
          "description": "Name of the property in the data source data that signals termination of trading."
        }
      },
      "title": "DataSourceSpecToFutureBinding describes which property of the data source data is to be\nused as settlement data and which to use as the trading terminated trigger"
    },
    "vegaDataSourceSpecToPerpetualBinding": {
      "type": "object",
      "properties": {
        "settlementDataProperty": {
          "type": "string",
          "description": "Name of the property in the source data that should be used for settlement data.\nIf it is set to \"prices.BTC.value\" for example, then the perpetual market will use the value of\nthis property to get settlement data."
        },
        "settlementScheduleProperty": {
          "type": "string",
          "description": "Name of the property in the source data that should be used to determine the perpetual's settlement schedule."
        }
      },
      "description": "Describes which properties of the data source data is to be\nused for settlement."
    },
    "vegaDeposit": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique ID for the deposit."
        },
        "status": {
          "$ref": "#/definitions/vegaDepositStatus",
          "description": "Status of the deposit."
        },
        "partyId": {
          "type": "string",
          "description": "Party ID of the user initiating the deposit."
        },
        "asset": {
          "type": "string",
          "description": "Vega asset targeted by this deposit."
        },
        "amount": {
          "type": "string",
          "description": "Amount to be deposited. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "txHash": {
          "type": "string",
          "description": "Hash of the transaction from the foreign chain."
        },
        "creditedTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the Vega account was updated with the deposit."
        },
        "createdTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the deposit was created on the Vega network."
        }
      },
      "title": "Deposit on to the Vega network"
    },
    "vegaDepositStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_OPEN",
        "STATUS_CANCELLED",
        "STATUS_FINALIZED",
        "STATUS_DUPLICATE_REJECTED"
      ],
      "default": "STATUS_UNSPECIFIED",
      "description": "- STATUS_UNSPECIFIED: Default value, always invalid\n - STATUS_OPEN: Deposit is being processed by the network\n - STATUS_CANCELLED: Deposit has been cancelled or failed to be verified by the network\n - STATUS_FINALIZED: Deposit has been finalised and accounts have been updated\n - STATUS_DUPLICATE_REJECTED: Deposit has been rejected as a duplicate transaction.",
      "title": "Status of the deposit"
    },
    "vegaDiscountFactors": {
      "type": "object",
      "properties": {
        "infrastructureDiscountFactor": {
          "type": "string",
          "description": "Proportion of the referee's infrastructure fee to be discounted."
        },
        "liquidityDiscountFactor": {
          "type": "string",
          "description": "Proportion of the referee's liquidity fee to be discounted."
        },
        "makerDiscountFactor": {
          "type": "string",
          "description": "Proportion of the referee's maker fee to be discounted."
        }
      }
    },
    "vegaDispatchMetric": {
      "type": "string",
      "enum": [
        "DISPATCH_METRIC_UNSPECIFIED",
        "DISPATCH_METRIC_MAKER_FEES_PAID",
        "DISPATCH_METRIC_MAKER_FEES_RECEIVED",
        "DISPATCH_METRIC_LP_FEES_RECEIVED",
        "DISPATCH_METRIC_MARKET_VALUE",
        "DISPATCH_METRIC_RELATIVE_RETURN",
        "DISPATCH_METRIC_RETURN_VOLATILITY",
        "DISPATCH_METRIC_VALIDATOR_RANKING",
        "DISPATCH_METRIC_REALISED_RETURN",
        "DISPATCH_METRIC_AVERAGE_NOTIONAL",
        "DISPATCH_METRIC_ELIGIBLE_ENTITIES"
      ],
      "default": "DISPATCH_METRIC_UNSPECIFIED",
      "title": "- DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that uses the total maker fees paid in the market\n - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that uses the total maker fees received in the market\n - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that uses the total LP fees received in the market\n - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that uses total value of the market if above the required threshold and not paid given proposer bonus yet\n - DISPATCH_METRIC_RELATIVE_RETURN: Dispatch metric that uses the relative PNL of the party in the market\n - DISPATCH_METRIC_RETURN_VOLATILITY: Dispatch metric that uses return volatility of the party in the market\n - DISPATCH_METRIC_VALIDATOR_RANKING: Dispatch metric that uses the validator ranking of the validator as metric\n - DISPATCH_METRIC_REALISED_RETURN: Dispatch metric that uses the realised return of the party in a market\n - DISPATCH_METRIC_AVERAGE_NOTIONAL: Dispatch metric that uses the time weighted average notional\n - DISPATCH_METRIC_ELIGIBLE_ENTITIES: Dispatch metric that uses the eligibility criteria of entities"
    },
    "vegaDispatchStrategy": {
      "type": "object",
      "properties": {
        "assetForMetric": {
          "type": "string",
          "description": "Asset to use for metric."
        },
        "metric": {
          "$ref": "#/definitions/vegaDispatchMetric",
          "description": "Metric to apply."
        },
        "markets": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Optional markets in scope."
        },
        "entityScope": {
          "$ref": "#/definitions/vegaEntityScope",
          "description": "Mandatory enum that defines the entities within scope."
        },
        "individualScope": {
          "$ref": "#/definitions/vegaIndividualScope",
          "description": "Optional enum if the entity scope defined is for individuals, which determines the subset of individuals that are eligible to be rewarded."
        },
        "teamScope": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional list applicable if the reward type has a scope of teams, which allows the funder to define a list of team IDs that are eligible to be rewarded from this transfer"
        },
        "nTopPerformers": {
          "type": "string",
          "title": "The proportion of the top performers in the team for a given metric to be averaged for the metric calculation if the scope is team"
        },
        "stakingRequirement": {
          "type": "string",
          "title": "Minimum number of governance (e.g. VEGA) tokens staked for a party to be considered eligible. Defaults to 0"
        },
        "notionalTimeWeightedAveragePositionRequirement": {
          "type": "string",
          "title": "Minimum notional time-weighted averaged position required for a party to be considered eligible. Defaults to 0"
        },
        "windowLength": {
          "type": "string",
          "format": "uint64",
          "title": "Number of epochs to evaluate the metric on"
        },
        "lockPeriod": {
          "type": "string",
          "format": "uint64",
          "title": "Number of epochs after distribution to delay vesting of rewards by"
        },
        "distributionStrategy": {
          "$ref": "#/definitions/vegaDistributionStrategy",
          "title": "Controls how the reward is distributed between qualifying parties"
        },
        "rankTable": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaRank"
          },
          "description": "Ordered list, using start rank, defining the rank bands and share ratio for each band. Mandatory for the rank and rank lottery distribution strategies."
        },
        "capRewardFeeMultiple": {
          "type": "string",
          "description": "If set, the actual amount of rewards transferred to each public key during distribution for this transfer will be `min(calculated_reward_in_quantum, cap_reward_fee_multiple Ã— fees_paid_this_epoch_in_quantum)."
        },
        "transferInterval": {
          "type": "integer",
          "format": "int32",
          "description": "Number of epochs between transfers, i.e. when 4, funds will be transferred every 4 epochs with the first transfer occurring 4 epochs after the transaction is processed."
        }
      }
    },
    "vegaDistributionStrategy": {
      "type": "string",
      "enum": [
        "DISTRIBUTION_STRATEGY_UNSPECIFIED",
        "DISTRIBUTION_STRATEGY_PRO_RATA",
        "DISTRIBUTION_STRATEGY_RANK",
        "DISTRIBUTION_STRATEGY_RANK_LOTTERY"
      ],
      "default": "DISTRIBUTION_STRATEGY_UNSPECIFIED",
      "description": " - DISTRIBUTION_STRATEGY_PRO_RATA: Rewards funded using the pro-rata strategy should be distributed pro-rata by each entity's reward metric, scaled by any active multipliers that party has.\n - DISTRIBUTION_STRATEGY_RANK: Rewards funded using the party rank.\n - DISTRIBUTION_STRATEGY_RANK_LOTTERY: Rewards funded using the ranked lottery."
    },
    "vegaERC20": {
      "type": "object",
      "properties": {
        "contractAddress": {
          "type": "string",
          "description": "Address of the contract for the token, on the ethereum network."
        },
        "lifetimeLimit": {
          "type": "string",
          "description": "Lifetime limits deposit per address\nnote: this is a temporary measure that can be changed by governance."
        },
        "withdrawThreshold": {
          "type": "string",
          "description": "Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.\nThereâ€™s no limit on the size of a withdrawal\nnote: this is a temporary measure that can be changed by governance."
        },
        "chainId": {
          "type": "string",
          "description": "Chain ID the asset originated from."
        }
      },
      "title": "ERC20 token based asset, living on the ethereum network"
    },
    "vegaERC20Update": {
      "type": "object",
      "properties": {
        "lifetimeLimit": {
          "type": "string",
          "description": "Lifetime limits deposit per address.\nThis will be interpreted against the asset decimals.\nnote: this is a temporary measure that can be changed by governance."
        },
        "withdrawThreshold": {
          "type": "string",
          "description": "Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.\nThereâ€™s no limit on the size of a withdrawal\nnote: this is a temporary measure that can be changed by governance."
        }
      }
    },
    "vegaEntityScope": {
      "type": "string",
      "enum": [
        "ENTITY_SCOPE_UNSPECIFIED",
        "ENTITY_SCOPE_INDIVIDUALS",
        "ENTITY_SCOPE_TEAMS"
      ],
      "default": "ENTITY_SCOPE_UNSPECIFIED",
      "title": "- ENTITY_SCOPE_INDIVIDUALS: Rewards must be distributed directly to eligible parties.\n - ENTITY_SCOPE_TEAMS: Rewards must be distributed to directly eligible teams, and then amongst team members"
    },
    "vegaEpochAction": {
      "type": "string",
      "enum": [
        "EPOCH_ACTION_UNSPECIFIED",
        "EPOCH_ACTION_START",
        "EPOCH_ACTION_END"
      ],
      "default": "EPOCH_ACTION_UNSPECIFIED",
      "description": "- EPOCH_ACTION_START: Epoch update is for a new epoch.\n - EPOCH_ACTION_END: Epoch update is for the end of an epoch.",
      "title": "What epoch action has occurred"
    },
    "vegaErc20WithdrawExt": {
      "type": "object",
      "properties": {
        "receiverAddress": {
          "type": "string",
          "description": "Address into which the bridge will release the funds."
        }
      },
      "title": "Extension of data required for the withdraw submissions"
    },
    "vegaEthCallSpec": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Ethereum address of the contract to call."
        },
        "abi": {
          "type": "string",
          "description": "The ABI of that contract."
        },
        "method": {
          "type": "string",
          "description": "Name of the method on the contract to call."
        },
        "args": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "List of arguments to pass to method call.\nProtobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum\ntype according to the ABI."
        },
        "trigger": {
          "$ref": "#/definitions/vegaEthCallTrigger",
          "description": "Conditions for determining when to call the contract method."
        },
        "requiredConfirmations": {
          "type": "string",
          "format": "uint64",
          "title": "Number of confirmations required before the query is considered verified"
        },
        "filters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Filter"
          },
          "title": "Filters the data returned from the contract method"
        },
        "normalisers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaNormaliser"
          },
          "description": "Normalisers are used to convert the data returned from the contract method\ninto a standard format. The key of the map is the name of the property,\nwhich identifies the specific piece of data to other parts of the data\nsourcing framework, for example filters. The value is a JSONPath expression\nfor expressing where in the contract call result the required data is\nlocated, for example $[0] indicates the first result. $[1].price would look\nin the second result returned from the contract for a structure with a key\ncalled 'price' and use that if it exists."
        },
        "sourceChainId": {
          "type": "string",
          "format": "uint64",
          "description": "The ID of the EVM based chain which is to be used to source the oracle data."
        }
      },
      "description": "Specifies a data source that derives its content from calling a read method\non an Ethereum contract."
    },
    "vegaEthCallTrigger": {
      "type": "object",
      "properties": {
        "timeTrigger": {
          "$ref": "#/definitions/vegaEthTimeTrigger"
        }
      },
      "description": "Determines when the contract method should be called."
    },
    "vegaEthTimeTrigger": {
      "type": "object",
      "properties": {
        "initial": {
          "type": "string",
          "format": "uint64",
          "description": "Trigger when the Ethereum time is greater or equal to this time, in Unix\nseconds."
        },
        "every": {
          "type": "string",
          "format": "uint64",
          "description": "Repeat the call every n seconds after the initial call. If no time for\ninitial call was specified, begin repeating immediately."
        },
        "until": {
          "type": "string",
          "format": "uint64",
          "description": "If repeating, stop once Ethereum time is greater than this time, in Unix\nseconds. If not set, then repeat indefinitely."
        }
      },
      "description": "Trigger for an Ethereum call based on the Ethereum block timestamp. Can be\none-off or repeating."
    },
    "vegaExternalDataSourceSpec": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/vegaDataSourceSpec"
        }
      }
    },
    "vegaFee": {
      "type": "object",
      "properties": {
        "makerFee": {
          "type": "string",
          "description": "Fee amount paid to the non-aggressive party of the trade. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "infrastructureFee": {
          "type": "string",
          "description": "Fee amount paid for maintaining the Vega infrastructure. This field is an unsigned integer scaled using the asset's decimal places."
        },
        "liquidityFee": {
          "type": "string",
          "description": "Fee amount paid to market makers. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "makerFeeVolumeDiscount": {
          "type": "string",
          "description": "Volume discounts.\nDiscount on maker fee based on the taker volume."
        },
        "infrastructureFeeVolumeDiscount": {
          "type": "string",
          "description": "Discount on infrastructure fee based on the taker volume."
        },
        "liquidityFeeVolumeDiscount": {
          "type": "string",
          "description": "Discount on liquidity fee basedo on taker volume."
        },
        "makerFeeReferrerDiscount": {
          "type": "string",
          "description": "Referrer discounts.\nDiscount on maker fee for eligible referrer."
        },
        "infrastructureFeeReferrerDiscount": {
          "type": "string",
          "description": "Discount on infrastructure fee for eligible referrer."
        },
        "liquidityFeeReferrerDiscount": {
          "type": "string",
          "description": "Discount on liquidity fee for eligible referrer."
        },
        "treasuryFee": {
          "type": "string",
          "description": "Fee amount sent to network treasury for later use based on governance actions (network wide)."
        },
        "buyBackFee": {
          "type": "string",
          "description": "Fee amount used to purchase governance tokens via regular auctions (network wide)."
        },
        "highVolumeMakerFee": {
          "type": "string",
          "description": "Fee paid by the taker to the maker if the maker is eligible."
        }
      },
      "title": "Represents any fees paid by a party, resulting from a trade"
    },
    "vegaFeeFactors": {
      "type": "object",
      "properties": {
        "makerFee": {
          "type": "string",
          "description": "Market maker fee charged network wide."
        },
        "infrastructureFee": {
          "type": "string",
          "description": "Infrastructure fee charged network wide for staking and governance."
        },
        "liquidityFee": {
          "type": "string",
          "description": "Liquidity fee applied per market for market making."
        },
        "treasuryFee": {
          "type": "string",
          "description": "Fees sent to network treasury for later use based on governance actions (network wide)."
        },
        "buyBackFee": {
          "type": "string",
          "description": "Fees used to purchase governance tokens via regular auctions (network wide)."
        }
      },
      "title": "Fee factors definition"
    },
    "vegaFees": {
      "type": "object",
      "properties": {
        "factors": {
          "$ref": "#/definitions/vegaFeeFactors",
          "description": "Fee factors."
        },
        "liquidityFeeSettings": {
          "$ref": "#/definitions/vegaLiquidityFeeSettings",
          "description": "Liquidity fee settings for the market describing how the fee was calculated."
        }
      },
      "title": "Fees definition"
    },
    "vegaFuture": {
      "type": "object",
      "properties": {
        "settlementAsset": {
          "type": "string",
          "description": "Underlying asset for the future."
        },
        "quoteName": {
          "type": "string",
          "description": "Quote name of the instrument."
        },
        "dataSourceSpecForSettlementData": {
          "$ref": "#/definitions/vegaDataSourceSpec",
          "description": "Data source specification that describes the settlement data source filter."
        },
        "dataSourceSpecForTradingTermination": {
          "$ref": "#/definitions/vegaDataSourceSpec",
          "description": "Data source specification that describes the trading termination data source filter."
        },
        "dataSourceSpecBinding": {
          "$ref": "#/definitions/vegaDataSourceSpecToFutureBinding",
          "description": "Binding between the data spec and the data source."
        },
        "cap": {
          "$ref": "#/definitions/vegaFutureCap",
          "description": "If set, this product represents a capped future market."
        }
      },
      "title": "Future product definition"
    },
    "vegaFutureCap": {
      "type": "object",
      "properties": {
        "maxPrice": {
          "type": "string",
          "description": "Set the maximum price for orders, and settlement data in market decimals."
        },
        "binarySettlement": {
          "type": "boolean",
          "description": "If set to true, the settlement price must either be zero, or equal to the max price."
        },
        "fullyCollateralised": {
          "type": "boolean",
          "description": "If set to true, positions must be fully collateralised so there is no default risk for any party."
        }
      }
    },
    "vegaFutureProduct": {
      "type": "object",
      "properties": {
        "settlementAsset": {
          "type": "string",
          "description": "Asset ID for the product's settlement asset."
        },
        "quoteName": {
          "type": "string",
          "description": "Product quote name."
        },
        "dataSourceSpecForSettlementData": {
          "$ref": "#/definitions/vegaDataSourceDefinition",
          "description": "Data source spec describing the data source for settlement."
        },
        "dataSourceSpecForTradingTermination": {
          "$ref": "#/definitions/vegaDataSourceDefinition",
          "description": "The external data source spec describing the data source of trading termination."
        },
        "dataSourceSpecBinding": {
          "$ref": "#/definitions/vegaDataSourceSpecToFutureBinding",
          "description": "Binding between the data source spec and the settlement data."
        },
        "cap": {
          "$ref": "#/definitions/vegaFutureCap",
          "description": "If set, this product creates a capped future market."
        }
      },
      "title": "Future product configuration"
    },
    "vegaGovernanceTransferType": {
      "type": "string",
      "enum": [
        "GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED",
        "GOVERNANCE_TRANSFER_TYPE_ALL_OR_NOTHING",
        "GOVERNANCE_TRANSFER_TYPE_BEST_EFFORT"
      ],
      "default": "GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED"
    },
    "vegaIcebergOrder": {
      "type": "object",
      "properties": {
        "peakSize": {
          "type": "string",
          "format": "uint64",
          "description": "Size of the order that will be made visible if the iceberg order is replenished after trading."
        },
        "minimumVisibleSize": {
          "type": "string",
          "format": "uint64",
          "description": "If the visible size of the order falls below this value, it will be replenished back to the peak size using the reserved amount."
        },
        "reservedRemaining": {
          "type": "string",
          "format": "uint64",
          "description": "Size of the order that is reserved and used to restore the iceberg's peak when it is refreshed."
        }
      },
      "title": "Details of an iceberg order"
    },
    "vegaIndividualScope": {
      "type": "string",
      "enum": [
        "INDIVIDUAL_SCOPE_UNSPECIFIED",
        "INDIVIDUAL_SCOPE_ALL",
        "INDIVIDUAL_SCOPE_IN_TEAM",
        "INDIVIDUAL_SCOPE_NOT_IN_TEAM",
        "INDIVIDUAL_SCOPE_AMM"
      ],
      "default": "INDIVIDUAL_SCOPE_UNSPECIFIED",
      "description": " - INDIVIDUAL_SCOPE_ALL: All parties on the network are within the scope of this reward.\n - INDIVIDUAL_SCOPE_IN_TEAM: All parties that are part of a team are within the scope of this reward.\n - INDIVIDUAL_SCOPE_NOT_IN_TEAM: All parties that are not part of a team are within the scope of this reward.\n - INDIVIDUAL_SCOPE_AMM: All keys representing AMMs are within the scope of this reward."
    },
    "vegaInstrument": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique instrument ID."
        },
        "code": {
          "type": "string",
          "description": "Code for the instrument."
        },
        "name": {
          "type": "string",
          "description": "Name of the instrument."
        },
        "metadata": {
          "$ref": "#/definitions/vegaInstrumentMetadata",
          "description": "Collection of instrument meta-data."
        },
        "future": {
          "$ref": "#/definitions/vegaFuture",
          "description": "Future."
        },
        "spot": {
          "$ref": "#/definitions/vegaSpot",
          "description": "Spot."
        },
        "perpetual": {
          "$ref": "#/definitions/vegaPerpetual",
          "description": "Perpetual."
        }
      },
      "title": "Instrument definition"
    },
    "vegaInstrumentConfiguration": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Instrument name."
        },
        "code": {
          "type": "string",
          "description": "Instrument code, human-readable shortcode used to describe the instrument."
        },
        "future": {
          "$ref": "#/definitions/vegaFutureProduct",
          "description": "Future."
        },
        "spot": {
          "$ref": "#/definitions/vegaSpotProduct",
          "description": "Spot."
        },
        "perpetual": {
          "$ref": "#/definitions/vegaPerpetualProduct",
          "description": "Perpetual."
        }
      },
      "title": "Instrument configuration"
    },
    "vegaInstrumentMetadata": {
      "type": "object",
      "properties": {
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of 0 or more tags."
        }
      },
      "title": "Instrument metadata definition"
    },
    "vegaLedgerEntry": {
      "type": "object",
      "properties": {
        "fromAccount": {
          "$ref": "#/definitions/vegaAccountDetails",
          "description": "One or more accounts to transfer from."
        },
        "toAccount": {
          "$ref": "#/definitions/vegaAccountDetails",
          "description": "One or more accounts to transfer to."
        },
        "amount": {
          "type": "string",
          "description": "Amount to transfer. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "type": {
          "$ref": "#/definitions/vegaTransferType",
          "description": "Transfer type for this entry."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in nanoseconds of when the ledger entry was created."
        },
        "fromAccountBalance": {
          "type": "string",
          "description": "Sender account balance after the transfer. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "toAccountBalance": {
          "type": "string",
          "description": "Receiver account balance after the transfer. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "transferId": {
          "type": "string",
          "description": "Transfer ID the ledger entry relates to."
        }
      },
      "title": "Represents a ledger entry on Vega"
    },
    "vegaLedgerMovement": {
      "type": "object",
      "properties": {
        "entries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaLedgerEntry"
          },
          "description": "All the entries for these ledger movements."
        },
        "balances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaPostTransferBalance"
          },
          "description": "Resulting balances once the ledger movement are applied."
        }
      }
    },
    "vegaLiquidationStrategy": {
      "type": "object",
      "properties": {
        "disposalTimeStep": {
          "type": "string",
          "format": "int64",
          "description": "Interval, in seconds, at which the network will attempt to close its position."
        },
        "disposalFraction": {
          "type": "string",
          "description": "Fraction of the open position the market will try to close in a single attempt; range 0 through 1."
        },
        "fullDisposalSize": {
          "type": "string",
          "format": "uint64",
          "description": "Size of the position that the network will try to close in a single attempt."
        },
        "maxFractionConsumed": {
          "type": "string",
          "description": "Max fraction of the total volume of the orderbook, within liquidity bounds, that the network can use to close its position; range 0 through 1."
        },
        "disposalSlippageRange": {
          "type": "string",
          "description": "Decimal \u003e 0 specifying the range range above and below the mid price within which the network will trade to dispose of its position.\nThe value can be \u003e 1. For example, if set to 1.5, the minimum price will be 0, ie max(0, mid_price * (1 - 1.5)), and the maximum price will be mid_price * (1 + 1.5)."
        }
      },
      "description": "Liquidation strategy used when the network holds a position resulting from position resolution."
    },
    "vegaLiquidityFeeSettings": {
      "type": "object",
      "properties": {
        "method": {
          "$ref": "#/definitions/vegaLiquidityFeeSettingsMethod",
          "description": "Method used to calculate the market's liquidity fee."
        },
        "feeConstant": {
          "type": "string",
          "description": "Constant liquidity fee used when using the constant fee method."
        }
      },
      "description": "Market settings that describe how the liquidity fee is calculated."
    },
    "vegaLiquidityFeeSettingsMethod": {
      "type": "string",
      "enum": [
        "METHOD_UNSPECIFIED",
        "METHOD_MARGINAL_COST",
        "METHOD_WEIGHTED_AVERAGE",
        "METHOD_CONSTANT"
      ],
      "default": "METHOD_UNSPECIFIED",
      "description": " - METHOD_MARGINAL_COST: Fee is the smallest value of all bids, such that liquidity providers with nominated fees less than or equal to this value still have sufficient commitment to fulfil the market's target stake.\n - METHOD_WEIGHTED_AVERAGE: Fee is the weighted average of all liquidity providers' nominated fees, weighted by their committment.\n - METHOD_CONSTANT: Fee is set by the market to a constant value irrespective of any liquidity provider's nominated fee."
    },
    "vegaLiquidityMonitoringParameters": {
      "type": "object",
      "properties": {
        "targetStakeParameters": {
          "$ref": "#/definitions/vegaTargetStakeParameters",
          "description": "Specifies parameters related to target stake calculation."
        },
        "triggeringRatio": {
          "type": "string",
          "description": "Specifies the triggering ratio for entering liquidity auction."
        },
        "auctionExtension": {
          "type": "string",
          "format": "int64",
          "description": "Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction."
        }
      },
      "title": "LiquidityMonitoringParameters contains settings used for liquidity monitoring"
    },
    "vegaLiquidityOrder": {
      "type": "object",
      "properties": {
        "reference": {
          "$ref": "#/definitions/vegaPeggedReference",
          "description": "Pegged reference point for the order."
        },
        "proportion": {
          "type": "integer",
          "format": "int64",
          "description": "Relative proportion of the commitment to be allocated at a price level."
        },
        "offset": {
          "type": "string",
          "description": "Offset/amount of units away for the order. This field is an unsigned integer scaled using the market's decimal places."
        }
      },
      "title": "Represents a liquidity order"
    },
    "vegaLiquidityOrderReference": {
      "type": "object",
      "properties": {
        "orderId": {
          "type": "string",
          "description": "Unique ID of the pegged order generated to fulfil this liquidity order."
        },
        "liquidityOrder": {
          "$ref": "#/definitions/vegaLiquidityOrder",
          "description": "Liquidity order from the original submission."
        }
      },
      "title": "Pair of a liquidity order and the ID of the generated order"
    },
    "vegaLiquidityProviderFeeShare": {
      "type": "object",
      "properties": {
        "party": {
          "type": "string",
          "description": "Liquidity provider party ID."
        },
        "equityLikeShare": {
          "type": "string",
          "description": "Share own by this liquidity provider."
        },
        "averageEntryValuation": {
          "type": "string",
          "description": "Average entry valuation of the liquidity provider for the market."
        },
        "averageScore": {
          "type": "string",
          "description": "Average liquidity score."
        },
        "virtualStake": {
          "type": "string",
          "description": "The virtual stake of this liquidity provider."
        }
      },
      "title": "Equity-like share of liquidity fee for each liquidity provider"
    },
    "vegaLiquidityProviderSLA": {
      "type": "object",
      "properties": {
        "party": {
          "type": "string",
          "description": "Liquidity provider party ID."
        },
        "currentEpochFractionOfTimeOnBook": {
          "type": "string",
          "description": "Indicates how often LP meets the commitment during the current epoch."
        },
        "lastEpochFractionOfTimeOnBook": {
          "type": "string",
          "description": "Indicates how often LP met the commitment in the previous epoch."
        },
        "lastEpochFeePenalty": {
          "type": "string",
          "description": "Indicates the fee penalty amount applied in the previous epoch."
        },
        "lastEpochBondPenalty": {
          "type": "string",
          "description": "Shows the bond penalties from past epochs."
        },
        "hysteresisPeriodFeePenalties": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Determines how the fee penalties from past epochs affect future fee revenue."
        },
        "requiredLiquidity": {
          "type": "string",
          "description": "Represents the total amount of funds LP must supply. The amount to be supplied is in the marketâ€™s\nsettlement currency, spread on both buy and sell sides of the order book within a defined range."
        },
        "notionalVolumeBuys": {
          "type": "string",
          "description": "Notional volume of orders within the range provided on the buy side of the book."
        },
        "notionalVolumeSells": {
          "type": "string",
          "description": "Notional volume of orders within the range provided on the sell side of the book."
        }
      },
      "title": "SLA performance for each liquidity provider"
    },
    "vegaLiquidityProvision": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique ID for the liquidity provision."
        },
        "partyId": {
          "type": "string",
          "description": "Unique party ID for the creator of the provision."
        },
        "createdAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds for when the liquidity provision was created."
        },
        "updatedAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds for when the liquidity provision was updated."
        },
        "marketId": {
          "type": "string",
          "description": "Market ID for the liquidity provision."
        },
        "commitmentAmount": {
          "type": "string",
          "description": "Specified as a unitless number that represents the amount of settlement asset of the market.\nThis field is an unsigned integer scaled to the asset's decimal places."
        },
        "fee": {
          "type": "string",
          "description": "Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers."
        },
        "sells": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaLiquidityOrderReference"
          },
          "description": "Set of liquidity sell orders to meet the liquidity provision obligation."
        },
        "buys": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaLiquidityOrderReference"
          },
          "description": "Set of liquidity buy orders to meet the liquidity provision obligation."
        },
        "version": {
          "type": "string",
          "format": "uint64",
          "description": "Version of this liquidity provision."
        },
        "status": {
          "$ref": "#/definitions/vegaLiquidityProvisionStatus",
          "description": "Status of this liquidity provision."
        },
        "reference": {
          "type": "string",
          "description": "Reference shared between this liquidity provision and all its orders."
        }
      },
      "title": "Liquidity provider commitment"
    },
    "vegaLiquidityProvisionStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_ACTIVE",
        "STATUS_STOPPED",
        "STATUS_CANCELLED",
        "STATUS_REJECTED",
        "STATUS_UNDEPLOYED",
        "STATUS_PENDING"
      ],
      "default": "STATUS_UNSPECIFIED",
      "description": "Status of a liquidity provision.\n\n - STATUS_UNSPECIFIED: Always invalid\n - STATUS_ACTIVE: Liquidity provision is active\n - STATUS_STOPPED: Liquidity provision was stopped by the network\n - STATUS_CANCELLED: Liquidity provision was cancelled by the liquidity provider\n - STATUS_REJECTED: Liquidity provision was invalid and got rejected\n - STATUS_UNDEPLOYED: Liquidity provision is valid and accepted by network, but orders aren't deployed\n - STATUS_PENDING: Liquidity provision is valid and accepted by network\nbut has never been deployed. If when it's possible to deploy the orders for the first time\nmargin check fails, then they will be cancelled without any penalties."
    },
    "vegaLiquiditySLAParameters": {
      "type": "object",
      "properties": {
        "priceRange": {
          "type": "string"
        },
        "commitmentMinTimeFraction": {
          "type": "string",
          "description": "Specifies the minimum fraction of time LPs must spend \"on the book\" providing their committed liquidity."
        },
        "performanceHysteresisEpochs": {
          "type": "string",
          "format": "uint64",
          "description": "Specifies the number of liquidity epochs over which past performance will continue to affect rewards."
        },
        "slaCompetitionFactor": {
          "type": "string",
          "description": "Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers\nthat achieved a higher SLA performance than them."
        }
      }
    },
    "vegaLogNormalModelParams": {
      "type": "object",
      "properties": {
        "mu": {
          "type": "number",
          "format": "double",
          "description": "Mu parameter, annualised growth rate of the underlying asset."
        },
        "r": {
          "type": "number",
          "format": "double",
          "description": "R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number."
        },
        "sigma": {
          "type": "number",
          "format": "double",
          "description": "Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number."
        }
      },
      "title": "Risk model parameters for log normal"
    },
    "vegaLogNormalRiskModel": {
      "type": "object",
      "properties": {
        "riskAversionParameter": {
          "type": "number",
          "format": "double",
          "description": "Risk Aversion Parameter."
        },
        "tau": {
          "type": "number",
          "format": "double",
          "description": "Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall\ncalculation to obtain the maintenance margin, must be a strictly non-negative real number."
        },
        "params": {
          "$ref": "#/definitions/vegaLogNormalModelParams",
          "description": "Risk model parameters for log normal."
        },
        "riskFactorOverride": {
          "$ref": "#/definitions/vegaRiskFactorOverride",
          "description": "And optional override for the risk factor calculated by the risk model."
        }
      },
      "title": "Risk model for log normal"
    },
    "vegaMarginCalculator": {
      "type": "object",
      "properties": {
        "scalingFactors": {
          "$ref": "#/definitions/vegaScalingFactors",
          "description": "Scaling factors for margin calculation."
        },
        "fullyCollateralised": {
          "type": "boolean",
          "description": "If set to true, positions must be fully collateralised so there is no default risk for any party (capped futures)."
        }
      },
      "title": "Margin Calculator definition"
    },
    "vegaMarginLevels": {
      "type": "object",
      "properties": {
        "maintenanceMargin": {
          "type": "string",
          "description": "Maintenance margin value. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "searchLevel": {
          "type": "string",
          "description": "Margin search level value. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "initialMargin": {
          "type": "string",
          "description": "Initial margin value. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "collateralReleaseLevel": {
          "type": "string",
          "description": "Collateral release level value. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "partyId": {
          "type": "string",
          "description": "Party ID for whom the margin levels apply."
        },
        "marketId": {
          "type": "string",
          "description": "Market ID for which the margin levels apply."
        },
        "asset": {
          "type": "string",
          "description": "Asset ID for which the margin levels apply."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds for when the ledger entry was created."
        },
        "orderMargin": {
          "type": "string",
          "description": "Margin required to cover orders in isolated margin mode."
        },
        "marginMode": {
          "$ref": "#/definitions/vegaMarginMode",
          "description": "Margin mode for the party, cross margin or isolated margin."
        },
        "marginFactor": {
          "type": "string",
          "description": "Margin factor, relevant only for isolated margin, 0 otherwise."
        }
      },
      "title": "Represents the margin levels for a party on a market at a given time"
    },
    "vegaMarginMode": {
      "type": "string",
      "enum": [
        "MARGIN_MODE_UNSPECIFIED",
        "MARGIN_MODE_CROSS_MARGIN",
        "MARGIN_MODE_ISOLATED_MARGIN"
      ],
      "default": "MARGIN_MODE_UNSPECIFIED",
      "title": "- MARGIN_MODE_UNSPECIFIED: Never valid.\n - MARGIN_MODE_CROSS_MARGIN: Cross margin mode - margin is dynamically acquired and released as a position is marked to market\n - MARGIN_MODE_ISOLATED_MARGIN: Isolated margin mode - margin for any newly opened position volume is transferred to the margin account when the trade is executed"
    },
    "vegaMarket": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique ID for the market."
        },
        "tradableInstrument": {
          "$ref": "#/definitions/vegaTradableInstrument",
          "description": "Tradable instrument configuration."
        },
        "decimalPlaces": {
          "type": "string",
          "format": "uint64",
          "description": "Number of decimal places that a price must be shifted by in order to get a\ncorrect price denominated in the currency of the market, for example:\n`realPrice = price / 10^decimalPlaces`. On spot markets, also called 'size decimal places'."
        },
        "fees": {
          "$ref": "#/definitions/vegaFees",
          "description": "Fees configuration that apply to the market."
        },
        "openingAuction": {
          "$ref": "#/definitions/vegaAuctionDuration",
          "description": "Auction duration specifies how long the opening auction will run (minimum\nduration and optionally a minimum traded volume)."
        },
        "priceMonitoringSettings": {
          "$ref": "#/definitions/vegaPriceMonitoringSettings",
          "description": "PriceMonitoringSettings for the market."
        },
        "liquidityMonitoringParameters": {
          "$ref": "#/definitions/vegaLiquidityMonitoringParameters",
          "description": "LiquidityMonitoringParameters for the market."
        },
        "tradingMode": {
          "$ref": "#/definitions/MarketTradingMode",
          "description": "Current mode of execution of the market."
        },
        "state": {
          "$ref": "#/definitions/vegaMarketState",
          "description": "Current state of the market."
        },
        "marketTimestamps": {
          "$ref": "#/definitions/vegaMarketTimestamps",
          "description": "Timestamps for when the market state changes."
        },
        "positionDecimalPlaces": {
          "type": "string",
          "format": "int64",
          "description": "The number of decimal places for a position.\nOn spot markets, used for order size, also known as 'size decimal places'."
        },
        "lpPriceRange": {
          "type": "string",
          "description": "Percentage move up and down from the mid price which specifies the range of\nprice levels over which automated liquidity provisions will be deployed."
        },
        "linearSlippageFactor": {
          "type": "string",
          "description": "Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume."
        },
        "quadraticSlippageFactor": {
          "type": "string",
          "description": "Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume."
        },
        "parentMarketId": {
          "type": "string",
          "title": "ID of the market this market succeeds"
        },
        "insurancePoolFraction": {
          "type": "string",
          "description": "The fraction of the parent market's insurance pool that this market inherits; range 0 through 1."
        },
        "successorMarketId": {
          "type": "string",
          "description": "ID of the market that succeeds this market if it exists. This will be populated by the system when the successor market is enabled."
        },
        "liquiditySlaParams": {
          "$ref": "#/definitions/vegaLiquiditySLAParameters",
          "description": "Liquidity SLA parameters for the market."
        },
        "liquidationStrategy": {
          "$ref": "#/definitions/vegaLiquidationStrategy",
          "description": "Liquidation strategy used by this market."
        },
        "markPriceConfiguration": {
          "$ref": "#/definitions/vegaCompositePriceConfiguration",
          "description": "Mark price calculation configuration."
        },
        "tickSize": {
          "type": "string",
          "title": "The market tick size defines the minimum change in quote price for the market"
        },
        "enableTransactionReordering": {
          "type": "boolean",
          "title": "If enabled aggressive orders sent to the market will be delayed by the configured number of blocks"
        }
      },
      "title": "Market definition"
    },
    "vegaMarketData": {
      "type": "object",
      "properties": {
        "markPrice": {
          "type": "string",
          "description": "Mark price, as an unsigned integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "bestBidPrice": {
          "type": "string",
          "description": "Highest price level on an order book for buy orders, as an unsigned integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "bestBidVolume": {
          "type": "string",
          "format": "uint64",
          "description": "Aggregated volume being bid at the best bid price, as an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market is configured to 5 decimal places."
        },
        "bestOfferPrice": {
          "type": "string",
          "description": "Lowest price level on an order book for offer orders. This field is an unsigned integer scaled to the market's decimal places."
        },
        "bestOfferVolume": {
          "type": "string",
          "format": "uint64",
          "description": "Aggregated volume being offered at the best offer price, as an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market is configured to 5 decimal places."
        },
        "bestStaticBidPrice": {
          "type": "string",
          "description": "Highest price on the order book for buy orders not including pegged orders.\nThis field is an unsigned integer scaled to the market's decimal places."
        },
        "bestStaticBidVolume": {
          "type": "string",
          "format": "uint64",
          "description": "Total volume at the best static bid price excluding pegged orders."
        },
        "bestStaticOfferPrice": {
          "type": "string",
          "description": "Lowest price on the order book for sell orders not including pegged orders.\nThis field is an unsigned integer scaled to the market's decimal places."
        },
        "bestStaticOfferVolume": {
          "type": "string",
          "format": "uint64",
          "description": "Total volume at the best static offer price, excluding pegged orders."
        },
        "midPrice": {
          "type": "string",
          "description": "Arithmetic average of the best bid price and best offer price, as an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "staticMidPrice": {
          "type": "string",
          "description": "Arithmetic average of the best static bid price and best static offer price.\nThis field is an unsigned integer scaled to the market's decimal places."
        },
        "market": {
          "type": "string",
          "title": "Market ID for the data"
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds at which this mark price was relevant."
        },
        "openInterest": {
          "type": "string",
          "format": "uint64",
          "description": "Sum of the size of all positions greater than zero on the market."
        },
        "auctionEnd": {
          "type": "string",
          "format": "int64",
          "description": "Time in seconds until the end of the auction (zero if currently not in auction period)."
        },
        "auctionStart": {
          "type": "string",
          "format": "int64",
          "description": "Time until next auction, or start time of the current auction if market is in auction period."
        },
        "indicativePrice": {
          "type": "string",
          "description": "Indicative price (zero if not in auction). This field is an unsigned scaled to the market's decimal places."
        },
        "indicativeVolume": {
          "type": "string",
          "format": "uint64",
          "description": "Indicative volume (zero if not in auction)."
        },
        "marketTradingMode": {
          "$ref": "#/definitions/MarketTradingMode",
          "description": "Current trading mode for the market."
        },
        "trigger": {
          "$ref": "#/definitions/vegaAuctionTrigger",
          "description": "When a market is in an auction trading mode, this field indicates what triggered the auction."
        },
        "extensionTrigger": {
          "$ref": "#/definitions/vegaAuctionTrigger",
          "description": "When a market auction is extended, this field indicates what caused the extension."
        },
        "targetStake": {
          "type": "string",
          "description": "Targeted stake for the given market. This field is an unsigned integer scaled to the settlement asset's decimal places."
        },
        "suppliedStake": {
          "type": "string",
          "description": "Available stake for the given market. This field is an unsigned integer scaled to the settlement asset's decimal places."
        },
        "priceMonitoringBounds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaPriceMonitoringBounds"
          },
          "description": "One or more price monitoring bounds for the current timestamp."
        },
        "marketValueProxy": {
          "type": "string",
          "description": "Market value proxy."
        },
        "liquidityProviderFeeShare": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaLiquidityProviderFeeShare"
          },
          "description": "Equity-like share of liquidity fee for each liquidity provider."
        },
        "marketState": {
          "$ref": "#/definitions/vegaMarketState",
          "description": "Current state of the market."
        },
        "nextMarkToMarket": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the next mark-to-market calculation will occur."
        },
        "lastTradedPrice": {
          "type": "string",
          "description": "Last traded price of the market. This field is an unsigned integer scaled to the market's decimal places."
        },
        "marketGrowth": {
          "type": "string",
          "description": "Market growth at the last market time window."
        },
        "productData": {
          "$ref": "#/definitions/vegaProductData",
          "description": "Data related to the particular product type of the market."
        },
        "liquidityProviderSla": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaLiquidityProviderSLA"
          },
          "description": "SLA performance for each liquidity provider."
        },
        "nextNetworkCloseout": {
          "type": "string",
          "format": "int64",
          "description": "Time in Unix nanoseconds when the market will next submit a trade to reduce its position."
        },
        "markPriceType": {
          "$ref": "#/definitions/vegaCompositePriceType",
          "description": "The method used for calculating the mark price."
        },
        "markPriceState": {
          "$ref": "#/definitions/vegaCompositePriceState",
          "description": "State of the internal composite price."
        }
      },
      "title": "Represents data generated by a market when open"
    },
    "vegaMarketState": {
      "type": "string",
      "enum": [
        "STATE_UNSPECIFIED",
        "STATE_PROPOSED",
        "STATE_REJECTED",
        "STATE_PENDING",
        "STATE_CANCELLED",
        "STATE_ACTIVE",
        "STATE_SUSPENDED",
        "STATE_CLOSED",
        "STATE_TRADING_TERMINATED",
        "STATE_SETTLED",
        "STATE_SUSPENDED_VIA_GOVERNANCE"
      ],
      "default": "STATE_UNSPECIFIED",
      "description": "- STATE_UNSPECIFIED: Default value, invalid\n - STATE_PROPOSED: Governance proposal valid and accepted\n - STATE_REJECTED: Outcome of governance votes is to reject the market\n - STATE_PENDING: Governance vote passes/wins\n - STATE_CANCELLED: Market triggers cancellation condition or governance\nvotes to close before market becomes Active\n - STATE_ACTIVE: Enactment date reached and usual auction exit checks pass\n - STATE_SUSPENDED: Price monitoring or liquidity monitoring trigger\n - STATE_CLOSED: Governance vote to close (Not currently implemented)\n - STATE_TRADING_TERMINATED: Defined by the product (i.e. from a product parameter,\nspecified in market definition, giving close date/time)\n - STATE_SETTLED: Settlement triggered and completed as defined by product\n - STATE_SUSPENDED_VIA_GOVERNANCE: Market has been suspended via governance",
      "title": "Current state of the market"
    },
    "vegaMarketStateUpdateType": {
      "type": "string",
      "enum": [
        "MARKET_STATE_UPDATE_TYPE_UNSPECIFIED",
        "MARKET_STATE_UPDATE_TYPE_TERMINATE",
        "MARKET_STATE_UPDATE_TYPE_SUSPEND",
        "MARKET_STATE_UPDATE_TYPE_RESUME"
      ],
      "default": "MARKET_STATE_UPDATE_TYPE_UNSPECIFIED",
      "title": "- MARKET_STATE_UPDATE_TYPE_UNSPECIFIED: Default value, always invalid\n - MARKET_STATE_UPDATE_TYPE_TERMINATE: Request to terminate a market via governance\n - MARKET_STATE_UPDATE_TYPE_SUSPEND: Request to suspend a market via governance\n - MARKET_STATE_UPDATE_TYPE_RESUME: Request to resume a market via governance"
    },
    "vegaMarketTimestamps": {
      "type": "object",
      "properties": {
        "proposed": {
          "type": "string",
          "format": "int64",
          "description": "Time when the market is first proposed."
        },
        "pending": {
          "type": "string",
          "format": "int64",
          "description": "Time when the market has been voted in and began its opening auction."
        },
        "open": {
          "type": "string",
          "format": "int64",
          "description": "Time when the market has left the opening auction and is ready to accept trades."
        },
        "close": {
          "type": "string",
          "format": "int64",
          "description": "Time when the market closed."
        }
      },
      "title": "Time stamps for important times about creating, enacting etc the market"
    },
    "vegaMetadata": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "Key of the metadata."
        },
        "value": {
          "type": "string",
          "description": "Value of the metadata."
        }
      },
      "description": "Generic structure holding a key/value pair."
    },
    "vegaNetworkLimits": {
      "type": "object",
      "properties": {
        "canProposeMarket": {
          "type": "boolean",
          "description": "Are market proposals allowed at this point in time."
        },
        "canProposeAsset": {
          "type": "boolean",
          "description": "Are asset proposals allowed at this point in time."
        },
        "proposeMarketEnabled": {
          "type": "boolean",
          "description": "Are market proposals enabled on this chain."
        },
        "proposeAssetEnabled": {
          "type": "boolean",
          "description": "Are asset proposals enabled on this chain."
        },
        "genesisLoaded": {
          "type": "boolean",
          "description": "True once the genesis file is loaded."
        },
        "proposeMarketEnabledFrom": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds at which market proposals will be enabled (0 indicates not set)."
        },
        "proposeAssetEnabledFrom": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds at which asset proposals will be enabled (0 indicates not set)."
        },
        "canProposeSpotMarket": {
          "type": "boolean",
          "description": "Are spot market proposals allowed at this point in time."
        },
        "canProposePerpetualMarket": {
          "type": "boolean",
          "description": "Are perpetual market proposals allowed at this point in time."
        },
        "canUseAmm": {
          "type": "boolean",
          "description": "Can parties use AMM related transactions."
        }
      },
      "title": "Network limits, defined in the genesis file"
    },
    "vegaNetworkParameter": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "Unique key of the network parameter."
        },
        "value": {
          "type": "string",
          "description": "Value for the network parameter."
        }
      },
      "title": "Represents a network parameter on Vega"
    },
    "vegaNewAsset": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaAssetDetails",
          "description": "Configuration of the new asset."
        }
      },
      "title": "New asset on Vega"
    },
    "vegaNewFreeform": {
      "type": "object",
      "description": "Freeform proposal\nThis message is just used as a placeholder to sort out the nature of the\nproposal once parsed."
    },
    "vegaNewMarket": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaNewMarketConfiguration",
          "description": "Configuration of the new market."
        }
      },
      "title": "New market on Vega"
    },
    "vegaNewMarketConfiguration": {
      "type": "object",
      "properties": {
        "instrument": {
          "$ref": "#/definitions/vegaInstrumentConfiguration",
          "description": "New futures market instrument configuration."
        },
        "decimalPlaces": {
          "type": "string",
          "format": "uint64",
          "description": "Decimal places used for the new futures market, sets the smallest price increment on the book."
        },
        "metadata": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Optional new futures market metadata, tags."
        },
        "priceMonitoringParameters": {
          "$ref": "#/definitions/vegaPriceMonitoringParameters",
          "description": "Price monitoring parameters."
        },
        "liquidityMonitoringParameters": {
          "$ref": "#/definitions/vegaLiquidityMonitoringParameters",
          "description": "Liquidity monitoring parameters."
        },
        "simple": {
          "$ref": "#/definitions/vegaSimpleModelParams",
          "description": "Simple risk model parameters, valid only if MODEL_SIMPLE is selected."
        },
        "logNormal": {
          "$ref": "#/definitions/vegaLogNormalRiskModel",
          "description": "Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected."
        },
        "positionDecimalPlaces": {
          "type": "string",
          "format": "int64",
          "description": "Decimal places for order sizes, sets what size the smallest order / position on the futures market can be."
        },
        "lpPriceRange": {
          "type": "string",
          "description": "DEPRECATED: Use liquidity SLA parameters instead.\nPercentage move up and down from the mid price which specifies the range of\nprice levels over which automated liquidity provisions will be deployed."
        },
        "linearSlippageFactor": {
          "type": "string",
          "description": "Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume."
        },
        "quadraticSlippageFactor": {
          "type": "string",
          "description": "Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume."
        },
        "successor": {
          "$ref": "#/definitions/vegaSuccessorConfiguration",
          "description": "Successor configuration. If this proposal is meant to succeed a given market, then this should be set."
        },
        "liquiditySlaParameters": {
          "$ref": "#/definitions/vegaLiquiditySLAParameters",
          "title": "Liquidity SLA parameters"
        },
        "liquidityFeeSettings": {
          "$ref": "#/definitions/vegaLiquidityFeeSettings",
          "description": "Specifies how the liquidity fee for the market will be calculated."
        },
        "liquidationStrategy": {
          "$ref": "#/definitions/vegaLiquidationStrategy",
          "description": "Liquidation strategy for this market."
        },
        "markPriceConfiguration": {
          "$ref": "#/definitions/vegaCompositePriceConfiguration",
          "description": "Mark price configuration."
        },
        "tickSize": {
          "type": "string",
          "title": "The market tick size defines the minimum change in quote price for the market"
        },
        "enableTransactionReordering": {
          "type": "boolean",
          "title": "If enabled aggressive orders sent to the market will be delayed by the configured number of blocks"
        }
      },
      "title": "Configuration for a new futures market on Vega"
    },
    "vegaNewSpotMarket": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaNewSpotMarketConfiguration",
          "description": "Configuration of the new spot market."
        }
      },
      "title": "New spot market on Vega"
    },
    "vegaNewSpotMarketConfiguration": {
      "type": "object",
      "properties": {
        "instrument": {
          "$ref": "#/definitions/vegaInstrumentConfiguration",
          "description": "New spot market instrument configuration."
        },
        "priceDecimalPlaces": {
          "type": "string",
          "format": "uint64",
          "description": "Decimal places used for the new spot market, sets the smallest price increment on the book."
        },
        "metadata": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Optional new spot market metadata, tags."
        },
        "priceMonitoringParameters": {
          "$ref": "#/definitions/vegaPriceMonitoringParameters",
          "description": "Price monitoring parameters."
        },
        "targetStakeParameters": {
          "$ref": "#/definitions/vegaTargetStakeParameters",
          "description": "Specifies parameters related to target stake calculation."
        },
        "simple": {
          "$ref": "#/definitions/vegaSimpleModelParams",
          "description": "Simple risk model parameters, valid only if MODEL_SIMPLE is selected."
        },
        "logNormal": {
          "$ref": "#/definitions/vegaLogNormalRiskModel",
          "description": "Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected."
        },
        "sizeDecimalPlaces": {
          "type": "string",
          "format": "int64",
          "description": "Decimal places for order sizes, sets what size the smallest order / position on the spot market can be."
        },
        "slaParams": {
          "$ref": "#/definitions/vegaLiquiditySLAParameters",
          "description": "Specifies the liquidity provision SLA parameters."
        },
        "liquidityFeeSettings": {
          "$ref": "#/definitions/vegaLiquidityFeeSettings",
          "description": "Specifies how the liquidity fee for the market will be calculated."
        },
        "tickSize": {
          "type": "string",
          "title": "The market tick size defines the minimum change in quote price for the market"
        },
        "enableTransactionReordering": {
          "type": "boolean",
          "title": "If enabled aggressive orders sent to the market will be delayed by the configured number of blocks"
        }
      },
      "title": "Configuration for a new spot market on Vega"
    },
    "vegaNewTransfer": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaNewTransferConfiguration",
          "description": "Configuration for a new transfer."
        }
      },
      "title": "New governance transfer"
    },
    "vegaNewTransferConfiguration": {
      "type": "object",
      "properties": {
        "sourceType": {
          "$ref": "#/definitions/vegaAccountType",
          "title": "Source account type, such as network treasury, market insurance pool"
        },
        "source": {
          "type": "string",
          "title": "If network treasury, field is empty, otherwise uses the market ID"
        },
        "transferType": {
          "$ref": "#/definitions/vegaGovernanceTransferType",
          "title": "\"All or nothing\" or \"best effort\":\nAll or nothing: Transfers the specified amount or does not transfer anything\nBest effort: Transfers the specified amount or the max allowable amount if this is less than the specified amount"
        },
        "amount": {
          "type": "string",
          "title": "Maximum amount to transfer"
        },
        "asset": {
          "type": "string",
          "title": "ID of asset to transfer"
        },
        "fractionOfBalance": {
          "type": "string",
          "title": "Maximum fraction of the source account's balance to transfer as a decimal - i.e. 0.1 = 10% of the balance"
        },
        "destinationType": {
          "$ref": "#/definitions/vegaAccountType",
          "title": "Specifies the account type to transfer to: reward pool, party, network insurance pool, market insurance pool"
        },
        "destination": {
          "type": "string",
          "title": "Specifies the account to transfer to, depending on the account type:\nNetwork treasury: leave empty\nParty: party's public key\nMarket insurance pool: market ID"
        },
        "oneOff": {
          "$ref": "#/definitions/vegaOneOffTransfer"
        },
        "recurring": {
          "$ref": "#/definitions/vegaRecurringTransfer"
        }
      }
    },
    "vegaNormaliser": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "expression": {
          "type": "string"
        }
      }
    },
    "vegaOneOffTransfer": {
      "type": "object",
      "properties": {
        "deliverOn": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds for when the transfer should be delivered into the receiver's account."
        }
      },
      "title": "Specific details for a one off transfer"
    },
    "vegaOracleData": {
      "type": "object",
      "properties": {
        "externalData": {
          "$ref": "#/definitions/v1ExternalData"
        }
      }
    },
    "vegaOracleSpec": {
      "type": "object",
      "properties": {
        "externalDataSourceSpec": {
          "$ref": "#/definitions/vegaExternalDataSourceSpec"
        }
      },
      "title": "Oracle spec contains an embedded external data source spec.\nIt will be generated by the compiler as: OracleSpec_ExternalDataSourceSpec_*"
    },
    "vegaOrder": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique ID generated for the order."
        },
        "marketId": {
          "type": "string",
          "description": "Market ID for the order."
        },
        "partyId": {
          "type": "string",
          "description": "Party ID for the order."
        },
        "side": {
          "$ref": "#/definitions/vegaSide",
          "description": "Side for the order, e.g. SIDE_BUY or SIDE_SELL."
        },
        "price": {
          "type": "string",
          "description": "Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "size": {
          "type": "string",
          "format": "uint64",
          "description": "Size for the order, for example, in a futures market the size equals the number of contracts."
        },
        "remaining": {
          "type": "string",
          "format": "uint64",
          "description": "Size remaining, when this reaches 0 then the order is fully filled and status becomes STATUS_FILLED."
        },
        "timeInForce": {
          "$ref": "#/definitions/OrderTimeInForce",
          "title": "Time in force indicates how long an order will remain active before it is executed or expires.\n- See OrderTimeInForce"
        },
        "type": {
          "$ref": "#/definitions/vegaOrderType",
          "description": "Type for the order."
        },
        "createdAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the order was created at, in nanoseconds."
        },
        "status": {
          "$ref": "#/definitions/vegaOrderStatus",
          "description": "Current status of the order."
        },
        "expiresAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds for when the order will expire."
        },
        "reference": {
          "type": "string",
          "description": "Reference given for the order."
        },
        "reason": {
          "$ref": "#/definitions/vegaOrderError",
          "description": "Futher details for why an order with status `STATUS_REJECTED` was rejected."
        },
        "updatedAt": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds for when the order was last updated."
        },
        "version": {
          "type": "string",
          "format": "uint64",
          "description": "Version for the order, initial value is version 1 and is incremented after each successful amend."
        },
        "batchId": {
          "type": "string",
          "format": "uint64",
          "description": "Batch ID for the order, used internally for orders submitted during auctions\nto keep track of the auction batch this order falls under. Required for fees calculation."
        },
        "peggedOrder": {
          "$ref": "#/definitions/vegaPeggedOrder",
          "description": "Pegged order details, used only if the order represents a pegged order."
        },
        "liquidityProvisionId": {
          "type": "string",
          "description": "Set if the order was created as part of a liquidity provision, will be empty if not."
        },
        "postOnly": {
          "type": "boolean",
          "description": "Only valid for Limit orders. Cannot be True at the same time as Reduce-Only."
        },
        "reduceOnly": {
          "type": "boolean",
          "description": "Only valid for Non-Persistent orders. Cannot be True at the same time as Post-Only.\nIf set, order will only be executed if the outcome of the trade moves the trader's position closer to 0."
        },
        "icebergOrder": {
          "$ref": "#/definitions/vegaIcebergOrder",
          "title": "Details of an iceberg order"
        }
      },
      "title": "Orders can be submitted, amended and cancelled on Vega in an attempt to make trades with other parties"
    },
    "vegaOrderError": {
      "type": "string",
      "enum": [
        "ORDER_ERROR_UNSPECIFIED",
        "ORDER_ERROR_INVALID_MARKET_ID",
        "ORDER_ERROR_INVALID_ORDER_ID",
        "ORDER_ERROR_OUT_OF_SEQUENCE",
        "ORDER_ERROR_INVALID_REMAINING_SIZE",
        "ORDER_ERROR_TIME_FAILURE",
        "ORDER_ERROR_REMOVAL_FAILURE",
        "ORDER_ERROR_INVALID_EXPIRATION_DATETIME",
        "ORDER_ERROR_INVALID_ORDER_REFERENCE",
        "ORDER_ERROR_EDIT_NOT_ALLOWED",
        "ORDER_ERROR_AMEND_FAILURE",
        "ORDER_ERROR_NOT_FOUND",
        "ORDER_ERROR_INVALID_PARTY_ID",
        "ORDER_ERROR_MARKET_CLOSED",
        "ORDER_ERROR_MARGIN_CHECK_FAILED",
        "ORDER_ERROR_MISSING_GENERAL_ACCOUNT",
        "ORDER_ERROR_INTERNAL_ERROR",
        "ORDER_ERROR_INVALID_SIZE",
        "ORDER_ERROR_INVALID_PERSISTENCE",
        "ORDER_ERROR_INVALID_TYPE",
        "ORDER_ERROR_SELF_TRADING",
        "ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES",
        "ORDER_ERROR_INCORRECT_MARKET_TYPE",
        "ORDER_ERROR_INVALID_TIME_IN_FORCE",
        "ORDER_ERROR_CANNOT_SEND_GFN_ORDER_DURING_AN_AUCTION",
        "ORDER_ERROR_CANNOT_SEND_GFA_ORDER_DURING_CONTINUOUS_TRADING",
        "ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT",
        "ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT",
        "ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT",
        "ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC",
        "ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN",
        "ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN",
        "ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION",
        "ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION",
        "ORDER_ERROR_MUST_BE_LIMIT_ORDER",
        "ORDER_ERROR_MUST_BE_GTT_OR_GTC",
        "ORDER_ERROR_WITHOUT_REFERENCE_PRICE",
        "ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE",
        "ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO",
        "ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE",
        "ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO",
        "ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE",
        "ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER",
        "ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER",
        "ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER",
        "ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS",
        "ORDER_ERROR_TOO_MANY_PEGGED_ORDERS",
        "ORDER_ERROR_POST_ONLY_ORDER_WOULD_TRADE",
        "ORDER_ERROR_REDUCE_ONLY_ORDER_WOULD_NOT_REDUCE_POSITION",
        "ORDER_ERROR_ISOLATED_MARGIN_CHECK_FAILED",
        "ORDER_ERROR_PEGGED_ORDERS_NOT_ALLOWED_IN_ISOLATED_MARGIN_MODE",
        "ORDER_ERROR_PRICE_NOT_IN_TICK_SIZE",
        "ORDER_ERROR_PRICE_MUST_BE_LESS_THAN_OR_EQUAL_TO_MAX_PRICE"
      ],
      "default": "ORDER_ERROR_UNSPECIFIED",
      "description": "- ORDER_ERROR_UNSPECIFIED: Default value, no error reported\n - ORDER_ERROR_INVALID_MARKET_ID: Order was submitted for a market that does not exist\n - ORDER_ERROR_INVALID_ORDER_ID: Order was submitted with an invalid ID\n - ORDER_ERROR_OUT_OF_SEQUENCE: Order was amended with a sequence number that was not previous version + 1\n - ORDER_ERROR_INVALID_REMAINING_SIZE: Order was amended with an invalid remaining size (e.g. remaining greater than total size)\n - ORDER_ERROR_TIME_FAILURE: Node was unable to get Vega (blockchain) time\n - ORDER_ERROR_REMOVAL_FAILURE: Failed to remove an order from the book\n - ORDER_ERROR_INVALID_EXPIRATION_DATETIME: Order with `TimeInForce.TIME_IN_FORCE_GTT` was submitted or amended\nwith an expiration that was badly formatted or otherwise invalid\n - ORDER_ERROR_INVALID_ORDER_REFERENCE: Order was submitted or amended with an invalid reference field\n - ORDER_ERROR_EDIT_NOT_ALLOWED: Order amend was submitted for an order field that cannot not be amended (e.g. order ID)\n - ORDER_ERROR_AMEND_FAILURE: Amend failure because amend details do not match original order\n - ORDER_ERROR_NOT_FOUND: Order not found in an order book or store\n - ORDER_ERROR_INVALID_PARTY_ID: Order was submitted with an invalid or missing party ID\n - ORDER_ERROR_MARKET_CLOSED: Order was submitted for a market that has closed\n - ORDER_ERROR_MARGIN_CHECK_FAILED: Order was submitted, but the party did not have enough collateral to cover the order\n - ORDER_ERROR_MISSING_GENERAL_ACCOUNT: Order was submitted, but the party did not have an account for this asset\n - ORDER_ERROR_INTERNAL_ERROR: Unspecified internal error\n - ORDER_ERROR_INVALID_SIZE: Order was submitted with an invalid or missing size (e.g. 0)\n - ORDER_ERROR_INVALID_PERSISTENCE: Order was submitted with an invalid persistence for its type\n - ORDER_ERROR_INVALID_TYPE: Order was submitted with an invalid type field\n - ORDER_ERROR_SELF_TRADING: Order was stopped as it would have traded with another order submitted from the same party\n - ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES: Order was submitted, but the party did not have enough collateral to cover the fees for the order\n - ORDER_ERROR_INCORRECT_MARKET_TYPE: Order was submitted with an incorrect or invalid market type\n - ORDER_ERROR_INVALID_TIME_IN_FORCE: Order was submitted with invalid time in force\n - ORDER_ERROR_CANNOT_SEND_GFN_ORDER_DURING_AN_AUCTION: Good For Normal order has reached the market when it is in auction mode\n - ORDER_ERROR_CANNOT_SEND_GFA_ORDER_DURING_CONTINUOUS_TRADING: Good For Auction order has reached the market when it is in continuous trading mode\n - ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT: Attempt to amend order to GTT without ExpiryAt\n - ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT: Attempt to amend ExpiryAt to a value before CreatedAt\n - ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT: Attempt to amend to GTC without an ExpiryAt value\n - ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC: Amending to FOK or IOC is invalid\n - ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN: Amending to GFA or GFN is invalid\n - ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN: Amending from GFA or GFN is invalid\n - ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION: IOC orders are not allowed during auction\n - ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION: FOK orders are not allowed during auction\n - ORDER_ERROR_MUST_BE_LIMIT_ORDER: Pegged orders must be LIMIT orders\n - ORDER_ERROR_MUST_BE_GTT_OR_GTC: Pegged orders can only have TIF GTC or GTT\n - ORDER_ERROR_WITHOUT_REFERENCE_PRICE: Pegged order must have a reference price\n - ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE: Buy pegged order cannot reference best ask price\n - ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO: Pegged order offset must be \u003e= 0\n - ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE: Sell pegged order cannot reference best bid price\n - ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO: Pegged order offset must be \u003e zero\n - ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE: Party has an insufficient balance, or does not have\na general account to submit the order (no deposits made\nfor the required asset)\n - ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER: Cannot amend details of a non pegged details\n - ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER: Could not re-price a pegged order because a market price is unavailable\n - ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER: It is not possible to amend the price of an existing pegged order\n - ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS: FOK, IOC, or GFN order was rejected because it resulted in trades outside the price bounds\n - ORDER_ERROR_TOO_MANY_PEGGED_ORDERS: Unable to submit pegged order, temporarily too many pegged orders across all markets\n - ORDER_ERROR_POST_ONLY_ORDER_WOULD_TRADE: Post order would trade\n - ORDER_ERROR_REDUCE_ONLY_ORDER_WOULD_NOT_REDUCE_POSITION: Post order would trade\n - ORDER_ERROR_ISOLATED_MARGIN_CHECK_FAILED: Isolated margin check failed\n - ORDER_ERROR_PEGGED_ORDERS_NOT_ALLOWED_IN_ISOLATED_MARGIN_MODE: In isolated margin pegged orders are rejected\n - ORDER_ERROR_PRICE_NOT_IN_TICK_SIZE: Order price does not respect market's required tick size\n - ORDER_ERROR_PRICE_MUST_BE_LESS_THAN_OR_EQUAL_TO_MAX_PRICE: Order price exceeds the max price of the capped future market",
      "title": "OrderError codes are returned in the Order.reason field - If there is an issue\nwith an order during its life-cycle, it will be marked with `status.ORDER_STATUS_REJECTED`"
    },
    "vegaOrderStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_ACTIVE",
        "STATUS_EXPIRED",
        "STATUS_CANCELLED",
        "STATUS_STOPPED",
        "STATUS_FILLED",
        "STATUS_REJECTED",
        "STATUS_PARTIALLY_FILLED",
        "STATUS_PARKED"
      ],
      "default": "STATUS_UNSPECIFIED",
      "description": "- STATUS_UNSPECIFIED: Default value, always invalid\n - STATUS_ACTIVE: Used for active unfilled or partially filled orders\n - STATUS_EXPIRED: Used for expired GTT orders\n - STATUS_CANCELLED: Used for orders cancelled by the party that created the order\n - STATUS_STOPPED: Used for unfilled FOK or IOC orders, and for orders that were stopped by the network\n - STATUS_FILLED: Used for closed fully filled orders\n - STATUS_REJECTED: Used for orders when not enough collateral was available to fill the margin requirements\n - STATUS_PARTIALLY_FILLED: Used for closed partially filled IOC orders\n - STATUS_PARKED: Order has been removed from the order book and has been parked,\nthis applies to pegged orders and liquidity orders (orders created from a liquidity provision shape)",
      "title": "Status values for an order"
    },
    "vegaOrderType": {
      "type": "string",
      "enum": [
        "TYPE_UNSPECIFIED",
        "TYPE_LIMIT",
        "TYPE_MARKET",
        "TYPE_NETWORK"
      ],
      "default": "TYPE_UNSPECIFIED",
      "description": "- TYPE_UNSPECIFIED: Default value, always invalid\n - TYPE_LIMIT: Used for Limit orders\n - TYPE_MARKET: Used for Market orders\n - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)",
      "title": "Type values for an order"
    },
    "vegaParty": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique ID for the party, typically represented by a public key."
        },
        "alias": {
          "type": "string",
          "description": "Alias given to the party."
        },
        "metadata": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaMetadata"
          },
          "description": "Metadata to associate to a party, in a key/value format where the key\ndescribes the type of metadata in the value field."
        }
      },
      "title": "Party represents an entity who wishes to trade on or query a Vega network"
    },
    "vegaPartyProfile": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "description": "Party ID associated to the profile."
        },
        "alias": {
          "type": "string",
          "description": "Alias given to the party."
        },
        "metadata": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaMetadata"
          },
          "description": "Metadata to associate to a party, in a key/value format where the key\ndescribes the type of metadata in the value field."
        },
        "derivedKeys": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Derived keys for the party."
        }
      },
      "description": "Holds metadata associated to a party."
    },
    "vegaPeggedOrder": {
      "type": "object",
      "properties": {
        "reference": {
          "$ref": "#/definitions/vegaPeggedReference",
          "description": "Price point the order is linked to."
        },
        "offset": {
          "type": "string",
          "description": "Offset from the price reference."
        }
      },
      "title": "Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET\nThey can be used for any limit order that is valid during continuous trading"
    },
    "vegaPeggedReference": {
      "type": "string",
      "enum": [
        "PEGGED_REFERENCE_UNSPECIFIED",
        "PEGGED_REFERENCE_MID",
        "PEGGED_REFERENCE_BEST_BID",
        "PEGGED_REFERENCE_BEST_ASK"
      ],
      "default": "PEGGED_REFERENCE_UNSPECIFIED",
      "description": "- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference",
      "title": "Pegged reference defines which price point a pegged order is linked to - meaning\nthe price for a pegged order is calculated from the value of the reference price point"
    },
    "vegaPerpetual": {
      "type": "object",
      "properties": {
        "settlementAsset": {
          "type": "string",
          "description": "Underlying asset for the perpetual."
        },
        "quoteName": {
          "type": "string",
          "description": "Quote name of the instrument."
        },
        "marginFundingFactor": {
          "type": "string",
          "description": "Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1]."
        },
        "interestRate": {
          "type": "string",
          "description": "Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1]."
        },
        "clampLowerBound": {
          "type": "string",
          "description": "Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]."
        },
        "clampUpperBound": {
          "type": "string",
          "description": "Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]."
        },
        "dataSourceSpecForSettlementSchedule": {
          "$ref": "#/definitions/vegaDataSourceSpec",
          "description": "Data source spec describing the data source for settlement schedule."
        },
        "dataSourceSpecForSettlementData": {
          "$ref": "#/definitions/vegaDataSourceSpec",
          "description": "Data source spec describing the data source for settlement."
        },
        "dataSourceSpecBinding": {
          "$ref": "#/definitions/vegaDataSourceSpecToPerpetualBinding",
          "description": "Binding between the data source spec and the settlement data."
        },
        "fundingRateScalingFactor": {
          "type": "string",
          "description": "Factor applied to funding-rates. This scales the impact that spot price deviations have on funding payments."
        },
        "fundingRateLowerBound": {
          "type": "string",
          "description": "Lower bound for the funding-rate such that the funding-rate will never be lower than this value."
        },
        "fundingRateUpperBound": {
          "type": "string",
          "description": "Upper bound for the funding-rate such that the funding-rate will never be higher than this value."
        },
        "internalCompositePriceConfig": {
          "$ref": "#/definitions/vegaCompositePriceConfiguration",
          "description": "Optional configuration for the internal composite price used in funding payment calculation."
        }
      },
      "title": "Perpetual product definition"
    },
    "vegaPerpetualData": {
      "type": "object",
      "properties": {
        "fundingPayment": {
          "type": "string",
          "description": "Current funding payment for the in-progress funding period."
        },
        "fundingRate": {
          "type": "string",
          "description": "Current funding rate for the in-progress funding period."
        },
        "internalTwap": {
          "type": "string",
          "description": "Time-weighted-average the internal data-points for the in-progress funding period."
        },
        "externalTwap": {
          "type": "string",
          "description": "Time-weighted-average the external data points for the in-progress funding period."
        },
        "seqNum": {
          "type": "string",
          "format": "uint64",
          "title": "Funding period sequence number"
        },
        "startTime": {
          "type": "string",
          "format": "int64",
          "title": "Funding period start time"
        },
        "internalCompositePrice": {
          "type": "string",
          "description": "The internal composite price used for perpetual markets."
        },
        "nextInternalCompositePriceCalc": {
          "type": "string",
          "format": "int64",
          "description": "The next time the internal composite price is calculated for the perpetual market, in Unix nanoseconds."
        },
        "internalCompositePriceType": {
          "$ref": "#/definitions/vegaCompositePriceType",
          "description": "The method used for calculating the internal composite price, for perpetual markets only."
        },
        "underlyingIndexPrice": {
          "type": "string",
          "description": "Last seen value of the settlement oracle."
        },
        "internalCompositePriceState": {
          "$ref": "#/definitions/vegaCompositePriceState",
          "description": "State of the internal composite price."
        }
      },
      "description": "Represents market data specific to a perpetual market."
    },
    "vegaPerpetualProduct": {
      "type": "object",
      "properties": {
        "settlementAsset": {
          "type": "string",
          "description": "Asset ID for the product's settlement asset."
        },
        "quoteName": {
          "type": "string",
          "description": "Product quote name."
        },
        "marginFundingFactor": {
          "type": "string",
          "description": "Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1]."
        },
        "interestRate": {
          "type": "string",
          "description": "Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1]."
        },
        "clampLowerBound": {
          "type": "string",
          "description": "Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]."
        },
        "clampUpperBound": {
          "type": "string",
          "description": "Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]."
        },
        "dataSourceSpecForSettlementSchedule": {
          "$ref": "#/definitions/vegaDataSourceDefinition",
          "description": "Data source spec describing the data source for settlement schedule."
        },
        "dataSourceSpecForSettlementData": {
          "$ref": "#/definitions/vegaDataSourceDefinition",
          "description": "Data source spec describing the data source for settlement."
        },
        "dataSourceSpecBinding": {
          "$ref": "#/definitions/vegaDataSourceSpecToPerpetualBinding",
          "description": "Binding between the data source spec and the settlement data."
        },
        "fundingRateScalingFactor": {
          "type": "string",
          "description": "Factor applied to funding-rates. This scales the impact that spot price deviations have on funding payments."
        },
        "fundingRateLowerBound": {
          "type": "string",
          "description": "Lower bound for the funding-rate such that the funding-rate will never be lower than this value."
        },
        "fundingRateUpperBound": {
          "type": "string",
          "description": "Upper bound for the funding-rate such that the funding-rate will never be higher than this value."
        },
        "internalCompositePriceConfiguration": {
          "$ref": "#/definitions/vegaCompositePriceConfiguration",
          "description": "Composite price configuration to drive the calculation of the internal composite price used for funding payments. If undefined the default mark price of the market is used."
        }
      },
      "title": "Perpetual product configuration"
    },
    "vegaPostTransferBalance": {
      "type": "object",
      "properties": {
        "account": {
          "$ref": "#/definitions/vegaAccountDetails",
          "description": "Account relating to the transfer."
        },
        "balance": {
          "type": "string",
          "description": "Balance relating to the transfer. This field is an unsigned integer scaled to the asset's decimal places."
        }
      },
      "title": "Represents the balance for an account during a transfer"
    },
    "vegaPriceMonitoringBounds": {
      "type": "object",
      "properties": {
        "minValidPrice": {
          "type": "string",
          "description": "Minimum price that isn't currently breaching the specified price monitoring trigger.\nThis field is an unsigned integer scaled to the market's decimal places."
        },
        "maxValidPrice": {
          "type": "string",
          "description": "Maximum price that isn't currently breaching the specified price monitoring trigger.\nThis field is an unsigned integer scaled to the market's decimal places."
        },
        "trigger": {
          "$ref": "#/definitions/vegaPriceMonitoringTrigger",
          "description": "Price monitoring trigger associated with the bounds."
        },
        "referencePrice": {
          "type": "string",
          "description": "Reference price used to calculate the valid price range. This field is an unsigned integer scaled to the market's decimal places."
        },
        "active": {
          "type": "boolean",
          "description": "Has this bound been triggered yet or is it still active."
        }
      },
      "title": "Represents a list of valid (at the current timestamp) price ranges per associated trigger"
    },
    "vegaPriceMonitoringParameters": {
      "type": "object",
      "properties": {
        "triggers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaPriceMonitoringTrigger"
          }
        }
      },
      "title": "PriceMonitoringParameters contains a collection of triggers to be used for a given market"
    },
    "vegaPriceMonitoringSettings": {
      "type": "object",
      "properties": {
        "parameters": {
          "$ref": "#/definitions/vegaPriceMonitoringParameters",
          "description": "Specifies price monitoring parameters to be used for price monitoring purposes."
        }
      },
      "title": "PriceMonitoringSettings contains the settings for price monitoring"
    },
    "vegaPriceMonitoringTrigger": {
      "type": "object",
      "properties": {
        "horizon": {
          "type": "string",
          "format": "int64",
          "description": "Price monitoring projection horizon Ï„ in seconds."
        },
        "probability": {
          "type": "string",
          "description": "Price monitoring probability level p."
        },
        "auctionExtension": {
          "type": "string",
          "format": "int64",
          "description": "Price monitoring auction extension duration in seconds should the price\nbreach its theoretical level over the specified horizon at the specified\nprobability level."
        }
      },
      "title": "PriceMonitoringTrigger holds together price projection horizon Ï„, probability level p, and auction extension duration"
    },
    "vegaProductData": {
      "type": "object",
      "properties": {
        "perpetualData": {
          "$ref": "#/definitions/vegaPerpetualData"
        }
      },
      "description": "Represents market data specific to a particular product type."
    },
    "vegaProposal": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique proposal ID."
        },
        "reference": {
          "type": "string",
          "description": "Proposal reference."
        },
        "partyId": {
          "type": "string",
          "description": "Party ID i.e. public key of the party submitting the proposal."
        },
        "state": {
          "$ref": "#/definitions/vegaProposalState",
          "description": "Current state of the proposal, i.e. open, passed, failed etc."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Proposal timestamp for date and time as Unix time in nanoseconds when proposal was submitted to the network."
        },
        "terms": {
          "$ref": "#/definitions/vegaProposalTerms",
          "description": "Proposal configuration and the actual change that is meant to be executed when proposal is enacted.\nSingle proposal term."
        },
        "reason": {
          "$ref": "#/definitions/vegaProposalError",
          "description": "Reason for the current state of the proposal, this may be set in case of REJECTED and FAILED statuses."
        },
        "errorDetails": {
          "type": "string",
          "description": "Detailed error associated to the reason."
        },
        "rationale": {
          "$ref": "#/definitions/vegaProposalRationale",
          "description": "Rationale behind a proposal."
        },
        "requiredParticipation": {
          "type": "string",
          "description": "Required vote participation for this proposal."
        },
        "requiredMajority": {
          "type": "string",
          "description": "Required majority for this proposal."
        },
        "requiredLiquidityProviderParticipation": {
          "type": "string",
          "description": "Required participation from liquidity providers, optional but is required for market update proposal."
        },
        "requiredLiquidityProviderMajority": {
          "type": "string",
          "description": "Required majority from liquidity providers, optional but is required for market update proposal."
        },
        "batchTerms": {
          "$ref": "#/definitions/vegaBatchProposalTerms",
          "description": "Batch proposal terms."
        },
        "batchId": {
          "type": "string",
          "description": "ID of a batch proposal that this proposal is part of."
        }
      },
      "title": "Governance proposal"
    },
    "vegaProposalError": {
      "type": "string",
      "enum": [
        "PROPOSAL_ERROR_UNSPECIFIED",
        "PROPOSAL_ERROR_CLOSE_TIME_TOO_SOON",
        "PROPOSAL_ERROR_CLOSE_TIME_TOO_LATE",
        "PROPOSAL_ERROR_ENACT_TIME_TOO_SOON",
        "PROPOSAL_ERROR_ENACT_TIME_TOO_LATE",
        "PROPOSAL_ERROR_INSUFFICIENT_TOKENS",
        "PROPOSAL_ERROR_INVALID_INSTRUMENT_SECURITY",
        "PROPOSAL_ERROR_NO_PRODUCT",
        "PROPOSAL_ERROR_UNSUPPORTED_PRODUCT",
        "PROPOSAL_ERROR_NO_TRADING_MODE",
        "PROPOSAL_ERROR_UNSUPPORTED_TRADING_MODE",
        "PROPOSAL_ERROR_NODE_VALIDATION_FAILED",
        "PROPOSAL_ERROR_MISSING_BUILTIN_ASSET_FIELD",
        "PROPOSAL_ERROR_MISSING_ERC20_CONTRACT_ADDRESS",
        "PROPOSAL_ERROR_INVALID_ASSET",
        "PROPOSAL_ERROR_INCOMPATIBLE_TIMESTAMPS",
        "PROPOSAL_ERROR_NO_RISK_PARAMETERS",
        "PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_KEY",
        "PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_VALUE",
        "PROPOSAL_ERROR_NETWORK_PARAMETER_VALIDATION_FAILED",
        "PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_SMALL",
        "PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_LARGE",
        "PROPOSAL_ERROR_COULD_NOT_INSTANTIATE_MARKET",
        "PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT",
        "PROPOSAL_ERROR_INVALID_RISK_PARAMETER",
        "PROPOSAL_ERROR_MAJORITY_THRESHOLD_NOT_REACHED",
        "PROPOSAL_ERROR_PARTICIPATION_THRESHOLD_NOT_REACHED",
        "PROPOSAL_ERROR_INVALID_ASSET_DETAILS",
        "PROPOSAL_ERROR_UNKNOWN_TYPE",
        "PROPOSAL_ERROR_UNKNOWN_RISK_PARAMETER_TYPE",
        "PROPOSAL_ERROR_INVALID_FREEFORM",
        "PROPOSAL_ERROR_INSUFFICIENT_EQUITY_LIKE_SHARE",
        "PROPOSAL_ERROR_INVALID_MARKET",
        "PROPOSAL_ERROR_TOO_MANY_MARKET_DECIMAL_PLACES",
        "PROPOSAL_ERROR_TOO_MANY_PRICE_MONITORING_TRIGGERS",
        "PROPOSAL_ERROR_ERC20_ADDRESS_ALREADY_IN_USE",
        "PROPOSAL_ERROR_LP_PRICE_RANGE_NONPOSITIVE",
        "PROPOSAL_ERROR_LP_PRICE_RANGE_TOO_LARGE",
        "PROPOSAL_ERROR_LINEAR_SLIPPAGE_FACTOR_OUT_OF_RANGE",
        "PROPOSAL_ERROR_QUADRATIC_SLIPPAGE_FACTOR_OUT_OF_RANGE",
        "PROPOSAL_ERROR_INVALID_SPOT",
        "PROPOSAL_ERROR_SPOT_PRODUCT_DISABLED",
        "PROPOSAL_ERROR_INVALID_SUCCESSOR_MARKET",
        "PROPOSAL_ERROR_GOVERNANCE_TRANSFER_PROPOSAL_FAILED",
        "PROPOSAL_ERROR_GOVERNANCE_TRANSFER_PROPOSAL_INVALID",
        "PROPOSAL_ERROR_GOVERNANCE_CANCEL_TRANSFER_PROPOSAL_INVALID",
        "PROPOSAL_ERROR_INVALID_MARKET_STATE_UPDATE",
        "PROPOSAL_ERROR_INVALID_SLA_PARAMS",
        "PROPOSAL_ERROR_MISSING_SLA_PARAMS",
        "PROPOSAL_ERROR_INVALID_PERPETUAL_PRODUCT",
        "PROPOSAL_ERROR_INVALID_REFERRAL_PROGRAM",
        "PROPOSAL_ERROR_INVALID_VOLUME_DISCOUNT_PROGRAM",
        "PROPOSAL_ERROR_PROPOSAL_IN_BATCH_REJECTED",
        "PROPOSAL_ERROR_PROPOSAL_IN_BATCH_DECLINED",
        "PROPOSAL_ERROR_INVALID_SIZE_DECIMAL_PLACES",
        "PROPOSAL_ERROR_INVALID_VOLUME_REBATE_PROGRAM"
      ],
      "default": "PROPOSAL_ERROR_UNSPECIFIED",
      "description": "- PROPOSAL_ERROR_UNSPECIFIED: Default value\n - PROPOSAL_ERROR_CLOSE_TIME_TOO_SOON: Specified close time is too early based on network parameters\n - PROPOSAL_ERROR_CLOSE_TIME_TOO_LATE: Specified close time is too late based on network parameters\n - PROPOSAL_ERROR_ENACT_TIME_TOO_SOON: Specified enactment time is too early based on network parameters\n - PROPOSAL_ERROR_ENACT_TIME_TOO_LATE: Specified enactment time is too late based on network parameters\n - PROPOSAL_ERROR_INSUFFICIENT_TOKENS: Proposer for this proposal has insufficient tokens\n - PROPOSAL_ERROR_INVALID_INSTRUMENT_SECURITY: Instrument quote name and base name were the same\n - PROPOSAL_ERROR_NO_PRODUCT: Proposal has no product\n - PROPOSAL_ERROR_UNSUPPORTED_PRODUCT: Specified product is not supported\n - PROPOSAL_ERROR_NO_TRADING_MODE: Proposal has no trading mode\n - PROPOSAL_ERROR_UNSUPPORTED_TRADING_MODE: Proposal has an unsupported trading mode\n - PROPOSAL_ERROR_NODE_VALIDATION_FAILED: Proposal failed node validation\n - PROPOSAL_ERROR_MISSING_BUILTIN_ASSET_FIELD: Field is missing in a builtin asset source\n - PROPOSAL_ERROR_MISSING_ERC20_CONTRACT_ADDRESS: Contract address is missing in the ERC20 asset source\n - PROPOSAL_ERROR_INVALID_ASSET: Asset ID is invalid or does not exist on the Vega network\n - PROPOSAL_ERROR_INCOMPATIBLE_TIMESTAMPS: Proposal terms timestamps are not compatible (Validation \u003c Closing \u003c Enactment)\n - PROPOSAL_ERROR_NO_RISK_PARAMETERS: No risk parameters were specified\n - PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_KEY: Invalid key in update network parameter proposal\n - PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_VALUE: Invalid value in update network parameter proposal\n - PROPOSAL_ERROR_NETWORK_PARAMETER_VALIDATION_FAILED: Validation failed for network parameter proposal\n - PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_SMALL: Opening auction duration is less than the network minimum opening auction time\n - PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_LARGE: Opening auction duration is more than the network minimum opening auction time\n - PROPOSAL_ERROR_COULD_NOT_INSTANTIATE_MARKET: Market proposal market could not be instantiated in execution\n - PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT: Market proposal market contained invalid product definition\n - PROPOSAL_ERROR_INVALID_RISK_PARAMETER: Market proposal has invalid risk parameter\n - PROPOSAL_ERROR_MAJORITY_THRESHOLD_NOT_REACHED: Proposal was declined because vote didn't reach the majority threshold required\n - PROPOSAL_ERROR_PARTICIPATION_THRESHOLD_NOT_REACHED: Proposal declined because the participation threshold was not reached\n - PROPOSAL_ERROR_INVALID_ASSET_DETAILS: Asset proposal has invalid asset details\n - PROPOSAL_ERROR_UNKNOWN_TYPE: Proposal is an unknown type\n - PROPOSAL_ERROR_UNKNOWN_RISK_PARAMETER_TYPE: Proposal has an unknown risk parameter type\n - PROPOSAL_ERROR_INVALID_FREEFORM: Validation failed for freeform proposal\n - PROPOSAL_ERROR_INSUFFICIENT_EQUITY_LIKE_SHARE: Party doesn't have enough equity-like share to propose an update on the market\ntargeted by the proposal\n - PROPOSAL_ERROR_INVALID_MARKET: Market targeted by the proposal does not exist or is not eligible for modification\n - PROPOSAL_ERROR_TOO_MANY_MARKET_DECIMAL_PLACES: Market proposal decimal place is higher than the market settlement asset decimal places\n - PROPOSAL_ERROR_TOO_MANY_PRICE_MONITORING_TRIGGERS: Market proposal contains too many price monitoring triggers\n - PROPOSAL_ERROR_ERC20_ADDRESS_ALREADY_IN_USE: Market proposal contains too many price monitoring triggers\n - PROPOSAL_ERROR_LP_PRICE_RANGE_NONPOSITIVE: LP price range must be larger than 0\n - PROPOSAL_ERROR_LP_PRICE_RANGE_TOO_LARGE: LP price range must not be larger than 100\n - PROPOSAL_ERROR_LINEAR_SLIPPAGE_FACTOR_OUT_OF_RANGE: Linear slippage factor is out of range, either negative or too large\n - PROPOSAL_ERROR_QUADRATIC_SLIPPAGE_FACTOR_OUT_OF_RANGE: Quadratic slippage factor is out of range, either negative or too large\n - PROPOSAL_ERROR_INVALID_SPOT: Validation failed for spot proposal\n - PROPOSAL_ERROR_SPOT_PRODUCT_DISABLED: Spot trading not enabled\n - PROPOSAL_ERROR_INVALID_SUCCESSOR_MARKET: Market proposal is invalid, either invalid insurance pool fraction, or it specifies a parent market that it can't succeed.\n - PROPOSAL_ERROR_GOVERNANCE_TRANSFER_PROPOSAL_FAILED: Governance transfer proposal is invalid\n - PROPOSAL_ERROR_GOVERNANCE_TRANSFER_PROPOSAL_INVALID: Governance transfer proposal failed\n - PROPOSAL_ERROR_GOVERNANCE_CANCEL_TRANSFER_PROPOSAL_INVALID: Proposal for cancelling transfer is invalid, check proposal ID\n - PROPOSAL_ERROR_INVALID_MARKET_STATE_UPDATE: Proposal for updating market state is invalid\n - PROPOSAL_ERROR_INVALID_SLA_PARAMS: Liquidity provision SLA parameters are invalid\n - PROPOSAL_ERROR_MISSING_SLA_PARAMS: Mandatory liquidity provision SLA parameters are missing\n - PROPOSAL_ERROR_INVALID_PERPETUAL_PRODUCT: Perpetual market proposal contained invalid product definition\n - PROPOSAL_ERROR_INVALID_REFERRAL_PROGRAM: Referral program proposal is invalid\n - PROPOSAL_ERROR_INVALID_VOLUME_DISCOUNT_PROGRAM: Volume discount program proposal is invalid\n - PROPOSAL_ERROR_PROPOSAL_IN_BATCH_REJECTED: One or more proposals in a batch has been rejected\n - PROPOSAL_ERROR_PROPOSAL_IN_BATCH_DECLINED: One or more proposals in a batch has been declined\n - PROPOSAL_ERROR_INVALID_SIZE_DECIMAL_PLACES: Spot market decimal places cannot be greater than the base assetâ€™s decimal places\n - PROPOSAL_ERROR_INVALID_VOLUME_REBATE_PROGRAM: Volume rebate program proposal is invalid",
      "title": "List of possible errors that can cause a proposal to be in state rejected or failed"
    },
    "vegaProposalParameters": {
      "type": "object",
      "properties": {
        "minClose": {
          "type": "string",
          "format": "int64",
          "description": "Represents the minimum time before a proposal can be closed for voting."
        },
        "maxClose": {
          "type": "string",
          "format": "int64",
          "description": "Represents the maximum time that a proposal can be open for voting."
        },
        "minEnact": {
          "type": "string",
          "format": "int64",
          "description": "Represents the minimum time before an enacted proposal takes effect."
        },
        "maxEnact": {
          "type": "string",
          "format": "int64",
          "description": "Represents the maximum time before an enacted proposal must take effect."
        },
        "requiredParticipation": {
          "type": "string",
          "description": "Specifies the required percentage of eligible participants that must partake in the proposal for it to be valid."
        },
        "requiredMajority": {
          "type": "string",
          "description": "Specifies the required percentage of votes a proposal needs to be approved."
        },
        "minProposerBalance": {
          "type": "string",
          "description": "Specifies the minimum governance token balance a proposer must hold to initiate a proposal."
        },
        "minVoterBalance": {
          "type": "string",
          "description": "Specifies the minimum governance token balance a voter must hold to participate in voting."
        },
        "requiredParticipationLp": {
          "type": "string",
          "description": "Specifies the required percentage of participation from liquidity providers for the proposal to be valid."
        },
        "requiredMajorityLp": {
          "type": "string",
          "description": "Specifies the required majority percentage from liquidity providers for a proposal to be approved."
        },
        "minEquityLikeShare": {
          "type": "string",
          "description": "Specifies the minimum share that is akin to equity, which a participant must hold for their vote to be eligible."
        }
      }
    },
    "vegaProposalRationale": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string",
          "description": "Description to show a short title / something in case the link goes offline.\nThis is to be between 0 and 20k unicode characters.\nThis is mandatory for all proposals."
        },
        "title": {
          "type": "string",
          "description": "Title to be used to give a short description of the proposal in lists.\nThis is to be between 0 and 100 unicode characters.\nThis is mandatory for all proposals."
        }
      },
      "description": "Rationale behind a proposal."
    },
    "vegaProposalState": {
      "type": "string",
      "enum": [
        "STATE_UNSPECIFIED",
        "STATE_FAILED",
        "STATE_OPEN",
        "STATE_PASSED",
        "STATE_REJECTED",
        "STATE_DECLINED",
        "STATE_ENACTED",
        "STATE_WAITING_FOR_NODE_VOTE"
      ],
      "default": "STATE_UNSPECIFIED",
      "description": "- STATE_UNSPECIFIED: Default value, always invalid\n - STATE_FAILED: Proposal enactment has failed - even though proposal has passed, its execution could not be performed\n - STATE_OPEN: Proposal is open for voting\n - STATE_PASSED: Proposal has gained enough support to be executed\n - STATE_REJECTED: Proposal wasn't accepted i.e. proposal terms failed validation due to wrong configuration or failed to meet network requirements.\n - STATE_DECLINED: Proposal didn't get enough votes, e.g. either failed to gain required participation or majority level.\n - STATE_ENACTED: Proposal enacted.\n - STATE_WAITING_FOR_NODE_VOTE: Waiting for node validation of the proposal",
      "title": "Proposal state transition:\nOpen -\u003e\n  - Passed -\u003e Enacted.\n  - Passed -\u003e Failed.\n  - Declined\nRejected\nProposal can enter Failed state from any other state"
    },
    "vegaProposalTerms": {
      "type": "object",
      "properties": {
        "closingTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp as Unix time in seconds when voting closes for this proposal,\nconstrained by `minClose` and `maxClose` network parameters."
        },
        "enactmentTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp as Unix time in seconds when proposal gets enacted if passed,\nconstrained by `minEnact` and `maxEnact` network parameters."
        },
        "validationTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Validation timestamp as Unix time in seconds."
        },
        "updateMarket": {
          "$ref": "#/definitions/vegaUpdateMarket",
          "description": "Proposal change for modifying an existing futures market on Vega."
        },
        "newMarket": {
          "$ref": "#/definitions/vegaNewMarket",
          "description": "Proposal change for creating new futures market on Vega."
        },
        "updateNetworkParameter": {
          "$ref": "#/definitions/vegaUpdateNetworkParameter",
          "description": "Proposal change for updating Vega network parameters."
        },
        "newAsset": {
          "$ref": "#/definitions/vegaNewAsset",
          "description": "Proposal change for creating new assets on Vega."
        },
        "newFreeform": {
          "$ref": "#/definitions/vegaNewFreeform",
          "description": "Proposal change for a freeform request, which can be voted on but does not change the behaviour of the system,\nand can be used to gauge community sentiment."
        },
        "updateAsset": {
          "$ref": "#/definitions/vegaUpdateAsset",
          "description": "Proposal change for updating an asset."
        },
        "newSpotMarket": {
          "$ref": "#/definitions/vegaNewSpotMarket",
          "description": "Proposal change for creating new spot market on Vega."
        },
        "updateSpotMarket": {
          "$ref": "#/definitions/vegaUpdateSpotMarket",
          "description": "Proposal change for modifying an existing spot market on Vega."
        },
        "newTransfer": {
          "$ref": "#/definitions/vegaNewTransfer",
          "description": "Proposal change for a governance transfer."
        },
        "cancelTransfer": {
          "$ref": "#/definitions/vegaCancelTransfer",
          "description": "Cancel a governance transfer."
        },
        "updateMarketState": {
          "$ref": "#/definitions/vegaUpdateMarketState",
          "description": "Proposal change for updating the state of a market."
        },
        "updateReferralProgram": {
          "$ref": "#/definitions/vegaUpdateReferralProgram",
          "description": "Proposal change for updating the referral program."
        },
        "updateVolumeDiscountProgram": {
          "$ref": "#/definitions/vegaUpdateVolumeDiscountProgram",
          "description": "Proposal change for updating the volume discount program."
        },
        "updateVolumeRebateProgram": {
          "$ref": "#/definitions/vegaUpdateVolumeRebateProgram",
          "description": "Proposal change for updating the volume rebate program."
        }
      },
      "title": "Terms for a governance proposal on Vega"
    },
    "vegaRank": {
      "type": "object",
      "properties": {
        "startRank": {
          "type": "integer",
          "format": "int64"
        },
        "shareRatio": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "vegaRecurringTransfer": {
      "type": "object",
      "properties": {
        "startEpoch": {
          "type": "string",
          "format": "uint64"
        },
        "endEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Last epoch at which this transfer shall be paid."
        },
        "dispatchStrategy": {
          "$ref": "#/definitions/vegaDispatchStrategy",
          "description": "Optional parameter defining how a transfer is dispatched."
        },
        "factor": {
          "type": "string",
          "description": "Factor that the initial transfer amount is multiplied by for each epoch that it is executed.\nFor example if the initial transfer amount is 1000 and the factor is 0.5, then the amounts transferred per epoch will be 1000, 500, 250, 125, etc."
        }
      },
      "title": "Specific details for a recurring transfer"
    },
    "vegaReferralProgram": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "uint64",
          "description": "Incremental version of the program. It is incremented after each program\nupdate."
        },
        "id": {
          "type": "string",
          "description": "Unique ID generated from the proposal that created this program."
        },
        "benefitTiers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaBenefitTier"
          },
          "description": "Defined benefit tiers ordered by increasing discounts."
        },
        "endOfProgramTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds, after which when the current epoch ends,\nthe program will end and benefits will be disabled."
        },
        "windowLength": {
          "type": "string",
          "format": "uint64",
          "description": "Number of epochs over which the referral set's running volume is evaluated."
        },
        "stakingTiers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaStakingTier"
          },
          "description": "Defined benefit tiers ordered by increasing reward multiplier. Determines the level of\nbenefit a party can expect based on their staking."
        }
      }
    },
    "vegaReferralProgramChanges": {
      "type": "object",
      "properties": {
        "benefitTiers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaBenefitTier"
          },
          "description": "Defined benefit tiers in increasing order. First element will give Tier 1,\nsecond element will give Tier 2, and so on. Determines the level of\nbenefit a party can expect based on performance criteria."
        },
        "endOfProgramTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp as Unix time in seconds, after which when the current epoch\nends, the program will end and benefits will be disabled."
        },
        "windowLength": {
          "type": "string",
          "format": "uint64",
          "description": "Number of epochs over which to evaluate a referral set's running volume."
        },
        "stakingTiers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaStakingTier"
          },
          "description": "Defined staking tiers in increasing order. First element will give Tier 1,\nsecond element will give Tier 2, and so on. Determines the level of\nbenefit a party can expect based on their staking."
        }
      }
    },
    "vegaRewardFactors": {
      "type": "object",
      "properties": {
        "infrastructureRewardFactor": {
          "type": "string",
          "description": "Proportion of the referee's infrastructure fees to be rewarded to the referrer."
        },
        "liquidityRewardFactor": {
          "type": "string",
          "description": "Proportion of the referee's liquidity fees to be rewarded to the referrer."
        },
        "makerRewardFactor": {
          "type": "string",
          "description": "Proportion of the maker fees to be rewarded."
        }
      }
    },
    "vegaRiskFactor": {
      "type": "object",
      "properties": {
        "market": {
          "type": "string",
          "description": "Market ID that relates to this risk factor."
        },
        "short": {
          "type": "string",
          "description": "Short Risk factor value."
        },
        "long": {
          "type": "string",
          "description": "Long Risk factor value."
        }
      },
      "title": "Risk factors are used to calculate the current risk associated with orders trading on a given market"
    },
    "vegaRiskFactorOverride": {
      "type": "object",
      "properties": {
        "short": {
          "type": "string",
          "description": "Short Risk factor value."
        },
        "long": {
          "type": "string",
          "description": "Long Risk factor value."
        }
      },
      "title": "Risk factor override to control stable leverage"
    },
    "vegaScalingFactors": {
      "type": "object",
      "properties": {
        "searchLevel": {
          "type": "number",
          "format": "double",
          "description": "Collateral search level. If collateral dips below this value,\nthe system will search for collateral to release."
        },
        "initialMargin": {
          "type": "number",
          "format": "double",
          "description": "Initial margin level. This is the minimum amount of collateral\nrequired to open a position in a market that requires margin."
        },
        "collateralRelease": {
          "type": "number",
          "format": "double",
          "description": "Collateral release level. If a trader has collateral above this level,\nthe system will release collateral to a trader's general collateral account\nfor the asset."
        }
      },
      "title": "Scaling Factors (for use in margin calculation)"
    },
    "vegaSide": {
      "type": "string",
      "enum": [
        "SIDE_UNSPECIFIED",
        "SIDE_BUY",
        "SIDE_SELL"
      ],
      "default": "SIDE_UNSPECIFIED",
      "description": "- SIDE_UNSPECIFIED: Default value, always invalid\n - SIDE_BUY: Buy order\n - SIDE_SELL: Sell order",
      "title": "Side relates to the direction of an order, to Buy, or Sell"
    },
    "vegaSimpleModelParams": {
      "type": "object",
      "properties": {
        "factorLong": {
          "type": "number",
          "format": "double",
          "description": "Pre-defined risk factor value for long."
        },
        "factorShort": {
          "type": "number",
          "format": "double",
          "description": "Pre-defined risk factor value for short."
        },
        "maxMoveUp": {
          "type": "number",
          "format": "double",
          "description": "Pre-defined maximum price move up that the model considers as valid."
        },
        "minMoveDown": {
          "type": "number",
          "format": "double",
          "description": "Pre-defined minimum price move down that the model considers as valid."
        },
        "probabilityOfTrading": {
          "type": "number",
          "format": "double",
          "description": "Pre-defined constant probability of trading."
        }
      },
      "title": "Risk model parameters for simple modelling"
    },
    "vegaSimpleRiskModel": {
      "type": "object",
      "properties": {
        "params": {
          "$ref": "#/definitions/vegaSimpleModelParams",
          "description": "Risk model params for simple modelling."
        }
      },
      "title": "Risk model for simple modelling"
    },
    "vegaSpecBindingForCompositePrice": {
      "type": "object",
      "properties": {
        "priceSourceProperty": {
          "type": "string",
          "description": "The property name of price."
        }
      },
      "description": "Describes which property of the data source data is to be\nused for price source."
    },
    "vegaSpot": {
      "type": "object",
      "properties": {
        "baseAsset": {
          "type": "string",
          "description": "Asset ID of the underlying base asset for the spot product."
        },
        "quoteAsset": {
          "type": "string",
          "description": "Asset ID of the underlying quote asset for the spot product."
        }
      },
      "title": "Spot product definition"
    },
    "vegaSpotProduct": {
      "type": "object",
      "properties": {
        "baseAsset": {
          "type": "string",
          "description": "Base asset ID."
        },
        "quoteAsset": {
          "type": "string",
          "description": "Quote asset ID."
        }
      },
      "title": "Spot product configuration"
    },
    "vegaStakingTier": {
      "type": "object",
      "properties": {
        "minimumStakedTokens": {
          "type": "string",
          "description": "Required number of governance tokens ($VEGA) a referrer must have staked to\nreceive the multiplier."
        },
        "referralRewardMultiplier": {
          "type": "string",
          "description": "Multiplier applied to the referral reward factor when calculating referral\nrewards due to the referrer."
        }
      }
    },
    "vegaStopOrder": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "title": "ID of this stop order\nalso the ID of the associated order if it is ever triggered"
        },
        "ocoLinkId": {
          "type": "string",
          "title": "The ID of the 'other' part of the OCO if 2 stop orders were submitted at once"
        },
        "expiresAt": {
          "type": "string",
          "format": "int64",
          "description": "Optional expiry timestamp."
        },
        "expiryStrategy": {
          "$ref": "#/definitions/StopOrderExpiryStrategy",
          "description": "Strategy to adopt if the expiry time is reached."
        },
        "triggerDirection": {
          "$ref": "#/definitions/StopOrderTriggerDirection",
          "description": "Trigger direction for this stop order."
        },
        "status": {
          "$ref": "#/definitions/vegaStopOrderStatus",
          "description": "Status of the stop order."
        },
        "createdAt": {
          "type": "string",
          "format": "int64",
          "description": "Creation time of the stop order."
        },
        "updatedAt": {
          "type": "string",
          "format": "int64",
          "description": "Last update of this stop order."
        },
        "orderId": {
          "type": "string",
          "description": "ID of the order created once the trigger is hit."
        },
        "partyId": {
          "type": "string",
          "description": "ID of the party that submitted this stop order."
        },
        "marketId": {
          "type": "string",
          "description": "ID of the market the stop order is submitted to."
        },
        "rejectionReason": {
          "$ref": "#/definitions/StopOrderRejectionReason",
          "title": "An optional reason for why a stop order was rejected"
        },
        "sizeOverrideSetting": {
          "$ref": "#/definitions/StopOrderSizeOverrideSetting",
          "title": "Size override setting"
        },
        "sizeOverrideValue": {
          "$ref": "#/definitions/StopOrderSizeOverrideValue",
          "title": "Size override value"
        },
        "price": {
          "type": "string",
          "description": "Fixed price at which the order will be submitted."
        },
        "trailingPercentOffset": {
          "type": "string",
          "title": "Trailing percentage at which the order will be submitted.\nThis should be expressed as a decimal value between 0 and 1, e.g. 0.01 for 1%"
        }
      }
    },
    "vegaStopOrderStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_PENDING",
        "STATUS_CANCELLED",
        "STATUS_STOPPED",
        "STATUS_TRIGGERED",
        "STATUS_EXPIRED",
        "STATUS_REJECTED"
      ],
      "default": "STATUS_UNSPECIFIED",
      "title": "- STATUS_UNSPECIFIED: Never valid\n - STATUS_PENDING: Pending to be executed once the trigger is breached\n - STATUS_CANCELLED: Cancelled by the user\n - STATUS_STOPPED: Stopped by the network, e.g: OCO on the other side has been triggered\n - STATUS_TRIGGERED: Stop order has been triggered and generated an order\n - STATUS_EXPIRED: Stop order has expired\n - STATUS_REJECTED: Stop order was rejected at submission"
    },
    "vegaSuccessorConfiguration": {
      "type": "object",
      "properties": {
        "parentMarketId": {
          "type": "string",
          "description": "ID of the market that the successor should take over from."
        },
        "insurancePoolFraction": {
          "type": "string",
          "description": "A decimal value between or equal to 0 and 1, specifying the fraction of the insurance pool balance that is carried over from the parent market to the successor."
        }
      },
      "description": "Configuration required to turn a new market proposal in to a successor market proposal."
    },
    "vegaTargetStakeParameters": {
      "type": "object",
      "properties": {
        "timeWindow": {
          "type": "string",
          "format": "int64",
          "description": "Specifies length of time window expressed in seconds for target stake calculation."
        },
        "scalingFactor": {
          "type": "number",
          "format": "double",
          "description": "Specifies scaling factors used in target stake calculation."
        }
      },
      "title": "TargetStakeParameters contains parameters used in target stake calculation"
    },
    "vegaTradableInstrument": {
      "type": "object",
      "properties": {
        "instrument": {
          "$ref": "#/definitions/vegaInstrument",
          "description": "Details for the underlying instrument."
        },
        "marginCalculator": {
          "$ref": "#/definitions/vegaMarginCalculator",
          "description": "Margin calculator for the instrument."
        },
        "logNormalRiskModel": {
          "$ref": "#/definitions/vegaLogNormalRiskModel",
          "description": "Log normal."
        },
        "simpleRiskModel": {
          "$ref": "#/definitions/vegaSimpleRiskModel",
          "description": "Simple."
        }
      },
      "title": "Tradable Instrument definition"
    },
    "vegaTrade": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique ID for the trade."
        },
        "marketId": {
          "type": "string",
          "description": "Market ID on which the trade occurred."
        },
        "price": {
          "type": "string",
          "description": "Price for the trade, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places."
        },
        "size": {
          "type": "string",
          "format": "uint64",
          "description": "Size filled for the trade."
        },
        "buyer": {
          "type": "string",
          "description": "Unique party ID for the buyer."
        },
        "seller": {
          "type": "string",
          "description": "Unique party ID for the seller."
        },
        "aggressor": {
          "$ref": "#/definitions/vegaSide",
          "description": "Direction of the aggressive party e.g. SIDE_BUY or SIDE_SELL."
        },
        "buyOrder": {
          "type": "string",
          "description": "Identifier of the order from the buy side."
        },
        "sellOrder": {
          "type": "string",
          "description": "Identifier of the order from the sell side."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds for when the trade occurred."
        },
        "type": {
          "$ref": "#/definitions/vegaTradeType",
          "description": "Type for the trade."
        },
        "buyerFee": {
          "$ref": "#/definitions/vegaFee",
          "description": "Fee amount charged to the buyer party for the trade."
        },
        "sellerFee": {
          "$ref": "#/definitions/vegaFee",
          "description": "Fee amount charged to the seller party for the trade."
        },
        "buyerAuctionBatch": {
          "type": "string",
          "format": "uint64",
          "description": "Auction batch number that the buy side order was placed in."
        },
        "sellerAuctionBatch": {
          "type": "string",
          "format": "uint64",
          "description": "Auction batch number that the sell side order was placed in."
        },
        "assetPrice": {
          "type": "string",
          "description": "Price for the trade using asset decimals, as opposed to market decimals used\nin the price field. This is only used in trade events for position updates."
        }
      },
      "title": "A trade occurs when an aggressive order crosses one or more passive orders on the order book for a market on Vega"
    },
    "vegaTradeType": {
      "type": "string",
      "enum": [
        "TYPE_UNSPECIFIED",
        "TYPE_DEFAULT",
        "TYPE_NETWORK_CLOSE_OUT_GOOD",
        "TYPE_NETWORK_CLOSE_OUT_BAD"
      ],
      "default": "TYPE_UNSPECIFIED",
      "description": "- TYPE_UNSPECIFIED: Default value, always invalid\n - TYPE_DEFAULT: Normal trading between two parties\n - TYPE_NETWORK_CLOSE_OUT_GOOD: Trading initiated by the network with another party on the book,\nwhich helps to zero-out the positions of one or more distressed parties\n - TYPE_NETWORK_CLOSE_OUT_BAD: Trading initiated by the network with another party off the book,\nwith a distressed party in order to zero-out the position of the party",
      "title": "Type values for a trade"
    },
    "vegaTransferType": {
      "type": "string",
      "enum": [
        "TRANSFER_TYPE_UNSPECIFIED",
        "TRANSFER_TYPE_LOSS",
        "TRANSFER_TYPE_WIN",
        "TRANSFER_TYPE_MTM_LOSS",
        "TRANSFER_TYPE_MTM_WIN",
        "TRANSFER_TYPE_MARGIN_LOW",
        "TRANSFER_TYPE_MARGIN_HIGH",
        "TRANSFER_TYPE_MARGIN_CONFISCATED",
        "TRANSFER_TYPE_MAKER_FEE_PAY",
        "TRANSFER_TYPE_MAKER_FEE_RECEIVE",
        "TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY",
        "TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE",
        "TRANSFER_TYPE_LIQUIDITY_FEE_PAY",
        "TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE",
        "TRANSFER_TYPE_BOND_LOW",
        "TRANSFER_TYPE_BOND_HIGH",
        "TRANSFER_TYPE_WITHDRAW",
        "TRANSFER_TYPE_DEPOSIT",
        "TRANSFER_TYPE_BOND_SLASHING",
        "TRANSFER_TYPE_REWARD_PAYOUT",
        "TRANSFER_TYPE_TRANSFER_FUNDS_SEND",
        "TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE",
        "TRANSFER_TYPE_CLEAR_ACCOUNT",
        "TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE",
        "TRANSFER_TYPE_SPOT",
        "TRANSFER_TYPE_HOLDING_LOCK",
        "TRANSFER_TYPE_HOLDING_RELEASE",
        "TRANSFER_TYPE_SUCCESSOR_INSURANCE_FRACTION",
        "TRANSFER_TYPE_LIQUIDITY_FEE_ALLOCATE",
        "TRANSFER_TYPE_LIQUIDITY_FEE_NET_DISTRIBUTE",
        "TRANSFER_TYPE_SLA_PENALTY_BOND_APPLY",
        "TRANSFER_TYPE_SLA_PENALTY_LP_FEE_APPLY",
        "TRANSFER_TYPE_LIQUIDITY_FEE_UNPAID_COLLECT",
        "TRANSFER_TYPE_SLA_PERFORMANCE_BONUS_DISTRIBUTE",
        "TRANSFER_TYPE_PERPETUALS_FUNDING_LOSS",
        "TRANSFER_TYPE_PERPETUALS_FUNDING_WIN",
        "TRANSFER_TYPE_REWARDS_VESTED",
        "TRANSFER_TYPE_FEE_REFERRER_REWARD_PAY",
        "TRANSFER_TYPE_FEE_REFERRER_REWARD_DISTRIBUTE",
        "TRANSFER_TYPE_ORDER_MARGIN_LOW",
        "TRANSFER_TYPE_ORDER_MARGIN_HIGH",
        "TRANSFER_TYPE_ISOLATED_MARGIN_LOW",
        "TRANSFER_TYPE_ISOLATED_MARGIN_HIGH",
        "TRANSFER_TYPE_AMM_LOW",
        "TRANSFER_TYPE_AMM_HIGH",
        "TRANSFER_TYPE_AMM_RELEASE",
        "TRANSFER_TYPE_TREASURY_FEE_PAY",
        "TRANSFER_TYPE_BUY_BACK_FEE_PAY",
        "TRANSFER_TYPE_HIGH_MAKER_FEE_REBATE_PAY",
        "TRANSFER_TYPE_HIGH_MAKER_FEE_REBATE_RECEIVE"
      ],
      "default": "TRANSFER_TYPE_UNSPECIFIED",
      "description": "- TRANSFER_TYPE_UNSPECIFIED: Default value, always invalid\n - TRANSFER_TYPE_LOSS: Funds deducted after final settlement loss\n - TRANSFER_TYPE_WIN: Funds added to general account after final settlement gain\n - TRANSFER_TYPE_MTM_LOSS: Funds deducted from margin account after mark to market loss\n - TRANSFER_TYPE_MTM_WIN: Funds added to margin account after mark to market gain\n - TRANSFER_TYPE_MARGIN_LOW: Funds transferred from general account to meet margin requirement\n - TRANSFER_TYPE_MARGIN_HIGH: Excess margin amount returned to general account\n - TRANSFER_TYPE_MARGIN_CONFISCATED: Margin confiscated from margin account to fulfil closeout\n - TRANSFER_TYPE_MAKER_FEE_PAY: Maker fee paid from general account\n - TRANSFER_TYPE_MAKER_FEE_RECEIVE: Maker fee received into general account\n - TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY: Infrastructure fee paid from general account\n - TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE: Infrastructure fee received into general account\n - TRANSFER_TYPE_LIQUIDITY_FEE_PAY: Liquidity fee paid from general account\n - TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE: Liquidity fee received into general account\n - TRANSFER_TYPE_BOND_LOW: Bond account funded from general account to meet required bond amount\n - TRANSFER_TYPE_BOND_HIGH: Bond returned to general account after liquidity commitment was reduced\n - TRANSFER_TYPE_WITHDRAW: Funds withdrawn from general account\n - TRANSFER_TYPE_DEPOSIT: Funds deposited to general account\n - TRANSFER_TYPE_BOND_SLASHING: Bond account penalised when liquidity commitment not met\n - TRANSFER_TYPE_REWARD_PAYOUT: Reward payout received\n - TRANSFER_TYPE_TRANSFER_FUNDS_SEND: Internal Vega network instruction for the collateral engine to move funds from a user's general account into the pending transfers pool\n - TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE: Internal Vega network instruction for the collateral engine to move funds from the pending transfers pool account into the destination account\n - TRANSFER_TYPE_CLEAR_ACCOUNT: Market-related accounts emptied because market has closed\n - TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE: Balances restored after network restart\n - TRANSFER_TYPE_SPOT: Spot trade delivery\n - TRANSFER_TYPE_HOLDING_LOCK: An internal instruction to transfer a quantity corresponding to an active spot order from a general account into a party holding account.\n - TRANSFER_TYPE_HOLDING_RELEASE: An internal instruction to transfer an excess quantity corresponding to an active spot order from a holding account into a party general account.\n - TRANSFER_TYPE_SUCCESSOR_INSURANCE_FRACTION: Insurance pool fraction transfer from parent to successor market.\n - TRANSFER_TYPE_LIQUIDITY_FEE_ALLOCATE: Allocates liquidity fee earnings to each liquidity provider's network controlled liquidity fee account.\n - TRANSFER_TYPE_LIQUIDITY_FEE_NET_DISTRIBUTE: Distributes net fee earnings from liquidity provider's fee account to their general account.\n - TRANSFER_TYPE_SLA_PENALTY_BOND_APPLY: Applies SLA penalty by moving funds from party's bond account to market's insurance pool.\n - TRANSFER_TYPE_SLA_PENALTY_LP_FEE_APPLY: Applies SLA penalty by moving funds from the liquidity provider's fee account to market insurance pool.\n - TRANSFER_TYPE_LIQUIDITY_FEE_UNPAID_COLLECT: Collects penalties from the liquidity provider's fee account before the fee revenue is paid, and transfers it to the market's bonus distribution account.\n - TRANSFER_TYPE_SLA_PERFORMANCE_BONUS_DISTRIBUTE: Distributes performance bonus from market bonus to liquidity provider's general account.\n - TRANSFER_TYPE_PERPETUALS_FUNDING_LOSS: Funds deducted from margin account after a perpetuals funding loss.\n - TRANSFER_TYPE_PERPETUALS_FUNDING_WIN: Funds added to margin account after a perpetuals funding gain.\n - TRANSFER_TYPE_REWARDS_VESTED: Funds moved from the vesting account to the vested account once the vesting period is reached.\n - TRANSFER_TYPE_FEE_REFERRER_REWARD_PAY: Fee referrer reward paid from general account.\n - TRANSFER_TYPE_FEE_REFERRER_REWARD_DISTRIBUTE: Fee referrer reward received into general account of the referrer.\n - TRANSFER_TYPE_ORDER_MARGIN_LOW: Funds transferred from general account to meet order margin requirement in isolated margin mode.\n - TRANSFER_TYPE_ORDER_MARGIN_HIGH: Excess order margin amount returned to general account.\n - TRANSFER_TYPE_ISOLATED_MARGIN_LOW: Transfer from order margin account to margin account due to increase of position.\n - TRANSFER_TYPE_ISOLATED_MARGIN_HIGH: Transfer from excess order margin account to general account.\n - TRANSFER_TYPE_AMM_LOW: Transfer from a party's general account to their AMM's general account.\n - TRANSFER_TYPE_AMM_HIGH: Transfer from an AMM's general account to their owner's general account.\n - TRANSFER_TYPE_AMM_RELEASE: Transfer releasing an AMM's general account upon closure.\n - TRANSFER_TYPE_TREASURY_FEE_PAY: Treasury fee paid from party's general account.\n - TRANSFER_TYPE_BUY_BACK_FEE_PAY: Buy-back fee paid into network buy-back account.\n - TRANSFER_TYPE_HIGH_MAKER_FEE_REBATE_PAY: High-volume maker fee paid from general account\n - TRANSFER_TYPE_HIGH_MAKER_FEE_REBATE_RECEIVE: Maker fee received into general account",
      "title": "Transfers can occur between parties on Vega, these are the types that indicate why a transfer took place"
    },
    "vegaUpdateAsset": {
      "type": "object",
      "properties": {
        "assetId": {
          "type": "string",
          "description": "Asset ID the update is for."
        },
        "changes": {
          "$ref": "#/definitions/vegaAssetDetailsUpdate",
          "description": "Changes to apply on an existing asset."
        }
      },
      "title": "Update an existing asset on Vega"
    },
    "vegaUpdateFutureProduct": {
      "type": "object",
      "properties": {
        "quoteName": {
          "type": "string",
          "description": "Human-readable name/abbreviation of the quote name."
        },
        "dataSourceSpecForSettlementData": {
          "$ref": "#/definitions/vegaDataSourceDefinition",
          "description": "The data source spec describing the data of settlement data."
        },
        "dataSourceSpecForTradingTermination": {
          "$ref": "#/definitions/vegaDataSourceDefinition",
          "description": "The data source spec describing the data source for trading termination."
        },
        "dataSourceSpecBinding": {
          "$ref": "#/definitions/vegaDataSourceSpecToFutureBinding",
          "description": "The binding between the data source spec and the settlement data."
        }
      },
      "title": "Future product configuration"
    },
    "vegaUpdateInstrumentConfiguration": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "Instrument code, human-readable shortcode used to describe the instrument."
        },
        "name": {
          "type": "string",
          "title": "Instrument name"
        },
        "future": {
          "$ref": "#/definitions/vegaUpdateFutureProduct",
          "description": "Future."
        },
        "perpetual": {
          "$ref": "#/definitions/vegaUpdatePerpetualProduct",
          "description": "Perpetual."
        }
      },
      "title": "Instrument configuration"
    },
    "vegaUpdateMarket": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market ID the update is for."
        },
        "changes": {
          "$ref": "#/definitions/vegaUpdateMarketConfiguration",
          "description": "Updated configuration of the futures market."
        }
      },
      "title": "Update an existing market on Vega"
    },
    "vegaUpdateMarketConfiguration": {
      "type": "object",
      "properties": {
        "instrument": {
          "$ref": "#/definitions/vegaUpdateInstrumentConfiguration",
          "description": "Updated futures market instrument configuration."
        },
        "metadata": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Optional futures market metadata, tags."
        },
        "priceMonitoringParameters": {
          "$ref": "#/definitions/vegaPriceMonitoringParameters",
          "description": "Price monitoring parameters."
        },
        "liquidityMonitoringParameters": {
          "$ref": "#/definitions/vegaLiquidityMonitoringParameters",
          "description": "Liquidity monitoring parameters."
        },
        "simple": {
          "$ref": "#/definitions/vegaSimpleModelParams",
          "description": "Simple risk model parameters, valid only if MODEL_SIMPLE is selected."
        },
        "logNormal": {
          "$ref": "#/definitions/vegaLogNormalRiskModel",
          "description": "Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected."
        },
        "lpPriceRange": {
          "type": "string",
          "description": "DEPRECATED: Use liquidity SLA parameters instead.\nPercentage move up and down from the mid price which specifies the range of\nprice levels over which automated liquidity provisions will be deployed."
        },
        "linearSlippageFactor": {
          "type": "string",
          "description": "Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume."
        },
        "quadraticSlippageFactor": {
          "type": "string",
          "description": "Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume."
        },
        "liquiditySlaParameters": {
          "$ref": "#/definitions/vegaLiquiditySLAParameters",
          "title": "Liquidity SLA parameters"
        },
        "liquidityFeeSettings": {
          "$ref": "#/definitions/vegaLiquidityFeeSettings",
          "description": "Specifies how the liquidity fee for the market will be calculated."
        },
        "liquidationStrategy": {
          "$ref": "#/definitions/vegaLiquidationStrategy",
          "title": "Liquidation strategy parameters"
        },
        "markPriceConfiguration": {
          "$ref": "#/definitions/vegaCompositePriceConfiguration",
          "description": "Mark price configuration."
        },
        "tickSize": {
          "type": "string",
          "title": "The market tick size defines the minimum change in quote price for the market"
        },
        "enableTransactionReordering": {
          "type": "boolean",
          "title": "If enabled aggressive orders sent to the market will be delayed by the configured number of blocks"
        }
      },
      "title": "Configuration to update a futures market on Vega"
    },
    "vegaUpdateMarketState": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaUpdateMarketStateConfiguration",
          "title": "Configuration for governance-initiated change of a market's state"
        }
      }
    },
    "vegaUpdateMarketStateConfiguration": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "title": "ID of the market"
        },
        "updateType": {
          "$ref": "#/definitions/vegaMarketStateUpdateType",
          "title": "Type of the market update"
        },
        "price": {
          "type": "string",
          "title": "Settlement price, relevant only for market termination for futures markets"
        }
      }
    },
    "vegaUpdateNetworkParameter": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaNetworkParameter",
          "description": "The network parameter to update."
        }
      },
      "title": "Update network configuration on Vega"
    },
    "vegaUpdatePerpetualProduct": {
      "type": "object",
      "properties": {
        "quoteName": {
          "type": "string",
          "description": "Human-readable name/abbreviation of the quote name."
        },
        "marginFundingFactor": {
          "type": "string",
          "description": "Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1]."
        },
        "interestRate": {
          "type": "string",
          "description": "Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1]."
        },
        "clampLowerBound": {
          "type": "string",
          "description": "Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]."
        },
        "clampUpperBound": {
          "type": "string",
          "description": "Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]."
        },
        "dataSourceSpecForSettlementSchedule": {
          "$ref": "#/definitions/vegaDataSourceDefinition",
          "description": "Data source spec describing the data source for settlement schedule."
        },
        "dataSourceSpecForSettlementData": {
          "$ref": "#/definitions/vegaDataSourceDefinition",
          "description": "Data source spec describing the data source for settlement."
        },
        "dataSourceSpecBinding": {
          "$ref": "#/definitions/vegaDataSourceSpecToPerpetualBinding",
          "description": "Binding between the data source spec and the settlement data."
        },
        "fundingRateScalingFactor": {
          "type": "string",
          "description": "Factor applied to funding-rates. This scales the impact that spot price deviations have on funding payments."
        },
        "fundingRateLowerBound": {
          "type": "string",
          "description": "Lower bound for the funding-rate such that the funding-rate will never be lower than this value."
        },
        "fundingRateUpperBound": {
          "type": "string",
          "description": "Upper bound for the funding-rate such that the funding-rate will never be higher than this value."
        },
        "internalCompositePriceConfiguration": {
          "$ref": "#/definitions/vegaCompositePriceConfiguration",
          "description": "Configuration for the internal composite price used in funding payment calculation."
        }
      },
      "title": "Perpetual product configuration"
    },
    "vegaUpdateReferralProgram": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaReferralProgramChanges",
          "description": "Configuration for change to update a referral program."
        }
      }
    },
    "vegaUpdateSpotInstrumentConfiguration": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "Instrument code, human-readable shortcode used to describe the instrument."
        },
        "name": {
          "type": "string",
          "title": "Instrument name"
        }
      }
    },
    "vegaUpdateSpotMarket": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "Market ID the update is for."
        },
        "changes": {
          "$ref": "#/definitions/vegaUpdateSpotMarketConfiguration",
          "description": "Updated configuration of the spot market."
        }
      },
      "title": "Update an existing spot market on Vega"
    },
    "vegaUpdateSpotMarketConfiguration": {
      "type": "object",
      "properties": {
        "metadata": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Optional spot market metadata, tags."
        },
        "priceMonitoringParameters": {
          "$ref": "#/definitions/vegaPriceMonitoringParameters",
          "description": "Price monitoring parameters."
        },
        "targetStakeParameters": {
          "$ref": "#/definitions/vegaTargetStakeParameters",
          "description": "Specifies parameters related to target stake calculation."
        },
        "simple": {
          "$ref": "#/definitions/vegaSimpleModelParams",
          "description": "Simple risk model parameters, valid only if MODEL_SIMPLE is selected."
        },
        "logNormal": {
          "$ref": "#/definitions/vegaLogNormalRiskModel",
          "description": "Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected."
        },
        "slaParams": {
          "$ref": "#/definitions/vegaLiquiditySLAParameters",
          "description": "Specifies the liquidity provision SLA parameters."
        },
        "liquidityFeeSettings": {
          "$ref": "#/definitions/vegaLiquidityFeeSettings",
          "description": "Specifies how the liquidity fee for the market will be calculated."
        },
        "tickSize": {
          "type": "string",
          "title": "The market tick size defines the minimum change in quote price for the market"
        },
        "instrument": {
          "$ref": "#/definitions/vegaUpdateSpotInstrumentConfiguration",
          "description": "Specifies the name and code of the spot instrument."
        },
        "enableTransactionReordering": {
          "type": "boolean",
          "title": "If enabled aggressive orders sent to the market will be delayed by the configured number of blocks"
        }
      },
      "title": "Configuration to update a spot market on Vega"
    },
    "vegaUpdateVolumeDiscountProgram": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaVolumeDiscountProgramChanges",
          "title": "Configuration for a change to update a volume discount program"
        }
      }
    },
    "vegaUpdateVolumeRebateProgram": {
      "type": "object",
      "properties": {
        "changes": {
          "$ref": "#/definitions/vegaVolumeRebateProgramChanges",
          "title": "Configuration for a change to update a volume rebate program"
        }
      }
    },
    "vegaVolumeBenefitTier": {
      "type": "object",
      "properties": {
        "minimumRunningNotionalTakerVolume": {
          "type": "string",
          "description": "Required running notional taker volume in quantum units for parties\nto access this tier."
        },
        "volumeDiscountFactor": {
          "type": "string",
          "title": "deprecated"
        },
        "volumeDiscountFactors": {
          "$ref": "#/definitions/vegaDiscountFactors",
          "description": "Proportion of the taker fees to be discounted."
        }
      }
    },
    "vegaVolumeDiscountProgram": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "uint64",
          "description": "Incremental version of the program. It is incremented after each program\nupdate."
        },
        "id": {
          "type": "string",
          "description": "Unique ID generated from the proposal that created this program."
        },
        "benefitTiers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaVolumeBenefitTier"
          },
          "description": "Defined benefit tiers ordered by increasing discounts."
        },
        "endOfProgramTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix seconds, after which when the current epoch\nends, the program will end and benefits will be disabled."
        },
        "windowLength": {
          "type": "string",
          "format": "uint64",
          "description": "Number of epochs over which a referral set's running volume is evaluated."
        }
      }
    },
    "vegaVolumeDiscountProgramChanges": {
      "type": "object",
      "properties": {
        "benefitTiers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaVolumeBenefitTier"
          },
          "description": "Defined benefit tiers in increasing order. First element will give Tier 1,\nsecond element will give Tier 2, and so on. Determines the level of\nbenefit a party can expect based on performance criteria."
        },
        "endOfProgramTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp as Unix time in seconds, after which when the current epoch\nends, the program will end and benefits will be disabled."
        },
        "windowLength": {
          "type": "string",
          "format": "uint64",
          "description": "Number of epochs over which to evaluate a referral set's running volume."
        }
      }
    },
    "vegaVolumeRebateBenefitTier": {
      "type": "object",
      "properties": {
        "minimumPartyMakerVolumeFraction": {
          "type": "string",
          "description": "Fraction of a party's maker volume required for a party to access this tier."
        },
        "additionalMakerRebate": {
          "type": "string",
          "description": "Additional rebate factor, based on the 'trade value for fee purposes', that a party at this tier will receive when they are the maker side of a trade."
        }
      }
    },
    "vegaVolumeRebateProgram": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "uint64",
          "description": "Incremental version of the program. It is incremented after each program\nupdate."
        },
        "id": {
          "type": "string",
          "description": "Unique ID generated from the proposal that created this program."
        },
        "benefitTiers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaVolumeRebateBenefitTier"
          },
          "description": "Defined benefit tiers ordered by increasing rebates."
        },
        "endOfProgramTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix seconds, after which when the current epoch\nends, the program will end and benefits will be disabled."
        },
        "windowLength": {
          "type": "string",
          "format": "uint64",
          "description": "Number of epochs over which a referral set's running volume is evaluated."
        }
      }
    },
    "vegaVolumeRebateProgramChanges": {
      "type": "object",
      "properties": {
        "benefitTiers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaVolumeRebateBenefitTier"
          },
          "description": "Defined benefit tiers in increasing order. First element will give Tier 1,\nsecond element will give Tier 2, and so on. Determines the level of\nbenefit a party can expect based on performance criteria."
        },
        "endOfProgramTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp as Unix time in seconds, after which when the current epoch\nends, the program will end and benefits will be disabled."
        },
        "windowLength": {
          "type": "string",
          "format": "uint64",
          "description": "Number of epochs over which to evaluate a referral set's running volume."
        }
      }
    },
    "vegaVote": {
      "type": "object",
      "properties": {
        "partyId": {
          "type": "string",
          "description": "Voter's party ID."
        },
        "value": {
          "$ref": "#/definitions/vegaVoteValue",
          "description": "Which way the party voted."
        },
        "proposalId": {
          "type": "string",
          "description": "Proposal ID being voted on."
        },
        "timestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp in Unix nanoseconds when the vote was acknowledged by the network."
        },
        "totalGovernanceTokenBalance": {
          "type": "string",
          "description": "Total number of governance token for the party that cast the vote."
        },
        "totalGovernanceTokenWeight": {
          "type": "string",
          "description": "The weight of this vote based on the total number of governance tokens."
        },
        "totalEquityLikeShareWeight": {
          "type": "string",
          "description": "The weight of the vote compared to the total amount of equity-like share on the market. It is only populated if the vote is for a single type proposal."
        },
        "elsPerMarket": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/vegaVoteELSPair"
          },
          "description": "The per market weight of the vote compared to the total amount of equity-like share on the market.. It is only populated if the vote is for a batch type proposal."
        }
      },
      "title": "Governance vote"
    },
    "vegaVoteELSPair": {
      "type": "object",
      "properties": {
        "marketId": {
          "type": "string",
          "description": "The market ID."
        },
        "els": {
          "type": "string",
          "description": "The equity-like share weight for this market."
        }
      }
    },
    "vegaVoteValue": {
      "type": "string",
      "enum": [
        "VALUE_UNSPECIFIED",
        "VALUE_NO",
        "VALUE_YES"
      ],
      "default": "VALUE_UNSPECIFIED",
      "description": "- VALUE_UNSPECIFIED: Default value, always invalid\n - VALUE_NO: Vote against the proposal\n - VALUE_YES: Vote in favour of the proposal",
      "title": "Vote value"
    },
    "vegaWithdrawExt": {
      "type": "object",
      "properties": {
        "erc20": {
          "$ref": "#/definitions/vegaErc20WithdrawExt",
          "description": "ERC20 withdrawal details."
        }
      },
      "title": "Withdrawal external details"
    },
    "vegaWithdrawal": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique ID for the withdrawal."
        },
        "partyId": {
          "type": "string",
          "description": "Unique party ID of the user initiating the withdrawal."
        },
        "amount": {
          "type": "string",
          "description": "Amount to be withdrawn. This field is an unsigned integer scaled to the asset's decimal places."
        },
        "asset": {
          "type": "string",
          "description": "Asset to withdraw funds from."
        },
        "status": {
          "$ref": "#/definitions/vegaWithdrawalStatus",
          "description": "Status of the withdrawal."
        },
        "ref": {
          "type": "string",
          "description": "Reference which is used by the foreign chain\nto refer to this withdrawal."
        },
        "txHash": {
          "type": "string",
          "description": "Hash of the foreign chain for this transaction."
        },
        "createdTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the network started to process this withdrawal."
        },
        "withdrawnTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp for when the withdrawal was finalised by the network."
        },
        "ext": {
          "$ref": "#/definitions/vegaWithdrawExt",
          "description": "Foreign chain specifics."
        }
      },
      "title": "Withdrawal from the Vega network"
    },
    "vegaWithdrawalStatus": {
      "type": "string",
      "enum": [
        "STATUS_UNSPECIFIED",
        "STATUS_OPEN",
        "STATUS_REJECTED",
        "STATUS_FINALIZED"
      ],
      "default": "STATUS_UNSPECIFIED",
      "description": "- STATUS_UNSPECIFIED: Default value, always invalid\n - STATUS_OPEN: Withdrawal is open and being processed by the network\n - STATUS_REJECTED: Withdrawal have been cancelled\n - STATUS_FINALIZED: Withdrawal went through and is fully finalised, the funds are removed from the\nVega network and are unlocked on the foreign chain bridge, for example, on the Ethereum network",
      "title": "Status of the withdrawal"
    },
    "vegacommandsv1OneOffTransfer": {
      "type": "object",
      "properties": {
        "deliverOn": {
          "type": "string",
          "format": "int64",
          "description": "Timestamp, in Unix nanoseconds, for when the transfer should be executed, i.e., assets transferred into the receiver's account."
        }
      },
      "description": "Details for a one-off transfer."
    },
    "vegacommandsv1RecurringTransfer": {
      "type": "object",
      "properties": {
        "startEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "First epoch from which this transfer shall be executed."
        },
        "endEpoch": {
          "type": "string",
          "format": "uint64",
          "description": "Last epoch at which this transfer shall be executed."
        },
        "factor": {
          "type": "string",
          "description": "Factor that the initial transfer amount is multiplied by for each epoch that it is executed.\nFor example if the initial transfer amount is 1000 and the factor is 0.5, then the amounts transferred per epoch will be 1000, 500, 250, 125, etc."
        },
        "dispatchStrategy": {
          "$ref": "#/definitions/vegaDispatchStrategy",
          "description": "Optional parameter defining how a transfer is dispatched."
        }
      },
      "title": "Details for a recurring transfer"
    },
    "vegacommandsv1Transfer": {
      "type": "object",
      "properties": {
        "fromAccountType": {
          "$ref": "#/definitions/vegaAccountType",
          "description": "Account type from which the funds of the party should be taken."
        },
        "to": {
          "type": "string",
          "description": "Public key of the destination account."
        },
        "toAccountType": {
          "$ref": "#/definitions/vegaAccountType",
          "description": "Type of the destination account."
        },
        "asset": {
          "type": "string",
          "description": "Asset ID of the asset to be transferred."
        },
        "amount": {
          "type": "string",
          "description": "Amount to be taken from the source account, as an unsigned integer scaled to the asset's decimal places."
        },
        "reference": {
          "type": "string",
          "description": "Reference to be attached to the transfer."
        },
        "from": {
          "type": "string",
          "description": "AMM key from which assets are to be transferred, if applicable.\nThe submitter of the transaction must be the owner of this AMM key.\nIf provided, the 'from_account_type' must be REWARDS_VESTED, and the asset in this account\nmust match the asset specified in the transfer."
        },
        "oneOff": {
          "$ref": "#/definitions/vegacommandsv1OneOffTransfer",
          "description": "Details of a one-off transfer that is executed once at a specified time."
        },
        "recurring": {
          "$ref": "#/definitions/vegacommandsv1RecurringTransfer",
          "description": "Details of a transfer that is executed once every epoch until stopped."
        }
      },
      "title": "Command that allows a party to move assets from one account to another.\nA transfer can be set up as a single one-off transfer, or a recurring transfer that occurs once at the start of each epoch.\nEach transfer incurs a fee as specified by the network parameter `transfer.fee.factor`"
    },
    "vegaeventsv1OneOffTransfer": {
      "type": "object",
      "properties": {
        "deliverOn": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "vegaeventsv1RecurringTransfer": {
      "type": "object",
      "properties": {
        "startEpoch": {
          "type": "string",
          "format": "uint64"
        },
        "endEpoch": {
          "type": "string",
          "format": "uint64"
        },
        "factor": {
          "type": "string"
        },
        "dispatchStrategy": {
          "$ref": "#/definitions/vegaDispatchStrategy"
        }
      }
    },
    "vegaeventsv1Transfer": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "from": {
          "type": "string"
        },
        "fromAccountType": {
          "$ref": "#/definitions/vegaAccountType"
        },
        "to": {
          "type": "string"
        },
        "toAccountType": {
          "$ref": "#/definitions/vegaAccountType"
        },
        "asset": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        },
        "reference": {
          "type": "string"
        },
        "status": {
          "$ref": "#/definitions/v1TransferStatus"
        },
        "timestamp": {
          "type": "string",
          "format": "int64"
        },
        "reason": {
          "type": "string"
        },
        "gameId": {
          "type": "string",
          "title": "ID of the game this transfer was made in relation to. A transfer is made to members of a team\nor participants who take part in a game and are rewarded for their participation"
        },
        "oneOff": {
          "$ref": "#/definitions/vegaeventsv1OneOffTransfer"
        },
        "recurring": {
          "$ref": "#/definitions/vegaeventsv1RecurringTransfer"
        },
        "oneOffGovernance": {
          "$ref": "#/definitions/v1OneOffGovernanceTransfer"
        },
        "recurringGovernance": {
          "$ref": "#/definitions/v1RecurringGovernanceTransfer"
        }
      }
    }
  }
}
